// ==UserScript==
// @name         go kill 7
// @namespace    https://bintang500.dev/
// @version      1.0
// @description  Chess.com assistant that finds the best move using a Stockfish engine.
// @author       nanda
// @license      MIT
// @icon         https://images-wixmp-ed30a86b8c4ca887773594c2.wixmp.com/f/8a9db7bb-486f-4f74-ba59-513e78b175c4/dfy1l6k-3891a94b-1b8b-4d35-b0e5-c28da471c789.png
// @match        https://www.chess.com/*
// @match        https://www.chess.com/daily
// @match        https://www.chess.com/play/*
// @match        https://www.chess.com/game/*
// @match        https://www.chess.com/puzzles/*
// @require      https://cdnjs.cloudflare.com/ajax/libs/jquery/3.7.1/jquery.min.js
// @require      https://cdnjs.cloudflare.com/ajax/libs/chess.js/0.12.0/chess.min.js
// @require      https://cdnjs.cloudflare.com/ajax/libs/chessboard-js/1.0.0/chessboard-1.0.0.min.js
// @resource     stockfish.js      https://raw.githubusercontent.com/sayfpack13/chess-analysis-bot/main/tampermonkey%20script/content/stockfish-2018.js
// @resource    stockfish-2018.js   https://raw.githubusercontent.com/sayfpack13/chess-analysis-bot/main/tampermonkey%20script/content/stockfish-2018.js
// @run-at       document-idle
// @grant        GM_getValue
// @grant        GM_setValue
// @grant        GM_getResourceText
// @grant        GM_registerMenuCommand
// @grant        GM_info
// @grant        GM_xmlhttpRequest
// @connect      localhost
// @antifeature  membership
// ==/UserScript==

/* global Chess, $,+, checkAndSetupLevelPersistence, isMyTurn , setupEngineSelector, myVars, main, playChessExample,DEFAULT_SETTINGS,jQuery, originalConsoleLog */

/*
     ______         _____  ______  _______
    |  ____ |      |     | |_____] |_____| |
    |_____| |_____ |_____| |_____] |     | |_____


Code below this point runs on any site, including the GUI.
*/
(function() {
    'use strict';
    const API_URL = 'https://unpkg.com/@chrisoakman/chessboardjs@1.0.0/dist/chessboard-1.0.0.min.css';


    // ===========================================================================================================================================
    // Inisialisasi variabel global
    // ===========================================================================================================================================
    if (typeof window.myVars === 'undefined') window.myVars = {};

    // Flag logging
    window.myVars.stopLogging = false;

    // ===========================================================================================================================================
    // Fungsi global pengganti myFunctions.setLoggingEnabled
    // ===========================================================================================================================================
    function setLoggingEnabled(enabled) {
        window.myVars.stopLogging = !enabled;

        if (!enabled) {
            originalConsoleLog("[System] Logging dimatikan (Game Over / manual).");
        } else {
            originalConsoleLog("[System] Logging diaktifkan kembali.");
        }
    }

    // ===========================================================================================================================================
    // Helper DOM
    // ===========================================================================================================================================
    function qs(sel) { return document.querySelector(sel); }

    // ===========================================================================================================================================
    // Ambil objek board
    // ===========================================================================================================================================
    function getBoard() {
        const boardEl = qs('wc-chess-board') || qs('chess-board') || qs('.board');
        return boardEl?.game || qs('.game-board')?.game || null;
    }

    // ===========================================================================================================================================
    // jQuery alias (DIPERBAIKI)
    // ===========================================================================================================================================
    // ===========================================================================================================================================
    // jQuery alias
    // ===========================================================================================================================================
    // Mengecek apakah jQuery ada di scope internal (dari @require) atau di scope window (dari website)
    const $ = (typeof jQuery !== 'undefined') ? jQuery : (typeof window !== 'undefined' && window.jQuery ? window.jQuery : null);

    if (!$) {
        console.warn("[System] jQuery tidak ditemukan â€” fitur tertentu mungkin tidak berjalan.");
    }
    // ===========================================================================================================================================
    //
    // ===========================================================================================================================================
    /*
    _______ _     _ _______ _______ _______      _______ _____ _______ _______ _______
    |       |_____| |______ |______ |______      |______   |      |    |______ |______
    |_____  |     | |______ ______| ______|      ______| __|__    |    |______ ______|


Code below this point only runs on chess sites, not on the GUI itself.
*/
    function main() {
        console.log("Chess.com script is starting up...");

        window.myVars = Object.assign(window.myVars || {}, {
            // ===================================================================
            // --- ENGINE & DELAY SETTINGS ---
            // ===================================================================
            autoMovePiece: GM_getValue('autoMovePiece', false),
            autoRun: GM_getValue('autoRun', false),

            minDelay: GM_getValue('minDelay', 0.1),
            maxDelay: GM_getValue('maxDelay', 5),

            useSecondDelay: GM_getValue('useSecondDelay', false),
            minDelayTwo: GM_getValue('minDelayTwo', 0.1),
            maxDelayTwo: GM_getValue('maxDelayTwo', 0.1),

            moveClickDelay: GM_getValue('moveClickDelay', 1000),
            engineTimeoutMs: GM_getValue('engineTimeoutMs', 30000),

            lastRecordedBestMove: null,
            autoRunTimeoutId: null,
            retryTimer: null,

            // ===================================================================
            // --- BOT & PREMOVE ---
            // ===================================================================
            premoveMode: GM_getValue('premoveMode', 'every'),
            premovePieces: GM_getValue('premovePieces', { q:1, r:1, b:1, n:1, k:1, p:1 }),
            premoveChance: GM_getValue('premoveChance', 85),
            premoveMove: null,
            premoveFen: null,

            premoveEnabled: true,
            autoMoveEnabled: false,

            autoResignEnabled: GM_getValue('autoResignEnabled', false),
            autoResignThreshold: GM_getValue('autoResignThreshold', 5),
            autoResignThresholdCp: GM_getValue('autoResignThresholdCp', 1000),

            moveExecutionMode: GM_getValue('moveExecutionMode', 'drag'),
            isSmoothDragging: false,

            // ===================================================================
            // --- ELO & ENGINE ---
            // ===================================================================
            eloRating: GM_getValue('eloRating', 1800),
            skillLevel: GM_getValue('skillLevel', 10),
            customDepth: GM_getValue('customDepth', 24),
            defaultDepth: GM_getValue('defaultDepth', 24),
            maxDepthForElo: GM_getValue('maxDepthForElo', null),

            currentEngine: GM_getValue('currentEngine', 'Stockfish'),
            currentEngineName: 'Stockfish',

            // ===================================================================
            // --- STOCKFISH ADVANCED ---
            // ===================================================================
            showMultipleMoves: true,
            numberOfMovesToShow: 3,
            multiPv: 5,
            depth: 24,
            maxDepth: 24,

            // ===================================================================
            // --- UI / PANEL ---
            // ===================================================================
            panelTop: GM_getValue('panelTop', null),
            panelLeft: GM_getValue('panelLeft', null),
            panelState: GM_getValue('panelState', 'closed'),
            panelWidth: 300,
            panelHeight: 250,
            panelPosition: GM_getValue('panelPositionType', 'draggable'),

            // ===================================================================
            // --- COLORS ---
            // ===================================================================
            highlightColor1: GM_getValue('highlightColor1', '#eb6150'),
            highlightColor2: GM_getValue('highlightColor2', '#4287f5'),
            lightSquareColor: GM_getValue('lightSquareColor', '#f0d9b5'),
            darkSquareColor: GM_getValue('darkSquareColor', '#b58863'),
            whiteAdvantageColor: GM_getValue('whiteAdvantageColor', '#4287f5'),
            blackAdvantageColor: GM_getValue('blackAdvantageColor', '#eb6150'),

            // ===================================================================
            // --- ANALYSIS ---
            // ===================================================================
            analysisMode: GM_getValue('analysisMode', false),
            highlightEnabled: GM_getValue('highlightEnabled', false),
            autoAnalysisColor: GM_getValue('autoAnalysisColor', 'none'),
            analysisElo: 1350,

            isThinking: false,
            isAnalyzing: false,
            engineTimer: null,

            currentEvaluation: 0,
            previousEvaluation: 0,
            bestMoveEvaluation: null,

            topMoves: [],
            currentPvMoves: [],
            fenForPvDrawing: null,

            lastAnalyzedFen: null,
            lastObservedFen: null,

            // ===================================================================
            // --- HUMAN MODE ---
            // ===================================================================
            evaluationMode: GM_getValue('evaluationMode', 'engine'),
            humanMode: {
                active: false,
                level: GM_getValue('lastHumanLevelMode', 'intermediate'),
                elo: GM_getValue('eloRating', 1800),
                moveTime: { min: 3, max: 12 },
                errorRate: 0.15,
                blunderRate: 0.05
            },

            // ===================================================================
            // --- OPENING BOOK ---
            // ===================================================================
            autoMatchEnabled: GM_getValue('autoMatchEnabled', false),
            useOpeningBook: GM_getValue('useOpeningBook', true),
            maxOpeningBookMoves: GM_getValue('maxOpeningBookMoves', 10),
            selectedOpeningRepertoire: GM_getValue('selectedOpeningRepertoire', 'mixed'),

            openingBook: null,
            openingRepertoires: null,
            lastMoveFromBook: false,
            openingBookUsed: false,
            fromToDataLoaded: false,

            // ===================================================================
            // --- GAME / ACPL ---
            // ===================================================================
            hasAutoMatched: false,
            gameEnded: false,
            isGameOver: false,

            resignationPending: false,
            resignCompleted: false,

            totalCpl: 0,
            cplMoveCount: 0,
            acplDisplay: "0.00",

            totalCplWhite: 0,
            cplMoveCountWhite: 0,
            acplWhite: "0.00",

            totalCplBlack: 0,
            cplMoveCountBlack: 0,
            acplBlack: "0.00",

            // ===================================================================
            // --- CLOCK SYNC ---
            // ===================================================================
            clockSyncEnabled: GM_getValue('clockSyncEnabled', false),
            clockSync: false,

            lastOpponentTime: null,
            lastPlayerTime: null,

            clockSyncMinDelay: GM_getValue('clockSyncMinDelay', 0.5),
            clockSyncMaxDelay: GM_getValue('clockSyncMaxDelay', 5),
            clockSyncExactMatch: GM_getValue('clockSyncExactMatch', false),

            clockSyncCalculationTime: GM_getValue('clockSyncCalculationTime', 0.2),
            clockSyncTimePressure: GM_getValue('clockSyncTimePressure', true),
            clockSyncTimePressureThreshold: GM_getValue('clockSyncTimePressureThreshold', 20),
            clockSyncTimePressureActive: false,

            // ===================================================================
            // --- ENGINE STATE ---
            // ===================================================================
            stockfish: null,
            isEngineReady: false,

            currentFen: null,
            currentMove: null,
            currentDepth: 0,
            colorToMove: 'w',

            engineOn: true,
            premoveInterval: null,
            gameOverCheckInterval: null,

            debugMode: GM_getValue('debugMode', true),

            autoSyncElo: GM_getValue('autoSyncElo', true),
            opponentRating: 0,
            lastLogTime: 0,

            // ===================================================================
            // --- GAME OBJECT ---
            // ===================================================================
            game: new Chess(),

            // ===================================================================
            // --- EXTRA STATE (hasil audit) ---
            // ===================================================================
            engineErrorCount: 0,
            currentTurn: null,
            canGo: false,

            errorMoves: [],
            cachedFen: "",
            cachedFenTime: 0,

            lastArrow: null,
            lastHighlights: null,

            monitorStatus: "ok",

            // ===================================================================
            // --- VIRTUAL BOARD ---
            // ===================================================================
            virtualBoardFen: null,
            virtualBoardOrientation: 'white',
            virtualBoardLastMove: null,
            virtualBoardBestMove: null,
            useVirtualBoardArrows: true,
            virtualBoardBestMoves: []
        });

        // ===================================================================
        // --- RUNTIME FLAGS ---
        // ===================================================================
        myVars.autoRunCooldown = false;
        myVars.autoRunCooldownDelay = 10;


        // ===========================================================================================================================================
        //
        // ===========================================================================================================================================
        var myFunctions = document.myFunctions = window.myFunctions = window.myFunctions || {};

        // ===========================================================================
        // Runtime / Engine URLs + Styles
        // ===========================================================================
        let stockfishObjectURL = null;
        let analysisObjectURL = null;
        let dynamicStyles = null; // bisa digunakan jika perlu diubah di runtime

        // ===========================================================================
        // Runtime flags / state
        // ===========================================================================
        let isAnalysisThinking = false;
        let canGo = true;
        let myTurn = false;
        let autoStartTriggered = false;
        let lastValue = 11;

        // ======================================================================
        //
        // ======================================================================
        let board = null;
        let checkInterval = null;
        const engine = document.engine = document.engine || {}; // objek komunikasi engine
        let firstClickSquare = null;
        let isTwoClickModeActive = true;
        // Simpan state level terakhir di luar fungsi
        let lastAppliedLevel = null;
        const engineMoveHistory = []; // simpan langkah engine untuk history/log
        const evalHistory = []; // simpan history evaluasi (CPL)
        // ======================================================================
        // â™Ÿï¸ Virtual Board Lifecycle Manager (Hybrid API + DOM Fallback)
        // ======================================================================

        // ======================================================================
        // ðŸ›¡ï¸ INITIALIZATION GUARD
        // ======================================================================
        if (window.__ENGINE_INITIALIZED__) {
            console.warn("[Engine] Already initialized, skipping...");
            return;
        }
        window.__ENGINE_INITIALIZED__ = true;

        // ======================================================================
        // ðŸ“¦ CONSTANTS (Frozen to prevent mutation)
        // ======================================================================
        const ENGINE_STATE = Object.freeze({
            INIT: "INIT",
            READY: "READY",
            THINKING: "THINKING",
            RELOADING: "RELOADING",
            ERROR: "ERROR"
        });

        const CONFIG = Object.freeze({
            ENGINE_RELOAD_THROTTLE_MS: 5000,
            FEN_CACHE_TTL_MS: 150,
            MAX_ERROR_MOVES: 50,
            HEALTH_CHECK_INTERVAL_MS: 3000,
            MAX_ENGINE_ERRORS: 3
        });

        const PIECES = Object.freeze({
            'wK': 'â™”', 'wQ': 'â™•', 'wR': 'â™–', 'wB': 'â™—', 'wN': 'â™˜', 'wP': 'â™™',
            'bK': 'â™š', 'bQ': 'â™›', 'bR': 'â™œ', 'bB': 'â™', 'bN': 'â™ž', 'bP': 'â™Ÿ'
        });

        // ======================================================================
        // ðŸ—‘ï¸ RESOURCE TRACKER (For cleanup)
        // ======================================================================
        const ResourceTracker = {
            intervals: new Set(),
            timeouts: new Set(),
            eventListeners: [],
            domElements: new WeakSet(),

            addInterval(id) {
                this.intervals.add(id);
                return id;
            },

            addTimeout(id) {
                this.timeouts.add(id);
                return id;
            },

            addEventListener(target, event, handler, options) {
                target.addEventListener(event, handler, options);
                this.eventListeners.push({ target, event, handler, options });
            },

            trackDOMElement(el) {
                if (el) this.domElements.add(el);
            },

            clearInterval(id) {
                clearInterval(id);
                this.intervals.delete(id);
            },

            clearTimeout(id) {
                clearTimeout(id);
                this.timeouts.delete(id);
            },

            // ðŸ§¹ Master cleanup function
            dispose() {
                console.log("[ResourceTracker] Disposing all resources...");

                // Clear all intervals
                this.intervals.forEach(id => clearInterval(id));
                this.intervals.clear();

                // Clear all timeouts
                this.timeouts.forEach(id => clearTimeout(id));
                this.timeouts.clear();

                // Remove all event listeners
                this.eventListeners.forEach(({ target, event, handler, options }) => {
                    try {
                        target.removeEventListener(event, handler, options);
                    } catch (e) { /* ignore */ }
                });
                this.eventListeners.length = 0;

                console.log("[ResourceTracker] Cleanup complete.");
            }
        };

        // ======================================================================
        // ðŸ”„ STATE MANAGEMENT (Centralized)
        // ======================================================================
        const EngineStateManager = {
            _state: ENGINE_STATE.INIT,
            _errorCount: 0,
            _listeners: new Set(),

            get state() { return this._state; },
            get errorCount() { return this._errorCount; },

            setState(newState, reason = "") {
                // Guard: AutoRun OFF
                if (!myVars.autoRun) {
                    return false;
                }

                // Validate state
                if (!Object.values(ENGINE_STATE).includes(newState)) {
                    console.error(`[EngineState] Invalid state: ${newState}`);
                    return false;
                }

                const prevState = this._state;
                if (prevState === newState) return false; // No change

                console.log(`[EngineState] ${prevState} â†’ ${newState}${reason ? ` (${reason})` : ''}`);
                this._state = newState;

                // Reset error count on recovery
                if (newState === ENGINE_STATE.READY || newState === ENGINE_STATE.INIT) {
                    this._errorCount = 0;
                }

                // Update derived flags
                this._updateDerivedFlags();

                // Notify listeners
                this._notifyListeners(prevState, newState);

                return true;
            },

            incrementError() {
                this._errorCount = Math.min(this._errorCount + 1, CONFIG.MAX_ENGINE_ERRORS + 1);
                return this._errorCount;
            },

            resetErrors() {
                this._errorCount = 0;
            },

            _updateDerivedFlags() {
                myVars.isThinking = (this._state === ENGINE_STATE.THINKING);
                myVars.isEngineReady = (this._state === ENGINE_STATE.READY);
                myVars.engineRunning = this._state === ENGINE_STATE.READY ||
                    this._state === ENGINE_STATE.THINKING;
            },

            _notifyListeners(from, to) {
                const event = { from, to, timestamp: Date.now() };

                this._listeners.forEach(callback => {
                    try {
                        callback(event);
                    } catch (e) {
                        console.error("[EngineState] Listener error:", e);
                    }
                });

                // UI updates (safe calls)
                myFunctions.updateEngineUI?.(to);
                myFunctions.updateTurnStatus?.();
                myFunctions.emit?.("engineStateChanged", event);
                myFunctions.debugTurnState?.("EngineState", {
                    current: to,
                    errorCount: this._errorCount
                });
            },

            subscribe(callback) {
                this._listeners.add(callback);
                return () => this._listeners.delete(callback); // Unsubscribe function
            },

            dispose() {
                this._listeners.clear();
                this._state = ENGINE_STATE.INIT;
                this._errorCount = 0;
            }
        };

        // Expose to myFunctions
        myFunctions.setEngineState = (state, reason) => EngineStateManager.setState(state, reason);
        myFunctions.getEngineState = () => EngineStateManager.state;

        // ======================================================================
        // ðŸŽ¯ BOARD REFERENCE MANAGER
        // ======================================================================
        const BoardManager = {
            _boardRef: null,
            _lastRefreshTime: 0,
            _refreshCooldown: 100,

            getBoard() {
                const now = Date.now();
                if (this._boardRef && now - this._lastRefreshTime < this._refreshCooldown) {
                    return this._boardRef;
                }
                this.refresh();
                return this._boardRef;
            },

            refresh() {
                try {
                    if (typeof window.getBoard === 'function') {
                        this._boardRef = window.getBoard();
                    } else {
                        const el = document.querySelector(
                            'wc-chess-board, chess-board, .board, .game-board'
                        );
                        this._boardRef = el?.game || null;
                    }
                    this._lastRefreshTime = Date.now();
                } catch (e) {
                    console.warn("[BoardManager] Refresh failed:", e);
                    this._boardRef = null;
                }
            },

            isReady() {
                const board = this.getBoard();
                return !!(board && board.game);
            },

            dispose() {
                this._boardRef = null;
            }
        };

        // Legacy support
        function refreshBoardRef() {
            BoardManager.refresh();
            board = BoardManager.getBoard();
        }

        // ======================================================================
        // ðŸ” ENGINE LIFECYCLE MANAGER
        // ======================================================================
        const EngineLifecycle = {
            _lastReloadTime: 0,
            _isReloading: false,

            canReload() {
                if (this._isReloading) return false;
                if (EngineStateManager.state === ENGINE_STATE.RELOADING) return false;

                const now = Date.now();
                return (now - this._lastReloadTime) >= CONFIG.ENGINE_RELOAD_THROTTLE_MS;
            },

            async reload() {
                if (!this.canReload()) {
                    console.warn("[Engine] Reload blocked (throttled or in progress)");
                    return false;
                }

                this._isReloading = true;
                this._lastReloadTime = Date.now();
                EngineStateManager.setState(ENGINE_STATE.RELOADING, "Reloading...");

                try {
                    // Terminate existing worker
                    await this.terminateWorker();

                    // Load new engine
                    if (typeof myFunctions.loadChessEngine === "function") {
                        console.log("[Engine] Reloading Stockfish Worker...");
                        myFunctions.loadChessEngine();
                        return true;
                    }
                } catch (e) {
                    console.error("[Engine] Reload error:", e);
                    EngineStateManager.setState(ENGINE_STATE.ERROR, "Reload Failed");
                } finally {
                    this._isReloading = false;
                }

                return false;
            },

            async terminateWorker() {
                return new Promise((resolve) => {
                    try {
                        if (myVars.analysisEngine) {
                            // Give worker time to cleanup
                            myVars.analysisEngine.postMessage?.('quit');

                            const timeoutId = setTimeout(() => {
                                try {
                                    myVars.analysisEngine?.terminate();
                                } catch (e) { /* ignore */ }
                                myVars.analysisEngine = null;
                                resolve();
                            }, 100);

                            ResourceTracker.addTimeout(timeoutId);
                        } else {
                            resolve();
                        }
                    } catch (e) {
                        console.warn("[Engine] Terminate warning:", e);
                        myVars.analysisEngine = null;
                        resolve();
                    }
                });
            },

            dispose() {
                this.terminateWorker();
                this._lastReloadTime = 0;
                this._isReloading = false;
            }
        };

        // Legacy support
        function safeReloadEngine() {
            return EngineLifecycle.reload();
        }

        // ======================================================================
        // ðŸ§Š FEN CACHE (With TTL & Size limit)
        // ======================================================================
        const FenCache = {
            _cache: null,
            _timestamp: 0,
            _lastObserved: null,

            get(forceRefresh = false) {
                const now = Date.now();

                if (!forceRefresh &&
                    this._cache &&
                    (now - this._timestamp) < CONFIG.FEN_CACHE_TTL_MS) {
                    return this._cache;
                }

                const fen = myFunctions.getAccurateFen();

                if (fen && this.isValidFen(fen)) {
                    this._cache = fen;
                    this._timestamp = now;
                }

                return fen;
            },

            isValidFen(fen) {
                if (!fen || typeof fen !== 'string') return false;
                return fen.split(" ").length === 6;
            },

            setLastObserved(fen) {
                this._lastObserved = fen;
            },

            getLastObserved() {
                return this._lastObserved;
            },

            invalidate() {
                this._cache = null;
                this._timestamp = 0;
            },

            dispose() {
                this._cache = null;
                this._timestamp = 0;
                this._lastObserved = null;
            }
        };

        // Legacy support
        myFunctions.getStableFen = () => FenCache.get();

        // ======================================================================
        // â™Ÿï¸ FEN HELPERS (Optimized)
        // ======================================================================
        const FenHelpers = {
            FEN_MAP: Object.freeze({
                br: 'r', bn: 'n', bb: 'b', bq: 'q', bk: 'k', bp: 'p',
                wr: 'R', wn: 'N', wb: 'B', wq: 'Q', wk: 'K', wp: 'P'
            }),

            // Reusable Chess instance (avoid creating many instances)
            _chessInstance: null,

            getChessInstance() {
                if (!this._chessInstance && typeof Chess === 'function') {
                    this._chessInstance = new Chess();
                }
                return this._chessInstance;
            },

            resetChessInstance(fen = null) {
                const chess = this.getChessInstance();
                if (chess) {
                    if (fen) {
                        chess.load(fen);
                    } else {
                        chess.reset();
                    }
                }
                return chess;
            },

            buildPosition(pieces) {
                if (!pieces || !Array.isArray(pieces)) return '';

                try {
                    const rows = [];
                    for (let rank = 8; rank >= 1; rank--) {
                        let row = '';
                        let emptyCount = 0;

                        for (let f = 0; f < 8; f++) {
                            const fileChar = String.fromCharCode(97 + f); // 'a' = 97
                            const square = fileChar + rank;
                            const piece = pieces.find(p => p?.square === square);

                            if (piece) {
                                if (emptyCount > 0) {
                                    row += emptyCount;
                                    emptyCount = 0;
                                }
                                row += this.FEN_MAP[piece.piece] || '';
                            } else {
                                emptyCount++;
                            }
                        }

                        if (emptyCount > 0) row += emptyCount;
                        rows.push(row);
                    }

                    return rows.join('/');
                } catch (e) {
                    console.warn("[FenHelpers.buildPosition]", e);
                    return '';
                }
            },

            detectCastlingRights(pieces) {
                if (!pieces || !Array.isArray(pieces)) return '-';

                try {
                    let rights = '';
                    const has = (piece, square) =>
                    pieces.some(p => p.piece === piece && p.square === square);

                    if (has('wk', 'e1')) {
                        if (has('wr', 'h1')) rights += 'K';
                        if (has('wr', 'a1')) rights += 'Q';
                    }
                    if (has('bk', 'e8')) {
                        if (has('br', 'h8')) rights += 'k';
                        if (has('br', 'a8')) rights += 'q';
                    }

                    return rights || '-';
                } catch (e) {
                    console.warn("[FenHelpers.detectCastlingRights]", e);
                    return '-';
                }
            },

            getFullFen(pieces = [], moves = []) {
                // Priority 1: Chess.js replay (most accurate)
                if (typeof Chess === 'function' && moves.length > 0) {
                    try {
                        const game = this.resetChessInstance();
                        if (game) {
                            let valid = true;
                            for (const mv of moves) {
                                if (!game.move(mv, { sloppy: true })) {
                                    valid = false;
                                    break;
                                }
                            }
                            if (valid) return game.fen();
                        }
                    } catch (e) {
                        console.warn("[FenHelpers.getFullFen] Chess replay failed:", e);
                    }
                }

                // Priority 2: Manual reconstruction
                try {
                    const position = this.buildPosition(pieces) || '8/8/8/8/8/8/8/8';
                    const turn = moves.length % 2 === 0 ? 'w' : 'b';
                    const castling = this.detectCastlingRights(pieces);

                    return `${position} ${turn} ${castling} - 0 ${Math.floor(moves.length / 2) + 1}`;
                } catch (e) {
                    console.warn("[FenHelpers.getFullFen] Manual fallback failed:", e);
                    return '';
                }
            },

            dispose() {
                this._chessInstance = null;
            }
        };

        // Expose
        const fenHelpers = FenHelpers;

        // ======================================================================
        // ðŸŽ¯ GET ACCURATE FEN
        // ======================================================================
        myFunctions.getAccurateFen = function() {
            try {
                // A. Direct API access
                const board = BoardManager.getBoard();
                if (board?.getFen) return board.getFen();
                if (window.ChessComGame?.gameModel?.data?.fen) {
                    return window.ChessComGame.gameModel.data.fen;
                }

                // B. DOM Scraping fallback
                const pieceEls = qsa('chess-board .piece, wc-chess-board .piece, .board .piece');

                const pieces = pieceEls.map(el => {
                    const classes = el.className?.split(/\s+/) || [];
                    const pieceCode = classes.find(c => /^[wb][rnbqkp]$/i.test(c));
                    const squareClass = classes.find(c => c.startsWith('square-'));

                    if (!pieceCode || !squareClass) return null;

                    const coords = squareClass.replace('square-', '');
                    if (coords.length < 2) return null;

                    const file = String.fromCharCode(96 + parseInt(coords[0]));
                    const rank = parseInt(coords[1]);

                    if (isNaN(rank) || rank < 1 || rank > 8) return null;

                    return { square: file + rank, piece: pieceCode.toLowerCase() };
                }).filter(Boolean);

                // Get moves from move list
                const moves = getMoveListFromDOM();

                return FenHelpers.getFullFen(pieces, moves);
            } catch (e) {
                Logger.error('getAccurateFen', e);
                return '';
            }
        };

        // ======================================================================
        // ðŸ“ MOVE LIST PARSER
        // ======================================================================
        function getMoveListFromDOM() {
            try {
                const moveListEl = document.querySelector(
                    'vertical-move-list, wc-vertical-move-list, .move-list-container'
                );
                if (!moveListEl) return [];

                const text = moveListEl.innerText || "";
                return text.split(/\s+/).filter(m =>
                                                m &&
                                                !/^\d+\.?$/.test(m) &&
                                                !['1-0', '0-1', '1/2-1/2', '*'].includes(m)
                                               );
            } catch (e) {
                return [];
            }
        }

        // ======================================================================
        // ðŸ“Œ UTILITIES
        // ======================================================================
        function qsa(selector) {
            try {
                return Array.from(document.querySelectorAll(selector));
            } catch (e) {
                return [];
            }
        }

        function sleep(ms) {
            return new Promise(resolve => {
                const id = setTimeout(resolve, ms);
                ResourceTracker.addTimeout(id);
            });
        }

        function getSan(uci) {
            if (!uci) return uci;

            try {
                const fen = FenCache.get();
                if (!fen) return uci;

                const chess = FenHelpers.getChessInstance();
                if (!chess) return uci;

                chess.load(fen);
                const move = {
                    from: uci.slice(0, 2),
                    to: uci.slice(2, 4),
                    promotion: uci[4] || undefined
                };

                const result = chess.move(move, { sloppy: true });
                return result?.san || uci;
            } catch (e) {
                return uci;
            }
        }

        // ======================================================================
        // ðŸ§¾ LOGGER (Throttled)
        // ======================================================================
        const Logger = {
            _lastLogs: new Map(),
            _throttleMs: 1000,

            log(category, message, level = 'info') {
                const key = `${category}:${message}`;
                const now = Date.now();
                const last = this._lastLogs.get(key) || 0;

                if (now - last < this._throttleMs) return;

                this._lastLogs.set(key, now);

                // Limit map size
                if (this._lastLogs.size > 100) {
                    const firstKey = this._lastLogs.keys().next().value;
                    this._lastLogs.delete(firstKey);
                }

                const time = new Date().toLocaleTimeString();
                const line = `[${time}] [${category}] ${message}`;

                switch (level) {
                    case 'error': console.error(line); break;
                    case 'warn': console.warn(line); break;
                    default: console.log(line);
                }
            },

            error(category, error) {
                this.log(category, `Error: ${error?.message || error}`, 'error');
            },

            dispose() {
                this._lastLogs.clear();
            }
        };

        myFunctions.log = (cat, msg, level) => Logger.log(cat, msg, level);

        // ======================================================================
        // ðŸ§  HEALTH CHECK (Non-aggressive, Disposable)
        // ======================================================================
        const HealthChecker = {
            _intervalId: null,
            _isRunning: false,

            start() {
                if (this._intervalId) return;

                this._intervalId = setInterval(() => {
                    this.check();
                }, CONFIG.HEALTH_CHECK_INTERVAL_MS);

                ResourceTracker.addInterval(this._intervalId);
                console.log("[HealthChecker] Started");
            },

            stop() {
                if (this._intervalId) {
                    ResourceTracker.clearInterval(this._intervalId);
                    this._intervalId = null;
                }
                console.log("[HealthChecker] Stopped");
            },

            check() {
                if (this._isRunning) return { ok: true, skip: "already-running" };
                this._isRunning = true;

                try {
                    const board = BoardManager.getBoard();
                    if (!board?.game) {
                        return { ok: true, skipped: "board-not-ready" };
                    }

                    if (EngineStateManager.state === ENGINE_STATE.THINKING) {
                        return { ok: true, skip: "engine-thinking" };
                    }

                    // Check engine presence
                    const enginePresent = !!(typeof engine !== 'undefined' && engine?.engine);

                    if (!enginePresent) {
                        const errors = EngineStateManager.incrementError();
                        if (errors >= 2 && !myVars.isGameOver) {
                            EngineLifecycle.reload();
                        }
                        return { ok: false, enginePresent };
                    }

                    EngineStateManager.resetErrors();

                    // Validate FEN
                    const fen = FenCache.get();
                    if (!FenCache.isValidFen(fen)) {
                        return { ok: true, fenValid: false };
                    }

                    // New game detection
                    if (fen.startsWith("rnbqkbnr/pppppppp/8/8/8/8/PPPPPPPP/RNBQKBNR") &&
                        FenCache.getLastObserved()) {
                        EngineLifecycle.reload();
                        return { ok: true, newGame: true };
                    }

                    // AutoRun trigger
                    if (myVars.autoRun && EngineStateManager.state === ENGINE_STATE.READY) {
                        this._tryAutoRun(board);
                    }

                    return { ok: true };
                } catch (e) {
                    Logger.error('HealthCheck', e);
                    return { ok: false, error: e };
                } finally {
                    this._isRunning = false;
                }
            },

            _tryAutoRun(board) {
                try {
                    const turn = board.game?.getTurn?.();
                    const playingAs = board.game?.getPlayingAs?.();
                    if (turn && playingAs && turn === playingAs) {
                        myFunctions.runAnalysisMode?.();
                    }
                } catch (e) { /* ignore */ }
            },

            dispose() {
                this.stop();
                this._isRunning = false;
            }
        };

        myFunctions.checkScriptHealth = () => HealthChecker.check();

        // ======================================================================
        // ðŸ”„ RESCAN & RECOVERY
        // ======================================================================
        const RescanManager = {
            _errorMoves: [],
            _maxErrors: CONFIG.MAX_ERROR_MOVES,

            get errorMoves() { return [...this._errorMoves]; },

            async rescan() {
                console.log("[Rescan] Scanning board...");
                BoardManager.refresh();

                try {
                    const moves = getMoveListFromDOM();
                    if (typeof Chess !== 'function') return;

                    const tempGame = new Chess();
                    this._errorMoves = [];

                    for (const mvText of moves) {
                        const cleanMove = mvText.replace(/[?!#+]/g, '');
                        const res = tempGame.move(cleanMove, { sloppy: true });

                        if (!res) {
                            if (this._errorMoves.length < this._maxErrors) {
                                this._errorMoves.push(mvText);
                            }
                            console.warn(`[Rescan] Invalid move: ${mvText}`);
                        }
                    }

                    const finalFen = tempGame.fen();
                    console.log(`[Rescan] Reconstructed FEN: ${finalFen}`);

                    // Update caches
                    FenCache.setLastObserved(finalFen);
                    FenCache.invalidate();

                    // Update virtual board
                    myFunctions.updateVirtualChessboard?.();

                    // Trigger analysis if my turn
                    if (myVars.autoRun && !myVars.isGameOver) {
                        const turn = tempGame.turn();
                        const myColor = myFunctions.getBoardOrientation?.()[0];

                        if (turn === myColor) {
                            console.log("[Rescan] My turn, triggering analysis...");
                            myFunctions.checkAndRunAnalysisAutoMove?.();
                        }
                    }

                    if (this._errorMoves.length > 0) {
                        Logger.log('Rescan', `Error moves: ${this._errorMoves.length}`, 'warn');
                        UIManager.showRestoreButton(this._errorMoves.length);
                    }

                } catch (e) {
                    Logger.error('Rescan', e);
                }
            },

            dispose() {
                this._errorMoves = [];
            }
        };

        myFunctions.rescan = () => RescanManager.rescan();
        myVars.errorMoves = RescanManager.errorMoves;

        // ======================================================================
        // ðŸ”˜ UI MANAGER
        // ======================================================================
        const UIManager = {
            _buttonId: 'restoreErrorsBtn',

            showRestoreButton(errorCount) {
                this.removeRestoreButton();

                const container = document.getElementById('engineStatusPanel') || document.body;
                const btn = document.createElement('button');

                btn.id = this._buttonId;
                btn.textContent = `âš ï¸ Move Errors (${errorCount})`;
                btn.className = 'engine-button';
                btn.style.cssText = 'background-color:#e74c3c;cursor:pointer;';

                btn.onclick = () => {
                    alert(`Failed moves:\n${RescanManager.errorMoves.join(', ')}`);
                    this.removeRestoreButton();
                };

                container.appendChild(btn);
                ResourceTracker.trackDOMElement(btn);
            },

            removeRestoreButton() {
                const existing = document.getElementById(this._buttonId);
                if (existing) {
                    existing.onclick = null; // Remove event listener
                    existing.remove();
                }
            },

            dispose() {
                this.removeRestoreButton();
            }
        };

        myFunctions.injectRestoreButton = (count) => UIManager.showRestoreButton(count);

        // ======================================================================
        // ðŸš€ INITIALIZATION
        // ======================================================================
        function initialize() {
            console.log("[Engine] Initializing...");

            // Set initial state
            FenCache.invalidate();
            EngineStateManager.setState(ENGINE_STATE.READY, "Initial load");

            // Start health checker
            HealthChecker.start();

            console.log("[Engine] Initialization complete.");
        }

        // ======================================================================
        // ðŸ§¹ MASTER DISPOSE (Call on page unload)
        // ======================================================================
        function dispose() {
            console.log("[Engine] Disposing all resources...");

            HealthChecker.dispose();
            EngineLifecycle.dispose();
            EngineStateManager.dispose();
            BoardManager.dispose();
            FenCache.dispose();
            FenHelpers.dispose();
            RescanManager.dispose();
            UIManager.dispose();
            Logger.dispose();
            ResourceTracker.dispose();

            window.__ENGINE_INITIALIZED__ = false;
            console.log("[Engine] Disposal complete.");
        }

        // Expose dispose
        myFunctions.disposeEngine = dispose;

        // ======================================================================
        // ðŸ“¡ EVENT LISTENERS (Tracked)
        // ======================================================================
        ResourceTracker.addEventListener(window, 'load', initialize, { once: true });
        ResourceTracker.addEventListener(window, 'beforeunload', dispose);
        ResourceTracker.addEventListener(window, 'unload', dispose);

        // Visibility change handler (pause when hidden)
        ResourceTracker.addEventListener(document, 'visibilitychange', () => {
            if (document.hidden) {
                HealthChecker.stop();
            } else {
                HealthChecker.start();
            }
        });

        // ===========================================================================================================================================
        //                                                      âš™ï¸ (Monitor pesan eror â€“ STABLE, CLEAN, & SAFE) âš™ï¸
        // ===========================================================================================================================================
        // ===========================================================================
        // âš™ï¸  setMonitorStatus
        // ===========================================================================
        function setMonitorStatus(status) {
            const light = document.getElementById("monitorStatusLight");
            const label = light?.parentElement; // span SYSTEM MONITOR

            if (!light || !label) return;

            if (status === "error") {
                light.style.background = "#ff4444";
                light.style.boxShadow = "0 0 5px #ff4444";
                label.style.color = "#ff4444";
                label.textContent = "SYSTEM MONITOR (ERROR)";
            } else {
                light.style.background = "#4caf50";
                light.style.boxShadow = "0 0 5px #4caf50";
                label.style.color = "#4caf50";
                label.textContent = "SYSTEM MONITOR";
            }
        }

        // ======================================================================
        // ðŸ”¢ Global Counters
        // ======================================================================
        myVars.errorCount = 0;
        myVars.securityCount = 0;

        function updateCounterBadge() {
            const err = document.getElementById("errorCountBadge");
            const sec = document.getElementById("securityCountBadge");

            if (err) {
                err.textContent = myVars.errorCount;
                err.style.display = myVars.errorCount > 0 ? "inline-flex" : "none";
            }

            if (sec) {
                sec.textContent = myVars.securityCount;
                sec.style.display = myVars.securityCount > 0 ? "inline-flex" : "none";
            }
        }

        // ======================================================================
        // ðŸŽ¨ Log Styling Helpers
        // ======================================================================
        function getLogColor(type, msg) {
            const lower = String(msg).toLowerCase();
            const dangerWords = [
                "violation","policy","security","detected",
                "illegal","blocked","denied",
                "unsafe-inline","unsafe-eval","csp"
            ];

            if (type === "error" || dangerWords.some(w => lower.includes(w))) return "#fa3232";
            if (lower.includes("fen")) return "#3498db";
            if (type === "warn") return "#f1c40f";
            return "#00eb9b";
        }

        function getConsoleIcon(method) {
            return {
                warn: "âš ï¸ ",
                error: "ðŸš« ",
                info: "â„¹ï¸ ",
                debug: "ðŸž ",
                log: "ðŸ“œ "
            }[method] || "";
        }

        function getTimeStamp() {
            return new Date().toLocaleTimeString("en-GB", { hour12: false });
        }

        function getCleanTime() {
            const n = new Date();
            return [n.getHours(), n.getMinutes(), n.getSeconds()]
                .map(v => String(v).padStart(2, "0"))
                .join(":");
        }

        const isSecurityMsg = txt =>
        /content security policy|csp|violation|blocked|unsafe-inline|unsafe-eval/i
        .test(String(txt).toLowerCase());

        // ======================================================================
        // ðŸ“ Mini Log Console
        // ======================================================================
        myFunctions.addMiniLog = function (msg, type = "info") {
            try {
                const box = document.getElementById("miniLogConsole");
                if (!box) return;

                const color = getLogColor(type, msg);
                const isDanger = color === "#fa3232";

                const div = document.createElement("div");
                div.className = "log-line fade-in";
                div.innerHTML = `
            <span class="log-time">[${getTimeStamp()}]</span>
            <span style="color:${color};font-weight:${isDanger ? 600 : 400}">
                ${msg}
            </span>
        `;

                box.appendChild(div);
                box.scrollTop = box.scrollHeight;

                if (box.childNodes.length > 120) box.removeChild(box.firstChild);
            } catch (_) {}
        };

        // ======================================================================
        // ðŸ“¬ Error Mailbox
        // ======================================================================
        myFunctions.addErrorToMailbox = function (msg) {
            const content = document.getElementById("errorLogContent");
            const container = document.getElementById("errorBoxContainer");
            if (!content) return;

            if (content.innerText.includes("Menunggu pesan error")) {
                content.innerHTML = "";
            }

            const lower = String(msg).toLowerCase();
            let kategori = "System";
            let kelas = "err-general";

            if (isSecurityMsg(lower)) {
                kategori = "Security";
                kelas = "err-violation";
            } else if (lower.includes("runtime")) {
                kategori = "Runtime";
                kelas = "err-runtime";
            } else if (lower.includes("network")) {
                kategori = "Network";
                kelas = "err-network";
            }

            const row = document.createElement("tr");
            row.className = "fade-in";
            row.innerHTML = `
           <td>${getCleanTime()}</td>
            <td class="${kelas}">${kategori}</td>
             <td class="${kelas}">
            <span>${msg}</span>
            <button class="col-copy-btn" type="button">ðŸ“‹</button>
              </td>
             `;

            // Handler Salin
            row.querySelector('.col-copy-btn').onclick = function() {
                navigator.clipboard.writeText(msg);
                const originalText = this.innerText;
                this.innerText = 'âœ…';
                setTimeout(() => { this.innerText = originalText; }, 1000);
            };

            content.appendChild(row);
            if (container) container.scrollTop = container.scrollHeight;
            if (content.childNodes.length > 60) content.removeChild(content.firstChild);

            /* ðŸ”¢ COUNTER */
            myVars.errorCount++;
            updateCounterBadge();
        };

        // ======================================================================
        // ðŸ”’ Security Log
        // ======================================================================
        myFunctions.addSecurityLog = function (msg) {
            const box = document.getElementById("securityLogContainer");
            if (!box) return;

            if (box.innerText.includes("Menunggu pelanggaran")) {
                box.innerHTML = "";
            }

            const row = document.createElement("div");
            row.style.cssText = `
        border-left:4px solid #ff4444;
        padding:6px;
        margin-bottom:6px;
        background:#1a0000;
        color:#ffb3b3;
        word-break:break-word;
        font-family:monospace;
        font-size:12px;
    `;

            row.innerHTML = `
        <div style="color:#ff7777">[${getCleanTime()}] ðŸš¨ SECURITY</div>
        <div>${msg}</div>
    `;

            box.appendChild(row);
            box.scrollTop = box.scrollHeight;
            if (box.childNodes.length > 120) box.removeChild(box.firstChild);

            // ðŸ”¢ Counter
            myVars.securityCount++;
            updateCounterBadge();
        };

        // ======================================================================
        // ðŸž Console Hijack
        // ======================================================================
        (function () {
            const methods = ["log", "warn", "error", "info", "debug"];
            const native = {};

            methods.forEach(method => {
                native[method] = console[method];
                console[method] = function (...args) {
                    native[method].apply(console, args);

                    const msg = getConsoleIcon(method) + args.join(" ");
                    myFunctions.addMiniLog(msg, method);

                    if (method === "error") {
                        setMonitorStatus("error"); // ðŸ”´ aktifkan LED merah
                        myFunctions.addErrorToMailbox(msg);
                    }

                    if (isSecurityMsg(msg)) {
                        myFunctions.addSecurityLog(msg);
                        myFunctions.addErrorToMailbox(msg);
                    }
                };
            });
        })();
        // ======================================================================
        // ðŸŒ Global Error Handlers
        // ======================================================================
        window.addEventListener("error", e => {
            const msg = e.message || "Unknown Error";
            myFunctions.addMiniLog(`ðŸ’¥ ${msg}`, "error");
            myFunctions.addErrorToMailbox(msg);
            setMonitorStatus("error");
            myFunctions.updateAutoRunStatus(ENGINE_STATUS1.ERROR, 'STOP');
        });

        window.addEventListener("unhandledrejection", e => {
            const msg = `âŒ Promise Failed: ${e.reason?.message || e.reason}`;
            myFunctions.addMiniLog(msg, "error");
            myFunctions.addErrorToMailbox(msg);
            setMonitorStatus("error");
            myFunctions.updateAutoRunStatus(ENGINE_STATUS1.ERROR, 'STOP');
        });

        window.addEventListener("securitypolicyviolation", e => {
            const msg = `CSP VIOLATION â†’ ${e.violatedDirective} | ${e.blockedURI || "inline/eval"}`;

            myFunctions.addMiniLog("ðŸ”’ " + msg, "error");
            myFunctions.addErrorToMailbox(msg);
            myFunctions.addSecurityLog(`
        Directive: ${e.violatedDirective}
        Blocked: ${e.blockedURI || "inline/eval"}
        Source: ${e.sourceFile || "unknown"}
    `.trim());
        });

        // ======================================================================
        // ðŸ§¹ Clear Buttons
        // ======================================================================
        document.addEventListener("click", e => {
            if (e.target?.id === "clearErrorBtn") {
                const content = document.getElementById("errorLogContent");
                if (content) {
                    content.innerHTML = `
                <tr>
                    <td colspan="3" style="text-align:center;color:#666;">
                        <em>Menunggu pesan error...</em>
                    </td>
                </tr>
            `;
                }
                myVars.errorCount = 0;
                updateCounterBadge();
            }

            if (e.target?.id === "clearSecurityBtn") {
                const box = document.getElementById("securityLogContainer");
                if (box) {
                    box.innerHTML = `
                <div style="color:#666;text-align:center;padding:10px">
                    Menunggu pelanggaran keamananâ€¦
                </div>
            `;
                }
                myVars.securityCount = 0;
                updateCounterBadge();
                setMonitorStatus("ok");
            }
        });

        // ======================================================================
        // ðŸ”€ Tab Switcher
        // ======================================================================
        function showSecurityTab() {
            const sec = document.getElementById("securityTab");
            const err = document.getElementById("errorTab");
            if (sec) sec.style.display = "flex";
            if (err) err.style.display = "none";
        }

        // ===========================================================================================================================================
        //                                                      âš™ï¸ engine utama âš™ï¸
        // ===========================================================================================================================================

        // ===========================================================================
        // ðŸ”„ Status Engine UI
        // ===========================================================================
        myFunctions.updateEngineUI = function (state) {
            // Kalau AutoRun OFF â†’ jangan pasang observer
            if (!myVars.autoRun) {
                //  console.log("[guard] AutoRun OFF â†’ observer tidak dipasang.");
                return;
            }

            const led = document.getElementById("engine-led");
            const statusEl = document.getElementById("engine-status-text");

            const colors = {
                IDLE: "#555555", // Abu-abu
                READY: "#4caf50", // Hijau
                THINKING: "#ffeb3b", // Kuning
                RELOADING: "#2196f3", // Biru
                ERROR: "#f44336", // Merah
                RUNNING: "#ffeb3b" // Sama dengan Thinking
            };

            const labels = {
                IDLE: "Engine idle",
                READY: "Engine ready",
                THINKING: "Engine thinking...",
                RELOADING: "Reloading engine...",
                ERROR: "Engine error!",
                RUNNING: "Engine running..."
            };

            if (led) {
                const currentColor = colors[state] || colors.IDLE;
                led.style.backgroundColor = currentColor;
                led.style.boxShadow = (state !== "IDLE" && colors[state])
                    ? `0 0 6px ${currentColor}`
            : "none";
                led.classList.remove('active', 'running', 'error', 'ready');
            }

            if (statusEl) {
                statusEl.textContent = labels[state] || "Unknown state";
            }
        };
        // ===============================END====================================

        // ======================================================================
        // ðŸ§¹ Terminate Chess Engine (Safe & Complete)
        // ======================================================================
        myFunctions.terminateChessEngine = function(hard = false) {
            // MODIFICATION: If 'hard' is true (Manual Reset/Emergency), ignore autoRun check.
            // We want to be able to kill the engine even if the bot is paused.
            if (!hard && !myVars.autoRun) return;

            console.log(`[Engine] Initiating Termination... (Hard: ${hard})`);

            // 1. Matikan Controller (Business Logic)
            try {
                if (engine && engine.controller) {
                    if (typeof engine.controller.destroy === 'function') {
                        engine.controller.destroy();
                    } else if (typeof engine.controller.stop === 'function') {
                        engine.controller.stop();
                    }
                }
            } catch (e) {
                console.warn("[Engine] Controller termination warning:", e);
            }

            // 2. Matikan Worker (Raw Thread)
            try {
                if (engine && engine.engine) {
                    engine.engine.terminate(); // Force kill worker
                }
            } catch (e) {
                console.warn("[Engine] Worker termination warning:", e);
            }

            // 3. Bersihkan Memori Blob (Prevent Memory Leak)
            try {
                if (engine && engine._objectURL) {
                    URL.revokeObjectURL(engine._objectURL);
                    engine._objectURL = null;
                }
            } catch (e) {
                console.warn("[Engine] Blob revocation warning:", e);
            }

            // 4. Reset References
            engine.controller = null;
            engine.engine = null;
            myVars.isEngineReady = false;
            myVars.isThinking = false;

            // 5. Hard Reset UI Status
            if (hard) {
                if (typeof myFunctions.setEngineState === 'function') {
                    myFunctions.setEngineState(ENGINE_STATE.IDLE, "HARD_TERMINATE");
                }
                if (typeof myFunctions.updateAutoRunStatus === 'function') {
                    myFunctions.updateAutoRunStatus(ENGINE_STATUS1.IDLE, "TERMINATED");
                }

                // Reset Visual LED if function exists
                if (typeof myFunctions.updateLEDStatus === 'function') {
                    myFunctions.updateLEDStatus("OFF");
                }
            }

            console.log(`[Engine] Terminated ${hard ? 'HARD' : 'SAFELY'}.`);
        };

        // Fallback minimal
        myFunctions._terminateWorkerSafe = function() {
            try { engine?.engine?.terminate?.(); } catch {}
            try { if (engine?._objectURL) URL.revokeObjectURL(engine._objectURL); } catch {}
            engine.engine = null;
            engine.controller = null;
            engine._objectURL = null;
        };

        // ======================================================================
        // ðŸ”„ Reload Chess Engine (WITH LED LOGIC)
        // ======================================================================
        myFunctions.reloadChessEngine = function () {
            // If autoRun is off, we usually don't want to auto-reload,
            // BUT if the user clicked a "Reload" button, we might want to bypass this.
            // Assuming this is automatic recovery:
            if (!myVars.autoRun) return;

            if (myVars.engineStatus === "RELOADING" || myVars.isActuallyLoading) {
                console.log("[Engine] Reload ignored: already reloading");
                return;
            }

            console.log("[Engine] Reload requested");

            // --- TAMBAHAN LED LOADING (VISUAL FEEDBACK) ---
            if (typeof myFunctions.updateLEDStatus === 'function') {
                // Example: Turn all 7 LEDs to Yellow/Orange to indicate restart
                myFunctions.updateLEDStatus("LOADING");
            }
            // ----------------------------------------------

            // Force hard terminate to clear everything
            myFunctions.terminateChessEngine(true);

            // Give a slight buffer for memory cleanup before starting new worker
            setTimeout(() => {
                myFunctions.loadChessEngine();
            }, 200);
        };

        // ======================================================================
        // ðŸ“¥ LOAD ENGINE (ROBUST VERSION)
        // ======================================================================
        myFunctions.loadChessEngine = async function () {
            if (myVars.isActuallyLoading) return false;
            myVars.isActuallyLoading = true;
            myVars.isEngineReady = false;

            try {
                console.log("[Engine] Starting Load Process...");
                myFunctions.setEngineState(ENGINE_STATE.RELOADING, "INIT_LOAD");

                // 1. Dapatkan Source Code Stockfish
                let stockfishText = null;

                // Priority 1: GM_getResourceText (Tampermonkey Sync)
                if (typeof GM_getResourceText !== 'undefined') {
                    stockfishText = GM_getResourceText("stockfish.js");
                }
                // Priority 2: GM.getResourceText (GreaseMonkey 4+ Async)
                else if (typeof GM !== 'undefined' && GM.getResourceText) {
                    stockfishText = await GM.getResourceText("stockfish.js10.0.2");
                }

                // Priority 3: Fetch from CDN (Fallback)
                if (!stockfishText) {
                    console.warn("[Engine] GM Resource failed/empty, fetching from CDN...");
                    const resp = await fetch('https://cdnjs.cloudflare.com/ajax/libs/stockfish.js/9.0.0/stockfish.js');
                    if (!resp.ok) throw new Error(`CDN Error: ${resp.status}`);
                    stockfishText = await resp.text();
                }

                if (!stockfishText || stockfishText.length < 100) {
                    throw new Error("Stockfish source code is empty or invalid");
                }

                // 2. Buat Worker Blob
                const blob = new Blob([stockfishText], { type: "application/javascript" });
                const url = URL.createObjectURL(blob);

                // 3. Init Worker
                engine.engine = new Worker(url);
                engine._objectURL = url; // Save for cleanup

                engine.engine.onerror = err => {
                    console.error("[Engine] Worker Critical Error:", err);
                    // Don't modify state here immediately, let the controller handle logic
                    // or trigger a specific error state.
                };

                // 4. Init Controller (Assuming EngineController class exists)
                if (typeof EngineController === 'undefined') {
                    throw new Error("EngineController class is missing!");
                }

                engine.controller = new EngineController(engine.engine);

                // Bind State Changes
                engine.controller.onStateChange = state => {
                    myFunctions.setEngineState(state, "CONTROLLER");
                };

                // Bind Message Parser (Debug/Analysis)
                engine.engine.addEventListener('message', e => {
                    if (typeof parser === 'function') parser(e);
                });

                // 5. Initialize Engine (UCI Handshake)
                // Ensure this is awaited so we know it's truly ready
                await engine.controller.initialize();

                // 6. Success
                myVars.isEngineReady = true;
                myVars.isActuallyLoading = false;
                myVars.retryCount = 0; // RESET RETRY COUNT ON SUCCESS

                myFunctions.setEngineState(ENGINE_STATE.READY, "ENGINE_DONE");

                // Visual Success Indicator
                if (typeof myFunctions.updateLEDStatus === 'function') {
                    myFunctions.updateLEDStatus("READY");
                }

                console.log("[Engine] Fully Ready & Initialized");
                return true;

            } catch (e) {
                console.error("[Engine] Load Failed:", e);

                myVars.isEngineReady = false;
                myVars.isActuallyLoading = false;

                // Clean up partial load
                myFunctions.terminateChessEngine(true);
                myFunctions.setEngineState(ENGINE_STATE.ERROR, "LOAD_FAIL");

                // Auto-retry logic (Limit to 1 or 2 retries)
                if (!myVars.retryCount) myVars.retryCount = 0;
                if (myVars.retryCount < 2) {
                    console.log(`[Engine] Retrying load in 2s... (Attempt ${myVars.retryCount + 1})`);
                    myVars.retryCount++;
                    setTimeout(myFunctions.loadChessEngine, 2000);
                } else {
                    console.error("[Engine] Max retries reached. Manual refresh required.");
                }

                return false;
            }
        };

        // ======================================================================
        // âœ… ENGINE CONTROLLER (VERSION 2.4 - FIXED)
        // ======================================================================
        class EngineController {
            constructor(worker) {
                this.worker = worker;
                this.queue = [];
                this.isBusy = false;
                this.state = ENGINE_STATE.INIT;
                this.watchdog = null;
                this._readyPromise = null;
                this._readyResolver = null;

                // Callbacks
                this.onReady = null;
                this.onThinking = null;
                this.onStateChange = null;

                worker.addEventListener("message", e => {
                    this._onMessage(String(e.data || ""));
                });
            }

            // âœ… NEW: Promise-based initialization
            async initialize() {
                return new Promise((resolve, reject) => {
                    const timeout = setTimeout(() => {
                        reject(new Error("Engine initialization timeout"));
                    }, 50000);

                    const originalOnReady = this.onReady;
                    this.onReady = () => {
                        clearTimeout(timeout);
                        this.onReady = originalOnReady;
                        originalOnReady?.();
                        resolve();
                    };

                    this.send("uci");
                });
            }

            _setState(newState) {
                if (this.state !== newState) {
                    this.state = newState;
                    console.log(`[EngineController] âš¡ State â†’ ${newState}`);
                    this.onStateChange?.(newState);
                }
            }

            _clearWatchdog() {
                if (this.watchdog) {
                    clearTimeout(this.watchdog);
                    this.watchdog = null;
                }
            }

            _onMessage(msg) {
                if (!msg.startsWith("info depth")) {
                    console.log("[EngineController] â†", msg.substring(0, 120));
                }

                if (msg === "uciok") {
                    console.log("[EngineController] âœ“ UCI Handshake Complete");
                    this._configureOptions();
                    this.send("ucinewgame");
                    this.send("isready");
                    return;
                }

                if (msg === "readyok") {
                    console.log("[EngineController] âœ“ Engine Ready");
                    this._clearWatchdog(); // âœ… Clear watchdog
                    this.isBusy = false;
                    this._setState(ENGINE_STATE.READY);
                    this.onReady?.();
                    this._flush();
                    return;
                }

                if (msg.startsWith("bestmove")) {
                    console.log("[EngineController] âœ“ Calculation Finished");
                    this._clearWatchdog(); // âœ… Clear watchdog
                    this.isBusy = false;
                    this._setState(ENGINE_STATE.READY);
                    this.onReady?.();
                    this._flush();
                    return;
                }

                if (msg.startsWith("info")) {
                    if (this.state !== ENGINE_STATE.THINKING) {
                        this._setState(ENGINE_STATE.THINKING);
                        this.onThinking?.();
                    }
                    return;
                }

                if (msg.toLowerCase().includes("error") ||
                    msg.toLowerCase().includes("unknown command")) {
                    console.error("[EngineController] âš ï¸ Engine Error:", msg);
                    this._clearWatchdog();
                    this.isBusy = false;
                    this.queue = [];
                    this._setState(ENGINE_STATE.ERROR);
                    this.send("isready"); // Auto-recover
                }
            }

            // âœ… Extracted option configuration
            _configureOptions() {
                this.setOption("Hash", 256);
                this.setOption("UCI_LimitStrength", "true");

                if (myVars.showMultipleMoves) {
                    this.setOption("MultiPV", Math.max(1, myVars.numberOfMovesToShow || 3));
                }
                if (myVars.eloRating) {
                    this.setOption("UCI_Elo", myVars.eloRating);
                }
                if (myVars.skillLevel !== undefined) {
                    this.setOption("Skill Level", myVars.skillLevel);
                }
            }

            send(cmd) {
                console.debug("[EngineController] â†’ Queue:", cmd);
                this.queue.push(cmd);
                this._flush();
            }

            _flush() {
                if (this.isBusy || this.queue.length === 0) return;

                const cmd = this.queue.shift();
                console.log("[EngineController] â†’", cmd);
                this.isBusy = true;

                if (cmd.startsWith("go ")) {
                    this._setState(ENGINE_STATE.THINKING);
                    this._startWatchdog();
                }

                this.worker.postMessage(cmd);
            }

            // Shortcut methods
            uci() { this.send("uci"); }
            isready() { this.send("isready"); }
            setOption(name, value) {
                this.send(`setoption name ${name} value ${value}`);
            }
            positionFen(fen) {
                this.send(`position fen ${fen}`);
            }

            newGame() {
                this._clearWatchdog();
                this.send("ucinewgame");
                this.send("isready");
            }

            go(depth) {
                const maxDepth = myVars.maxDepthForElo || depth;
                const finalDepth = Math.min(depth, maxDepth);

                console.log("[EngineController] â–¶ Analysis depth:", finalDepth);

                if (this.isBusy) {
                    this.worker.postMessage("stop");
                    this._clearWatchdog();
                    this.queue = [];
                    this.isBusy = false;
                }

                this.send(`go depth ${finalDepth}`);
            }

            stop() {
                console.warn("[EngineController] â›” Stop Requested");
                this._clearWatchdog();
                this.worker.postMessage("stop");
                this.queue = [];
                this.isBusy = false;
                this._setState(ENGINE_STATE.READY);
                this.send("isready");
            }

            forceReset() {
                console.error("[EngineController] ðŸ”§ Emergency Reset");
                this._clearWatchdog();
                this.queue = [];
                this.isBusy = false;
                this.worker.postMessage("stop");
                this.newGame();
            }

            _startWatchdog() {
                this._clearWatchdog();
                const timeout = myVars.engineTimeoutMs || 15000;
                this.watchdog = setTimeout(() => {
                    if (this.isBusy && this.state === ENGINE_STATE.THINKING) {
                        console.warn("[EngineController] â° Watchdog triggered");
                        this.forceReset();
                    }
                }, timeout);
            }

            // âœ… NEW: Cleanup method
            destroy() {
                this._clearWatchdog();
                this.queue = [];
                this.worker.postMessage("quit");
            }
        }

        // ===========================================================================
        // â–¶ RUN CHESS ENGINE (Optimized - Anti Loop & Anti Stuck & Normalization)
        // ===========================================================================

        // Helper: Get FEN without move clocks (first 4 fields) to detect identical positions
        myFunctions.getSimpleFen = function(fen) {
            if (!fen) return '';
            return fen.split(' ').slice(0, 4).join(' ');
        };

        myFunctions.runChessEngine = async function (depth) {
            // 1. Basic Checks
            if (!myVars.autoRun) return;

            // Get current FEN
            const rawFen = board?.game?.getFEN?.() || myFunctions.getAccurateFen?.();

            // Check Game Over
            if (myVars.isGameOver || detectGameOver(rawFen)) {
                if (!myVars.isGameOver) {
                    console.log("[Engine] Stop: Game Over detected.");
                    myVars.isGameOver = true; // Prevent loop
                }
                return;
            }

            if (!rawFen) return;

            // 2. Anti-Loop & Anti-Stuck Guard
            // We normalize the FEN to ensure we don't re-analyze based on move clocks alone
            const currentSimpleFen = myFunctions.getSimpleFen(rawFen);
            const lastSimpleFen = myFunctions.getSimpleFen(myVars.lastAnalyzedFen);

            if (currentSimpleFen === lastSimpleFen && myVars.isThinking) {
                // If it's the same position and we are already thinking, do nothing.
                // But if we are stuck (isThinking=true but engine silent), we might need a timeout reset mechanism externally.
                console.log("[Engine] Position already being analyzed. Skipping.");
                return;
            }

            // Update the last analyzed FEN immediately to block duplicate calls
            myVars.lastAnalyzedFen = rawFen;

            try {
                // 3. Stop Previous Search (Crucial for Anti-Stuck)
                // Always tell stockfish to stop before sending a new position
                if (engine && engine.engine) {
                    engine.engine.postMessage("stop");
                }

                // 4. Opening Book Logic
                if (myVars.useOpeningBook) {
                    if (!myVars.openingBook) await myFunctions.fetchOpeningBook?.();

                    // Re-check FEN after await (Async Race Condition Protection)
                    // The board might have changed while we were fetching the book
                    const currentFenCheck = board?.game?.getFEN?.() || myFunctions.getAccurateFen?.();
                    if (myFunctions.getSimpleFen(currentFenCheck) !== currentSimpleFen) {
                        console.log("[Engine] Board changed during book fetch. Aborting.");
                        return;
                    }

                    const openingMove = myFunctions.getOpeningMove?.(rawFen);

                    if (openingMove) {
                        console.log("[Engine] Book Move Found:", openingMove);

                        // Reset Engine State immediately
                        myVars.isThinking = false;
                        myFunctions.setEngineState(ENGINE_STATE.READY);

                        // Apply logic
                        myVars.bestMove = openingMove;
                        myFunctions.color?.(openingMove);

                        // Update Server if needed
                        if (myVars.useExternalWindow && myVars.serverConnected) {
                            myVars.chessFen = rawFen; // Send the current FEN
                            myFunctions.sendServerUpdate();
                        }

                        return; // Exit successfully
                    }
                }

                // 5. Run Stockfish
                myVars.topMoves = [];
                myVars.isThinking = true;
                myFunctions.setEngineState(ENGINE_STATE.THINKING);

                // Send commands
                engine.engine.postMessage(`position fen ${rawFen}`);
                engine.controller.go(depth);
                lastValue = depth;

                // UI Updates
                const depthTextEl = $('#depthText')[0];
                if (depthTextEl) {
                    depthTextEl.innerHTML = `Calculating Depth: <strong>${depth}</strong>`;
                }

                if (myVars.useExternalWindow && myVars.serverConnected) {
                    myVars.chessFen = rawFen;
                    myVars.bestMove = ''; // Reset best move while thinking
                    myFunctions.sendServerUpdate();
                }

            } catch (err) {
                console.error("[Engine] Critical Error:", err);
                // Reset state so the engine doesn't stay "Thinking" forever
                myVars.isThinking = false;
                myFunctions.safeStateReset?.('ENGINE_CRASH');
            }
        };


        myFunctions.autoRun = function (requestedDepth) {
            // ==========================================================
            // HEALTH CHECK
            // ==========================================================
            if (!board || !board.game) {
                console.log("[AUTO RUN] Board/Game not ready, skip.");
                return;
            }

            let currentTurn, playingAs, currentFen;
            try {
                currentTurn = board.game.getTurn?.();
                playingAs = board.game.getPlayingAs?.();
                currentFen = board.game.getFEN?.() || myFunctions.getAccurateFen?.();
            } catch (err) {
                console.error("[AUTO RUN] Failed reading game state:", err);
                return;
            }

            const isPlayerTurn = currentTurn === playingAs;

            console.log(`[AUTO RUN] depth=${requestedDepth}`);
            console.log(`[AUTO RUN] turn=${currentTurn}, playingAs=${playingAs}`);
            console.log(`[AUTO RUN] isPlayerTurn=${isPlayerTurn}, isThinking=${myVars.isThinking}`);

            // ==========================================================
            // GLOBAL GUARDS
            // ==========================================================
            if (!myVars.autoRun) {
                console.log("[AUTO RUN] Disabled by user.");
                return;
            }

            if (myVars.isThinking) {
                console.log("[AUTO RUN] Engine still thinking.");
                return;
            }

            if (!isPlayerTurn) {
                console.log("[AUTO RUN] Not player turn.");
                return;
            }

            // ==========================================================
            // COOLDOWN GUARD
            // ==========================================================
            if (myVars.autoRunCooldown) {
                console.log("[AUTO RUN] Cooldown active.");
                return;
            }

            // ==========================================================
            // FEN DUPLICATION GUARD
            // ==========================================================
            if (currentFen && currentFen === myVars.lastAnalyzedFen) {
                console.log("[AUTO RUN] Same FEN as last analysis, skipped.");
                return;
            }

            // ==========================================================
            // LOCK GUARD (NEW)
            // ==========================================================
            if (!myFunctions.acquireAutoRunLock()) {
                console.log("[AUTO RUN] Lock not acquired, skip.");
                return;
            }

            // ==========================================================
            // EXECUTION
            // ==========================================================
            console.log(`[AUTO RUN] Running engine @ depth ${requestedDepth}`);

            myVars.lastAnalyzedFen = currentFen;

            // Cooldown flag
            myVars.autoRunCooldown = true;
            setTimeout(() => {
                myVars.autoRunCooldown = false;
            }, myVars.autoRunCooldownDelay || 300);

            // Trigger engine
            myFunctions.runChessEngine(requestedDepth);
        };

        // Helper sederhana untuk cek giliran (Private)
        function isMyTurn() {
            try {
                const boardEl = document.querySelector('chess-board, wc-chess-board');
                if (!boardEl || !boardEl.game) return false;

                const turn = boardEl.game.getTurn(); // 'w' or 'b'
                const playingAs = boardEl.game.getPlayingAs(); // 1 (w) or 2 (b)

                // Konversi playingAs number ke char jika perlu
                const myColor = (playingAs === 1) ? 'w' : (playingAs === 2) ? 'b' : null;

                return turn === myColor;
            } catch (e) {
                return false;
            }
        }

        // Fungsi scheduler otomatis tiap interval (misalnya tiap 1 detik)
        function autoRunScheduler() {
            // Update giliran setiap loop
            isMyTurn();

            // Jika kondisi memenuhi, jalankan autoRun
            if (myVars.autoRun && myTurn && !myVars.isThinking) {
                // Ubah status engine ke READY dan panggil autoRun
                myFunctions.autoRun(myVars.customDepth);
            } else {
                // Kalau tidak memenuhi, jadwalkan delay berikutnya
                scheduleAutoRun(1000); // 1 detik delay, bisa diubah sesuai kebutuhan
            }

            // Loop terus
            setTimeout(autoRunScheduler, 1000);
        }

        // Fungsi penjadwalan delay otomatis
        // ======================================================================
        // â³ AUTO RUN SCHEDULER (ANTI-LOOP VERSION â€“ FIXED)
        // ======================================================================
        // 2. Fungsi Utama Scheduler (Pengatur Jeda Eksekusi)
        function scheduleAutoRun(delay) {
            const boardElement = document.querySelector('chess-board') || document.querySelector('wc-chess-board');
            if (!boardElement || !boardElement.game) return;

            // --- LOGIKA AUTO-WAKEUP (Bangun Otomatis) ---
            const currentFen = boardElement.game.getFEN?.() || "";

            // Jika FEN adalah posisi awal, otomatis panggil reset agar isGameOver jadi false
            const isStartingPos = currentFen.startsWith("rnbqkbnr/pppppppp");
            if (isStartingPos && myVars.isGameOver) {
                myFunctions.resetForNewGame();
                myFunctions.clearMoveHistory();
            }

            // 1. HARD GUARD: Jangan jalan jika benar-benar Game Over
            // (Jika sudah direset di atas, guard ini akan lolos)
            if (myVars.isGameOver) {
                console.log("[SCHEDULER] Game Over aktif, menunggu game baru...");
                myFunctions.updateAutoRunStatus(ENGINE_STATUS1.IDLE, 'GAME_OVER_STOP');
                onGameEnd("Skor: 100 - Menang!");
                return;
            }

            // 2. Pembersihan Timer untuk mencegah tumpang tindih (Race Condition)
            if (myVars.autoRunTimeoutId) {
                clearTimeout(myVars.autoRunTimeoutId);
                myVars.autoRunTimeoutId = null;
            }

            // Update status ke DELAY (LED Kuning)
            myFunctions.updateAutoRunStatus(ENGINE_STATUS1.DELAY, "WAITING_MOVE");
            console.log(`[SCHEDULER] Direncanakan dalam ${delay}ms`);

            myVars.autoRunTimeoutId = setTimeout(() => {
                myVars.autoRunTimeoutId = null;

                // 3. RE-VALIDATION: Ambil data terbaru sebelum eksekusi
                const freshFen = boardElement.game.getFEN?.() || "";
                const currentTurn = boardElement.game.getTurn?.();
                const playingAs = boardElement.game.getPlayingAs?.();

                // Cek apakah game berakhir tepat sebelum eksekusi
                if (typeof detectGameOver === 'function' && detectGameOver(freshFen)) {
                    console.log("[SCHEDULER] Eksekusi dibatalkan: Game Selesai.");
                    onGameEnd("Skor: 100 - Menang!");
                    myVars.isGameOver = true;
                    myFunctions.updateAutoRunStatus(ENGINE_STATUS1.IDLE, "GAME_OVER");
                    return;
                }

                // Jalankan AutoRun jika giliran kita dan mesin tidak sedang berpikir
                if (myVars.autoRun && currentTurn === playingAs && !myVars.isThinking) {

                    // Jangan analisa FEN yang sama dua kali (Hemat Resource)
                    if (freshFen === myVars.lastAnalyzedFen) {
                        console.log("[SCHEDULER] Batal: FEN belum berubah.");
                        return;
                    }

                    console.log("[SCHEDULER] Kondisi terpenuhi, memicu AutoRun.");
                    myFunctions.updateAutoRunStatus(ENGINE_STATUS1.READY, "AUTO_RUN_EXEC");

                    // Panggil fungsi utama AutoRun Anda
                    if (typeof myFunctions.autoRun === 'function') {
                        myFunctions.autoRun(myVars.customDepth);
                    }

                } else {
                    console.log("[SCHEDULER] Kondisi batal: Bukan giliran atau mesin sibuk.");
                    myFunctions.updateAutoRunStatus(ENGINE_STATUS1.IDLE, 'WAITING_NEXT');
                }

                // Flow guard reset
                setTimeout(() => {
                    if (typeof canGo !== 'undefined') canGo = true;
                }, 100);

            }, delay);
        }
        // Mulai otomatisasi saat halaman terload
        window.addEventListener("load", () => {
            isMyTurn();
            autoRunScheduler();
        });
        // =============================== END ==================================
        // ======================================================================
        // â±ï¸ ENGINE THINKING TIMEOUT (SAFE)
        // ======================================================================
        myFunctions.installEngineTimeout = function () {
            if (!engine?.controller) return;

            let timer = null;

            engine.controller.onThinking = () => {
                clearTimeout(timer);
                timer = setTimeout(() => {
                    if (engine.controller.state === ENGINE_STATE.THINKING) {
                        console.warn("[ENGINE] Thinking timeout â†’ stop()");
                        engine.controller.stop();
                    }
                }, myVars.engineTimeoutMs || 30000);
            };

            engine.controller.onReady = () => {
                clearTimeout(timer);
            };
        };
        // ===============================END====================================
        // ======================================================================
        //
        // ======================================================================
        function safeParseInfoLine(message) {
            // ðŸ’¡ Saran: Penanganan parsing ini sudah memadai, menggunakan RegEx lebih handal daripada string split.
            const result = { multipv: 1, depth: null, scoreType: null, scoreValue: null, pv: '' };
            try {
                const mp = /multipv\s+(\d+)/.exec(message);
                if (mp) result.multipv = parseInt(mp[1], 10);

                const depthM = /depth\s+(\d+)/.exec(message);
                if (depthM) result.depth = parseInt(depthM[1], 10);

                const scoreM = /score\s+(cp|mate)\s+(-?\d+)/.exec(message);
                if (scoreM) {
                    result.scoreType = scoreM[1];
                    result.scoreValue = parseInt(scoreM[2], 10);
                }

                const pvM = /\s+pv\s+(.+)$/.exec(message);
                if (pvM) result.pv = pvM[1].trim();

            } catch (e) {
                myFunctions.log?.('PARSER', `safeParse failed: ${e}`, 'warn');
            }
            return result;
        }
        // ===============================END====================================
        // ======================================================================
        // ðŸ”Ž Parser (Fixed: Stats Active & Optimized)
        // ======================================================================

        // Variabel Cache (disimpan null dulu, diisi nanti)
        let uiCache = {
            nodes: null,
            nps: null,
            time: null,
            depth: null,
            pv: null,
            wdl: null
        };

        // Variabel Throttling (agar UI tidak kedip-kedip terlalu cepat)
        let lastUiUpdate = 0;
        const UI_UPDATE_INTERVAL = 100; // Update setiap 100ms (10 FPS)

        async function parser(e) {
            if (!myVars.autoRun) return;

            try {
                const msgString = e?.data;
                const message = typeof msgString === 'string' ? msgString.trim() : '';
                if (!message) return;

                // 0. SAFETY: GAME OVER
                if (myVars.isGameOver || myVars.gameEnded) {
                    myFunctions.setEngineState(ENGINE_STATE.READY);
                    return;
                }

                // 1. READYOK
                if (message === 'readyok') {
                    if (myVars.engineStatus !== ENGINE_STATE.READY) {
                        myFunctions.updateAutoRunStatus(ENGINE_STATUS1.READY, 'ENGINE_DONE');
                    }
                    return;
                }

                const safeParseInt = (v) => {
                    const n = parseInt(v, 10);
                    return Number.isFinite(n) ? n : null;
                };

                // 2. INFO PARSING (Nodes, NPS, Time, PV)
                if (message.startsWith('info')) {
                    // Pastikan status engine THINKING
                    if (myVars.engineStatus !== ENGINE_STATE.THINKING) {
                        myFunctions.updateAutoRunStatus(ENGINE_STATUS1.THINKING);
                    }

                    // --- Throttling UI ---
                    const now = Date.now();
                    const shouldUpdateUI = (now - lastUiUpdate > UI_UPDATE_INTERVAL);

                    if (shouldUpdateUI) {
                        lastUiUpdate = now;
                        const parts = message.split(/\s+/);

                        // A. UPDATE STATISTIK (Nodes, NPS, Time)
                        // Kita panggil ini SETIAP kali ada info, asalkan lolos throttling
                        myFunctions.updatePVPanel(message, parts);

                        // B. UPDATE PV & EVALUASI (Hanya jika ada 'pv' dan 'score')
                        if (message.includes('pv') && message.includes('score')) {
                            const multipvIndex = parts.indexOf('multipv');
                            const pvIndex = parts.indexOf('pv');
                            const scoreIndex = parts.indexOf('score');
                            const depthIndex = parts.indexOf('depth');

                            // Validasi minimal
                            if (pvIndex !== -1 && scoreIndex !== -1) {
                                const moveNumber = multipvIndex !== -1 ? (safeParseInt(parts[multipvIndex + 1]) || 1) : 1;
                                const bestMove = parts[pvIndex + 1] || '';
                                const depthValue = safeParseInt(parts[depthIndex + 1]) || 0;
                                const scoreType = parts[scoreIndex + 1] || 'cp';
                                const scoreValue = safeParseInt(parts[scoreIndex + 2]) || 0;
                                const pvLine = parts.slice(pvIndex + 1).join(" ");
                                const pvMovesArray = parts.slice(pvIndex + 1);

                                // Evaluasi
                                let evaluationText = '';
                                let evalClass = 'eval-equal';
                                let scoreForBar = scoreValue;
                                if (scoreType === 'cp') {
                                    const scorePawn = scoreValue / 100;
                                    evaluationText = (scorePawn > 0 ? '+' : '') + scorePawn.toFixed(2);
                                    evalClass = scorePawn > 0.3 ? 'eval-positive' :
                                    scorePawn < -0.3 ? 'eval-negative' : 'eval-equal';
                                } else {
                                    evaluationText = (scoreValue > 0 ? 'M+' : 'M-') + Math.abs(scoreValue);
                                    evalClass = scoreValue > 0 ? 'eval-positive' : 'eval-negative';
                                    scoreForBar = scoreValue > 0 ? 10000 : -10000;
                                }

                                const cpForWdl = scoreType === 'mate' ? (scoreValue > 0 ? 100000 : -100000) : scoreValue;
                                const wdlText = myFunctions.calculateWDL(cpForWdl, depthValue);

                                // Update Data Internal
                                if (!Array.isArray(myVars.topMoves)) myVars.topMoves = [];

                                const moveInfo = {
                                    move: bestMove,
                                    evaluationCp: cpForWdl,
                                    evaluationText,
                                    evalClass,
                                    depth: depthValue,
                                    multipv: moveNumber,
                                    pvLine,
                                    wdl: wdlText
                                };

                                const idx = myVars.topMoves.findIndex(m => m.multipv === moveNumber);
                                if (idx !== -1) myVars.topMoves[idx] = moveInfo;
                                else myVars.topMoves.push(moveInfo);
                                myVars.topMoves.sort((a, b) => b.evaluationCp - a.evaluationCp);

                                // Update Visual Utama (hanya untuk multipv 1)
                                if (moveNumber === 1) {
                                    myVars.lastPV = pvLine;
                                    myVars.currentEvaluationText = evaluationText;
                                    myVars.currentWDL = wdlText;

                                    // Update WDL UI
                                    if (!uiCache.wdl) uiCache.wdl = document.getElementById('wdl-output');
                                    if (uiCache.wdl) uiCache.wdl.innerText = wdlText;

                                    myFunctions.updateEvalBar?.(scoreForBar, null, depthValue);
                                    myFunctions.checkAutoResign?.({ type: scoreType, value: scoreValue });

                                    // Gambar Panah
                                    if (typeof myFunctions.onEnginePV === 'function') {
                                        myFunctions.onEnginePV(pvMovesArray);
                                    }
                                }

                                // Update Tabel Langkah
                                const moveEl = document.getElementById('topMove' + moveNumber);
                                const evalEl = document.getElementById('topMoveEval' + moveNumber);
                                if (moveEl) moveEl.textContent = bestMove;
                                if (evalEl) {
                                    evalEl.textContent = evaluationText;
                                    evalEl.className = `eval-badge ${evalClass}`;
                                }
                            }
                        }
                    }
                }

                // 3. BESTMOVE
                if (message.startsWith('bestmove')) {
                    if (myVars.engineStatus !== ENGINE_STATE.READY) {
                        myFunctions.setEngineState(ENGINE_STATE.READY);
                        myFunctions.updateAutoRunStatus(ENGINE_STATUS1.RUNNING, 'BESTMOVE');
                    }

                    const parts = message.split(/\s+/);
                    const finalMove = parts[1] || '';
                    if (!finalMove || finalMove === '(none)') return;

                    // Proses history langkah
                    const currentTopMoves = [...(myVars.topMoves || [])];
                    myVars.topMoves = [];

                    if (currentTopMoves.length > 0) {
                        const currentFEN = board?.game?.getFEN?.();
                        if (currentFEN) {
                            const turn = currentFEN.split(' ')[1];
                            const chosenData = currentTopMoves.find(m => m.move === finalMove) || currentTopMoves[0];
                            myVars.lastPV = chosenData.pvLine;

                            const newEval = chosenData.evaluationCp;
                            const prevEval = myVars.previousEvaluation || 0;
                            const cpl = turn === 'w' ? Math.max(0, prevEval - newEval) : Math.max(0, newEval - prevEval);

                            myVars.lastMoveGrade = myFunctions.getMoveGrade?.(cpl) || 'unknown';

                            // Update History Arrays
                            if (!myVars.acplHistory) myVars.acplHistory = [];
                            myVars.acplHistory.push(cpl);

                            if (turn === 'w') {
                                myVars.totalCplWhite = (myVars.totalCplWhite || 0) + cpl;
                                myVars.cplMoveCountWhite = (myVars.cplMoveCountWhite || 0) + 1;
                                myVars.acplWhite = (myVars.totalCplWhite / myVars.cplMoveCountWhite / 100).toFixed(2);
                            } else {
                                myVars.totalCplBlack = (myVars.totalCplBlack || 0) + cpl;
                                myVars.cplMoveCountBlack = (myVars.cplMoveCountBlack || 0) + 1;
                                myVars.acplBlack = (myVars.totalCplBlack / myVars.cplMoveCountBlack / 100).toFixed(2);
                            }

                            myFunctions.addMoveToHistory?.(
                                finalMove, chosenData.evaluationText, chosenData.depth,
                                myVars.lastMoveGrade, prevEval, chosenData.wdl
                            );

                            myVars.previousEvaluation = newEval;
                            myFunctions.updateAcplDisplay?.();
                        }
                    }

                    myFunctions.synchronizePV?.(finalMove);

                    // Delay & Move
                    let delay = 0;
                    if (myVars.evaluationMode === 'human') {
                        const { min, max } = myVars.humanMode?.moveTime || { min: 1, max: 3 };
                        delay = (Math.random() * (max - min) + min) * 1000;
                    }

                    if (myVars.moveTimer) clearTimeout(myVars.moveTimer);
                    myVars.moveTimer = setTimeout(() => {
                        if (myVars.isGameOver || myVars.gameEnded) return;
                        myFunctions.handleBestMove?.(finalMove);
                        myFunctions.updateTurnStatus?.();
                        myFunctions.checkAndRunAnalysisAutoMove?.();
                    }, delay);
                }

            } catch (err) {
                console.error("Parser Error:", err);
                myFunctions.setEngineState(ENGINE_STATE.ERROR);
            }
        }

        // ===========================================================================
        // UPDATE PANEL STATISTIK (Fixed: Safe DOM Lookup)
        // ===========================================================================
        myFunctions.updatePVPanel = function(message, preSplitParts) {
            const parts = preSplitParts || message.trim().split(/\s+/);

            const nodesIndex = parts.indexOf('nodes');
            const npsIndex = parts.indexOf('nps');
            const timeIndex = parts.indexOf('time');
            const depthIndex = parts.indexOf('depth');
            const pvIndex = parts.indexOf('pv');

            // Pastikan cache object ada
            if (!window.uiCache) window.uiCache = {};

            // 1. Cek dan Cache Element
            if (!window.uiCache.nodes) window.uiCache.nodes = document.getElementById('nodesDisplay');
            if (!window.uiCache.nps) window.uiCache.nps = document.getElementById('npsDisplay');
            if (!window.uiCache.time) window.uiCache.time = document.getElementById('timeDisplay');
            if (!window.uiCache.depth) window.uiCache.depth = document.getElementById('depthDisplay');
            if (!window.uiCache.pv) window.uiCache.pv = document.getElementById('pvDisplay');

            // 2. Update Nilai
            if (nodesIndex !== -1 && window.uiCache.nodes) {
                window.uiCache.nodes.textContent = parseInt(parts[nodesIndex + 1]).toLocaleString();
            }
            if (npsIndex !== -1 && window.uiCache.nps) {
                window.uiCache.nps.textContent = Math.round(parseInt(parts[npsIndex + 1]) / 1000) + 'k';
            }
            if (timeIndex !== -1 && window.uiCache.time) {
                window.uiCache.time.textContent = (parseInt(parts[timeIndex + 1]) / 1000).toFixed(1) + 's';
            }
            if (depthIndex !== -1 && window.uiCache.depth) {
                window.uiCache.depth.textContent = parts[depthIndex + 1];
            }
            if (pvIndex !== -1 && window.uiCache.pv && !message.startsWith('bestmove')) {
                const livePV = parts.slice(pvIndex + 1).join(' ');
                window.uiCache.pv.textContent = livePV;
            }
        };

        // ===========================================================================
        // SINKRONISASI PV DENGAN ANOTASI (Fixed ReferenceError)
        // ===========================================================================
        myFunctions.synchronizePV = function (finalMove) {
            try {
                const fen = board?.game?.getFEN?.();
                if (!fen || !finalMove) return;

                // Pastikan Chess library tersedia
                if (typeof Chess === 'undefined') return;

                const tempGame = new Chess(fen);

                const pvMoves = (myVars.lastPV || "")
                .split(/\s+/)
                .filter(m => /^[a-h][1-8][a-h][1-8][qrbn]?$/.test(m));

                const grade = myVars.lastMoveGrade || "Best";

                // Config Object
                const gradeConfig = {
                    "Terbaik": { sym: "!!", cls: "anno-brilliant" },
                    "Bagus": { sym: "!", cls: "anno-great" },
                    "Cukup Baik": { sym: "+=", cls: "anno-good" },
                    "Tidak Akurat": { sym: "?!", cls: "anno-inaccuracy" },
                    "Kesalahan": { sym: "?", cls: "anno-mistake" },
                    "Blunder": { sym: "??", cls: "anno-blunder" },
                    "Best": { sym: "*", cls: "" }
                };

                const currentGrade = gradeConfig[grade] || gradeConfig.Best;
                const annotatedMoves = [];

                // 1. Validasi Langkah Utama (Best Move)
                const played = tempGame.move(finalMove, { sloppy: true });
                if (!played) return;

                annotatedMoves.push(
                    `<strong>${finalMove}</strong><sup class="${currentGrade.cls}">${currentGrade.sym}</sup>`
                );

                // 2. Validasi PV Lanjutan (Sisa langkah)
                const idx = pvMoves.indexOf(finalMove);
                const startIdx = idx !== -1 ? idx + 1 : 0;

                for (let i = startIdx; i < pvMoves.length; i++) {
                    const m = pvMoves[i];
                    if (tempGame.move(m, { sloppy: true })) {
                        annotatedMoves.push(m);
                    } else {
                        break;
                    }
                }

                // 3. Render ke UI (Gunakan window.uiCache)
                // Jika cache belum ada isinya, cari manual dengan getElementById
                let pvDisplay = (window.uiCache && window.uiCache.pv)
                ? window.uiCache.pv
                : document.getElementById('pvDisplay');

                // Jika ketemu, update isinya
                if (pvDisplay) {
                    // Update cache jika tadi belum ada
                    if (window.uiCache && !window.uiCache.pv) window.uiCache.pv = pvDisplay;

                    pvDisplay.innerHTML = annotatedMoves.join(' ');

                    // Animasi Refresh (Reflow Hack)
                    pvDisplay.classList.remove('pv-update-anim');
                    void pvDisplay.offsetWidth; // Trigger Reflow
                    pvDisplay.classList.add('pv-update-anim');
                }

            } catch (err) {
                console.error("Error SynchronizePV:", err);
            }
        };

        // ======================================================================
        // PARSE STOCKFISH OUTPUT (Lampu THINKING & READY)
        // ======================================================================
        myFunctions.parseStockfishOutput = function(line, currentFen) {
            // Kalau AutoRun OFF â†’ jangan pasang observer
            if (!myVars.autoRun) {
                //  console.log("[guard] AutoRun OFF â†’ observer tidak dipasang.");
                return;
            }

            if (!line) return;
            const message = line.trim();

            // Bestmove
            if (message.startsWith('bestmove')) {
                const parts = message.split(/\s+/);
                const uciMove = parts[1];
                if (uciMove && /^[a-h][1-8][a-h][1-8][qrbn]?$/.test(uciMove)) {
                    myVars.bestMove = { uci: uciMove, from: uciMove.substring(0,2), to: uciMove.substring(2,4),
                                       promotion: uciMove.length > 4 ? uciMove.substring(4) : undefined, fen: currentFen };
                    console.log(`[Engine] Best move: ${uciMove}`);
                } else {
                    myVars.bestMove = null;
                }

                myVars.isThinking = false; // reset flag
                myFunctions.setEngineState(ENGINE_STATE.READY);
                myFunctions.updateTurnStatus();
                return;
            }

            // Info score
            if (message.startsWith('info') && message.includes('score')) {
                if (myVars.engineStatus !== ENGINE_STATE.THINKING) {
                }

                const match = message.match(/score (cp|mate) (-?\d+)/);
                if (match) {
                    const type = match[1];
                    const value = parseInt(match[2], 10);
                    myVars.lastEvalType = type;
                    myVars.lastEvalValue = value;
                    myVars.lastEvalText1 = type === 'cp'
                        ? ((value > 0 ? '+' : '') + (value / 100).toFixed(2))
                    : `#${value}`;
                    myFunctions.checkAutoResign?.({ type, value });
                }
            }

            // Info PV
            if (message.startsWith('info') && message.includes(' pv ')) {
                const pvMatch = message.match(/ pv (.+)/);
                if (pvMatch) {
                    myVars.principalVariation = pvMatch[1].trim().split(/\s+/);
                }
            }
        };

        // Pastikan ada default di myVars
        myVars.lastBarPercentage = typeof myVars.lastBarPercentage === 'number' ? myVars.lastBarPercentage : 50;

        // ===========================================================================
        // UPDATE EVAL BAR & UI STATUS (Sinkronisasi Visual LED ke Teks)
        // ===========================================================================
        myFunctions.updateEvalBar = function (rawScore, mateValue = null, depth = '') {
            // Kalau AutoRun OFF â†’ jangan update apa pun
            if (!myVars.autoRun) return;

            // =======================================================================
            // 1. HITUNG PERSENTASE BAR
            // =======================================================================
            const maxBarCap = 2000;
            let targetPercentage;

            // Prioritaskan mateValue kalau ada
            const mateProxyValue =
                  mateValue !== null
            ? mateValue
            : (Math.abs(rawScore) === 5000 ? rawScore : null);

            if (mateProxyValue !== null) {
                // Mate â†’ langsung penuh ke satu sisi
                targetPercentage = mateProxyValue > 0 ? 100 : 0;
            } else {
                const cappedScore = Math.max(-maxBarCap, Math.min(maxBarCap, rawScore));
                targetPercentage = 50 + (cappedScore / (maxBarCap * 2)) * 100;
                targetPercentage = Math.max(0, Math.min(100, targetPercentage));
            }

            // =======================================================================
            // 2. ANIMASI BAR (SMOOTH TRANSITION CUSTOM)
            //    - Menggunakan lerp dengan requestAnimationFrame agar naik-turunnya
            //      lebih halus, khususnya untuk perubahan besar.
            // =======================================================================
            const evalBar = $('#evaluationFillAutoRun');
            if (!evalBar.length) return;

            const start = myVars.lastBarPercentage;
            const end = targetPercentage;

            // Kalau perubahannya sangat kecil, langsung set saja
            if (Math.abs(end - start) < 0.5) {
                evalBar.css({
                    width: `${end}%`,
                    'background-color': (mateProxyValue !== null ? mateProxyValue : rawScore) >= 0 ? '#4CAF50' : '#FF4500'
                });
                myVars.lastBarPercentage = end;
            } else {
                // Smooth animate manual
                const duration = 500; // ms
                const startTime = performance.now();

                function animateBar(now) {
                    const t = Math.min(1, (now - startTime) / duration);

                    // Ease-out cubic (lebih halus)
                    const eased = 1 - Math.pow(1 - t, 3);
                    const current = start + (end - start) * eased;

                    evalBar.css({
                        width: `${current}%`,
                        'background-color': (mateProxyValue !== null ? mateProxyValue : rawScore) >= 0 ? '#4CAF50' : '#FF4500'
                    });

                    if (t < 1) {
                        requestAnimationFrame(animateBar);
                    } else {
                        myVars.lastBarPercentage = end;
                    }
                }

                requestAnimationFrame(animateBar);
            }

            // =======================================================================
            // 3. SIMPAN SCORE TERAKHIR
            // =======================================================================
            myVars.currentRawScore = rawScore;
            myVars.currentMateValue = mateValue;
            myVars.currentDepth = depth;

            // =======================================================================
            // 4. RENDER TEKS EVAL
            // =======================================================================
            const evalInPawn = rawScore / 100;
            let evalText = '';
            let emoji = '';
            let textColor = '#9E9E9E';
            const emojiStyle = 'position:relative;top:-1px;margin-right:3px;';

            if (mateProxyValue !== null) {
                const sign = mateProxyValue > 0 ? '' : '-';
                const absMate = Math.abs(mateProxyValue);

                emoji = mateProxyValue > 0 ? 'ðŸ‘‘' : 'ðŸ’€';
                textColor = mateProxyValue > 0 ? '#4CAF50' : '#FF4500';

                evalText = `
            <span style="display:flex;align-items:center;font-weight:bold;color:${textColor}">
                <span style="${emojiStyle}">${emoji}</span>
                <span>${sign}M${absMate}</span>
            </span>
        `;
            } else {
                const sign = evalInPawn >= 0 ? '+' : '';
                const absEval = Math.abs(evalInPawn).toFixed(2);

                if (evalInPawn > 1) {
                    emoji = 'ðŸš€'; textColor = '#4CAF50';
                } else if (evalInPawn > 0.3) {
                    emoji = 'â¬†ï¸'; textColor = '#7fa650';
                } else if (evalInPawn < -1) {
                    emoji = 'ðŸš¨'; textColor = '#FF4500';
                } else if (evalInPawn < -0.3) {
                    emoji = 'ðŸª‚'; textColor = '#E96150';
                } else {
                    emoji = 'âš–ï¸';
                }

                evalText = `
            <span style="display:flex;align-items:center;font-weight:bold;color:${textColor}">
                <span style="${emojiStyle}">${emoji}</span>
                <span>${sign}${absEval}</span>
            </span>
        `;
            }

            // =======================================================================
            // 5. STATUS TEXT
            // =======================================================================
            const autoRunStatusText = document.getElementById('autoRunStatusText');
            if (!autoRunStatusText) return;

            let statusText = 'READY';
            let statusColor = '#9E9E9E';

            const currentStatus = (myVars.engineStatus || ENGINE_STATUS1.READY).toUpperCase();

            switch (currentStatus) {
                case ENGINE_STATUS1.RUNNING:
                case ENGINE_STATUS1.THINKING:
                    statusText = 'RUNNING...';
                    statusColor = '#2196F3';
                    break;
                case ENGINE_STATUS1.WAITING:
                    statusText = 'WAITING...';
                    statusColor = '#FFA500';
                    break;
                case ENGINE_STATUS1.DELAY:
                    statusText = 'DELAY';
                    statusColor = '#FFA500';
                    break;
                case ENGINE_STATUS1.IDLE:
                    statusText = 'SLEEP';
                    statusColor = '#FFA500';
                    break;
                case ENGINE_STATUS1.OFF:
                    statusText = 'OFF';
                    statusColor = '#666';
                    break;
            }

            const statusDisplay = `
        <span style="font-size:10px;font-weight:bold;color:${statusColor}">
            ${statusText}
        </span>
    `;

            // =======================================================================
            // 6. RENDER FINAL
            // =======================================================================
            autoRunStatusText.innerHTML = `
        <div style="display:flex;justify-content:space-between;align-items:center;width:100%">
            ${evalText}
            ${statusDisplay}
        </div>
    `;
        };

        myFunctions.debugDepthSettings = function() {
            console.log("=== DEPTH DEBUG INFO ===");
            console.log("myVars.customDepth:", myVars.customDepth);
            console.log("myVars.maxDepthForElo:", myVars.maxDepthForElo);
            console.log("myVars.eloRating:", myVars.eloRating);
            console.log("myVars.skillLevel:", myVars.skillLevel);
            console.log("myVars.useEloLimit:", myVars.useEloLimit);
            console.log("Engine Controller State:", engine?.controller?.state);
            console.log("Engine isBusy:", engine?.controller?.isBusy);
            console.log("========================");
        };

        // Panggil di console untuk cek: myFunctions.debugDepthSettings()
        // ===========================================================================================================================================
        //                                                      âš™ï¸ logika game over âš™ï¸
        // ===========================================================================================================================================
        // ======================================================================
        // ðŸš« DISABLE AUTO RUN (Matikan semua mekanisme otomatis)
        // ======================================================================
        myFunctions.disableAutoRun = function() {
            console.log("%c[System] Mematikan semua mekanisme AutoRun...", "color:#f44336; font-weight:bold;");

            // 1. Set flag utama
            myVars.autoRun = false;
            myVars.isThinking = false;
            myVars.autoRunCooldown = false;

            // 2. Disconnect semua observer
            if (myVars.moveObserver) {
                myVars.moveObserver.disconnect();
                myVars.moveObserver = null;
                console.log("[System] MoveObserver dimatikan.");
            }
            if (typeof boardObserver !== "undefined" && boardObserver) {
                boardObserver.disconnect();
                boardObserver = null;
                console.log("[System] BoardObserver dimatikan.");
            }

            // 3. Bersihkan semua timer terkait AutoRun/Analysis
            const timers = [
                'analysisPollingInterval',
                'autoRunTimeoutId',
                'analysisDelayTimer',
                'premoveInterval',
                'autoMoveTimeout',
                'retryTimer'
            ];
            timers.forEach(t => {
                if (myVars[t]) {
                    clearTimeout(myVars[t]);
                    clearInterval(myVars[t]);
                    myVars[t] = null;
                    console.log(`[System] Timer cleared: ${t}`);
                }
            });

            console.log("%c[System] âœ“ AutoRun OFF â†’ semua script otomatis berhenti.", "color:#4caf50; font-weight:bold;");
        };

        // ======================================================================
        // âœ… ENABLE AUTO RUN (Hidupkan kembali semua mekanisme otomatis)
        // ======================================================================
        myFunctions.enableAutoRun = function() {
            console.log("%c[System] Menghidupkan kembali AutoRun & observer...", "color:#4caf50; font-weight:bold;");

            // 1. Set flag utama
            myVars.autoRun = true;
            myVars.isThinking = false;
            myVars.autoRunCooldown = false;

            // 2. Pasang kembali observer
            if (typeof myFunctions.setupMoveObserver === 'function') {
                myFunctions.setupMoveObserver();
            } else {
                console.warn("[System] setupMoveObserver tidak ditemukan.");
            }
            // 4. Trigger awal supaya engine langsung bangun
            if (typeof scheduleAutoRun === 'function') {
                scheduleAutoRun(1000); // jadwalkan autoRun pertama
            } else {
                myFunctions.checkAndRunAnalysisAutoMove?.();
            }

            console.log("%c[System] âœ“ AutoRun ON â†’ semua script otomatis aktif kembali.", "color:#64dd17; font-weight:bold;");
        };

        // ======================================================================
        // Stop Engine Thinking (SAFE - Sinkron dengan LED)
        // ======================================================================
        myFunctions.stopAllEngines = function() {
            // Stop controller
            if (engine.controller) {
                engine.controller.send("stop");
                engine.controller.send("isready");
            }

            // Stop worker
            if (myVars.analysisEngine) {
                myVars.analysisEngine.postMessage("stop");
                myVars.analysisEngine.postMessage("isready");
            }

            myVars.isThinking = false;
            myFunctions.setEngineState(ENGINE_STATE.READY);
        };

        // ======================================================================
        // Reset Engine for New Game (LED Reloading)
        // ======================================================================
        myFunctions.resetEngine = function () {
            myVars.isThinking = false;

            if (engine.controller) {
                engine.controller.newGame();
                console.log("[Engine] Internal state reset (ucinewgame)");
                myFunctions.setEngineState(ENGINE_STATE.READY);
            } else {
                console.log("[Engine] Controller not found, reloading...");
                myFunctions.loadChessEngine();
            }
        };

        // ======================================================================
        // Detect Game Over (Akurasi Tinggi dengan Chess.js)
        // ======================================================================
        function detectGameOver(fen) {
            if (!fen) return false;
            try {
                const game = new Chess(fen);
                return game.game_over();
            } catch (e) {
                return false;
            }
        }

        // ======================================================================
        // Game Over Handler + New Game Recovery
        // ======================================================================
        myFunctions.checkAndHandleGameOver = function () {
            // Kalau AutoRun OFF â†’ jangan pasang observer
            if (!myVars.autoRun) {
                // console.log("[guard] AutoRun OFF â†’ observer tidak dipasang.");
                return;
            }
            const gameOverSelectors = [
                '.game-over-modal-content',
                '.game-over-modal',
                '.result-container',
                '.modal-dialog-message',
                '.game-over-header',
                '[data-test-marker="game-over"]',
                '[data-cy="sidebar-game-over-new-game-button"]',
                '.game-over-buttons-component',
                '.post-game-view'
            ];

            const detectedGameOver = gameOverSelectors.some(selector => document.querySelector(selector));

            // --- SITUASI 1: GAME OVER ---
            if (detectedGameOver) {
                if (myVars.isGameOver) return;

                myVars.isGameOver = true;
                myVars.gameEnded = true;
                myVars.blockMove = true;

                console.log('%c[CLEANUP] GAME OVER â†’ Pembersihan total...', 'color:#ff5252; font-weight:bold');

                if (typeof myFunctions.stopAnalysisEngineSafe === 'function') {
                    myFunctions.stopAnalysisEngineSafe();
                }

                const timersToClear = [
                    'analysisInterval','premoveInterval','analysisDelayTimer',
                    'analysisPollingInterval','feedbackTimer','autoMoveTimeout'
                ];
                timersToClear.forEach(timerName => {
                    if (myVars[timerName]) {
                        clearInterval(myVars[timerName]);
                        clearTimeout(myVars[timerName]);
                        myVars[timerName] = null;
                        console.log(`[CLEANUP] Timer cleared: ${timerName}`);
                    }
                });

                myVars.topMoves = [];
                myVars.lastPV = '';
                myVars.currentEvaluationText = '0.00';
                myVars.lastAnalyzedFen = null;
                myVars.acplHistory = [];

                const engineInstance = myVars.analysisEngine || window.engine?.engine;
                if (engineInstance) {
                    try {
                        engineInstance.postMessage('stop');
                        engineInstance.postMessage('ucinewgame');
                        engineInstance.postMessage('isready');
                    } catch (e) {
                        console.warn('[CLEANUP] Engine postMessage failed:', e);
                    }
                }

                if (myVars.moveObserver) {
                    myVars.moveObserver.disconnect();
                    myVars.moveObserver = null;
                    console.log('[CLEANUP] MoveObserver disconnected');
                }

                return;
            }

            // --- SITUASI 2: NEW GAME ---
            if (!detectedGameOver && myVars.isGameOver) {
                console.log('%c[SYSTEM] Game Baru Terdeteksi â†’ Resetting Flags', 'color:#00ff00; font-weight:bold');

                myVars.isGameOver = false;
                myVars.gameEnded = false;
                myVars.blockMove = false;
                myVars.lastAnalyzedFen = null;
                myVars.topMoves = [];

                if (typeof myFunctions.setupMoveObserver === 'function') {
                    myFunctions.setupMoveObserver();
                }

                myFunctions.setEngineState(ENGINE_STATE.READY);
                myFunctions.updateTurnStatus?.();
            }
        };

        // ======================================================================
        // Manual Reset & Game State Handlers
        // ======================================================================
        myFunctions.setGameOver = function (reason) {
            myVars.blockMove = true;
            myVars.isGameOver = true;
            myVars.gameEnded = true;
            console.log("[GAME OVER EVENT]", reason);
        };

        // 1. Fungsi untuk Meriset State ke Kondisi Awal
        myFunctions.resetForNewGame = function () {
            console.log("%c[System] Resetting state for new game...", "color:#4caf50; font-weight:bold;");

            myFunctions.clearMoveHistory();
            // Reset flag utama
            myVars.isGameOver = false;
            myVars.gameEnded = false;
            myVars.blockMove = false;
            myVars.isThinking = false;
            myVars.lastAnalyzedFen = null;
            myVars.topMoves = [];

            // Bersihkan UI jika ada
            myFunctions.clearHighlights?.();
            myFunctions.clearPvArrows?.();

            // Reload engine agar fresh
            if (engine.controller) {
                engine.controller.send("ucinewgame");
                engine.controller.send("isready");
            }

            // Pasang observer ulang
            if (!myVars.moveObserver && typeof myFunctions.setupMoveObserver === "function") {
                myFunctions.setupMoveObserver();
            }

            // Set status ke READY
            myFunctions.setEngineState?.(ENGINE_STATE.READY, "NEW_GAME");

            console.log("%c[System] âœ“ Reset complete. Engine ready.", "color:#64dd17;");
        };


        // ======================================================================
        // â±ï¸ INACTIVITY WATCHDOG (PEMBERSIH OTOMATIS)
        // ======================================================================
        let inactivityTimer = null;

        myFunctions.startInactivityWatchdog = function() {
            // 1. Selalu bersihkan timer lama sebelum memulai yang baru
            clearTimeout(inactivityTimer);

            // 2. Jika status sudah aman (READY/IDLE), jangan jalankan watchdog
            if (myVars.engineStatus === ENGINE_STATUS1.READY ||
                myVars.engineStatus === ENGINE_STATUS1.IDLE) {
                return;
            }

            // 3. Set timer toleransi (Contoh: 15 detik)
            const TOLERANCE_MS = 15000;

            inactivityTimer = setTimeout(() => {
                // Cek apakah masih dalam kondisi stuck
                const isStuck = (
                    myVars.engineStatus === ENGINE_STATUS1.DELAY ||
                    myVars.engineStatus === ENGINE_STATUS1.THINKING
                );

                if (isStuck) {
                    console.warn(`%c[Watchdog] Engine stuck in ${myVars.engineStatus} for > 15s. Resetting...`,
                                 'color: #ff9800; font-weight: bold;');

                    // Lakukan reset total agar bot bisa berpikir kembali
                    if (typeof myFunctions.safeStateReset === 'function') {
                        myFunctions.safeStateReset('INACTIVITY_TIMEOUT');
                    } else {
                        // Fallback jika safeStateReset belum terdefinisi
                        myFunctions.stopEngine();
                    }
                }
            }, TOLERANCE_MS);
        };

        // ======================================================================
        // ðŸ›¡ï¸ SAFE STATE RESET (THE EMERGENCY RECOVER)
        // ======================================================================
        myFunctions.safeStateReset = function (reason = 'AUTO_CLEANUP') {
            console.log(`%c[System] ðŸ§¹ Resetting State: ${reason}`, "color: #ff5722; font-weight: bold;");

            // 1. Matikan Watchdog agar tidak memicu reset ganda
            if (typeof inactivityTimer !== 'undefined') {
                clearTimeout(inactivityTimer);
            }

            // 2. Hentikan semua timer yang sedang berjalan (UI & AutoMove)
            const timers = [
                'autoRunTimeoutId',
                'analysisDelayTimer',
                'premoveInterval',
                'autoMoveTimeout'
            ];

            timers.forEach(timerName => {
                if (myVars[timerName]) {
                    clearTimeout(myVars[timerName]);
                    clearInterval(myVars[timerName]);
                    myVars[timerName] = null;
                }
            });

            // 3. Reset Flag Utama & Proteksi Anti-Stuck
            myVars.isThinking = false;
            myVars.autoRunCooldown = false;
            myVars.isSmoothDragging = false;
            myVars.resignationPending = false;
            myVars.blockMove = false; // Membuka kunci pergerakan jika sempat terkunci

            // 4. Reset Engine Controller secara mendalam
            if (engine.controller) {
                try {
                    engine.controller.isBusy = false;

                    // Jika macet parah (FORCE_RESET atau Watchdog), kirim sinyal stop keras ke UCI
                    if (reason === 'FORCE_RESET' || reason === 'INACTIVITY_TIMEOUT') {
                        engine.controller.send("stop");
                        engine.controller.send("isready");
                        console.warn("[System] Hard engine stop signal sent.");
                    }
                } catch (err) {
                    console.error("[System] Failed to reset controller:", err);
                }
            }

            // 5. Sinkronisasi UI (LED & Status)
            // Set state internal ke READY
            if (typeof myFunctions.setEngineState === 'function') {
                myFunctions.setEngineState(ENGINE_STATE.READY);
            }

            console.log(`%c[System] âœ“ Recovery successful (${reason}). Ready to work.`, "color: #4caf50;");
        };
        // ======================================================================
        // DETEKSI KLIK TOMBOL NEW GAME (Versi Aman)
        // ======================================================================
        document.addEventListener('mousedown', function (e) {
            const btnText = e.target.innerText?.toLowerCase() || "";
            const isNewGameBtn =
                  btnText.includes('new game') ||
                  btnText.includes('rematch') ||
                  btnText.includes('play') ||
                  e.target.closest('.game-over-buttons-component') ||
                  e.target.closest('[data-cy="new-game-button"]');

            if (isNewGameBtn) {
                console.log("%c[System] New Game/Rematch terdeteksi â†’ Reset State.", "color:#4caf50; font-weight:bold;");

                // Reset flag utama
                myVars.isGameOver = false;
                myVars.gameEnded = false;
                myVars.blockMove = false;
                myVars.isThinking = false;
                myVars.lastAnalyzedFen = null;
                myVars.topMoves = [];

                // Reset engine
                if (typeof myFunctions.resetEngine === "function") {
                    myFunctions.resetEngine();
                }

                // Pasang observer ulang
                if (typeof myFunctions.setupMoveObserver === "function") {
                    myFunctions.setupMoveObserver();
                }

                // Set status ke READY
                myFunctions.setEngineState?.(ENGINE_STATE.READY, "NEW_MATCH");

                // Trigger AutoRun pertama setelah delay kecil
                if (typeof scheduleAutoRun === "function" && myVars.autoRun) {
                    setTimeout(() => scheduleAutoRun(1000), 500);
                }

                return;
            }
        }, true);


        // ===========================================================================================================================================
        //                                                      âš™ï¸ logika mid dan andgame âš™ï¸
        // ===========================================================================================================================================

        // ===========================================================================
        // ðŸ‘ï¸ GLOBAL OBSERVER HANDLER
        // ===========================================================================
        let boardObserver = null;

        // 1. Smart Observer Setup (Unified)
        myFunctions.smartSetupObserver = function() {
            myFunctions.stopAllBoardWatchers();

            // Cari elemen papan (Prioritas: Web Component > DOM Biasa)
            const boardElement = document.querySelector('wc-chess-board') ||
                  document.querySelector('chess-board') ||
                  document.querySelector('.board-layout-main') ||
                  document.querySelector('#board-single');

            if (!boardElement) {
                console.warn("[Observer] Board not found, retrying in 1s...");
                myVars.retryTimer = setTimeout(myFunctions.smartSetupObserver, 1000);
                return;
            }

            console.log("[Observer] Attached to:", boardElement.tagName || boardElement.className);

            const config = {
                childList: true,
                subtree: true,
                attributes: true,
                attributeFilter: ['class', 'style', 'data-fen'] // Watch specific attributes
            };

            let debounceTimer = null;

            boardObserver = new MutationObserver((mutations) => {
                if (myVars.isGameOver) return;

                // Debounce simple untuk mencegah spam
                clearTimeout(debounceTimer);
                debounceTimer = setTimeout(() => {
                    const currentFen = myFunctions.getFenFromBoard();

                    // Hanya trigger jika FEN valid dan BERBEDA dari yang terakhir dilihat
                    if (currentFen && currentFen !== myVars.lastObservedFen) {
                        console.log(`%c[Move] ${currentFen.split(" ")[1] === 'w' ? 'Black' : 'White'} moved`, "color: #9C27B0");

                        myVars.lastObservedFen = currentFen;

                        // Update Virtual Board
                        if (myVars.useVirtualChessboard) {
                            myFunctions.updateVirtualChessboard();
                        }

                        // Trigger Engine Analysis
                        if (myVars.autoRun) {
                            myFunctions.updateAutoRunStatus?.(ENGINE_STATUS1.DELAY, 'MOVE_DETECTED');
                            if (typeof scheduleAutoRun === 'function') {
                                scheduleAutoRun(500); // Small delay before thinking
                            }
                        }
                    }
                }, 150); // 150ms debounce
            });

            boardObserver.observe(boardElement, config);
        };

        // 2. Stop All Observers
        myFunctions.stopAllBoardWatchers = function() {
            if (boardObserver) {
                boardObserver.disconnect();
                boardObserver = null;
            }
            if (myVars.retryTimer) clearTimeout(myVars.retryTimer);
        };

        // ===========================================================================
        // ðŸ‘ï¸ IMPROVED MUTATION OBSERVER (dengan delay aman)
        // ===========================================================================
        myFunctions.startObservation = function() {
            if (boardObserver) boardObserver.disconnect();

            const boardElement = document.querySelector('wc-chess-board') || document.querySelector('chess-board');
            if (!boardElement) {
                myVars.retryTimer = setTimeout(myFunctions.startObservation, 2000);
                return;
            }

            if (myVars.retryTimer) {
                clearTimeout(myVars.retryTimer);
                myVars.retryTimer = null;
            }

            const config = { childList: true, subtree: true, attributes: true, attributeFilter: ['class'] };

            let throttleTimer = null;
            const callback = () => {
                if (myVars.isGameOver) return;
                clearTimeout(throttleTimer);
                throttleTimer = setTimeout(() => {
                    const currentFen = myFunctions.getFenFromBoard();
                    if (currentFen && currentFen !== myVars.lastObservedFen) {
                        console.log("%c[Observer] Move Detected!", "color: #4CAF50");
                        myVars.lastObservedFen = currentFen;
                        myFunctions.updateAutoRunStatus?.(ENGINE_STATUS1.DELAY, 'MOVE_DETECTED');
                        myFunctions.scheduleAutoRun?.(currentFen);
                    }
                }, 300); // delay aman
            };

            boardObserver = new MutationObserver(callback);
            boardObserver.observe(boardElement, config);
            console.log("%c[Observer] Eyes are open. Watching the board...", "color: #ff9800; font-weight: bold;");
        };

        // ===========================================================================
        // ðŸ‘ï¸ SETUP MOVE OBSERVER (dengan delay aman)
        // ===========================================================================
        myFunctions.setupMoveObserver = function () {
            if (!myVars.autoRun) return;

            if (myVars.analysisPollingInterval) clearInterval(myVars.analysisPollingInterval);
            if (myVars.moveObserver) {
                myVars.moveObserver.disconnect();
                myVars.moveObserver = null;
            }

            const targetNode = document.querySelector(
                '.board-layout-main, #board-layout-main, .board-container, #board-single'
            );

            if (!targetNode) {
                console.warn("[Observer] Papan tidak ditemukan, polling fallback...");
                myVars.analysisPollingInterval = setInterval(() => {
                    const reCheckBoard = document.querySelector('.board-layout-main, .board-container');
                    if (reCheckBoard) {
                        myFunctions.setupMoveObserver();
                    }
                    myFunctions.checkAndRunAnalysisAutoMove?.();
                }, 1000);
                return;
            }

            const observerConfig = {
                childList: true,
                subtree: true,
                attributes: true,
                attributeFilter: ['class','style','data-square']
            };
            let debounceTimer = null;

            const callback = function () {
                if (myVars.isGameOver) return;
                clearTimeout(debounceTimer);
                debounceTimer = setTimeout(() => {
                    if (myVars.useVirtualChessboard) {
                        myFunctions.updateVirtualChessboard();
                    }
                    myFunctions.checkAndRunAnalysisAutoMove?.();
                }, 300); // delay aman
            };

            myVars.moveObserver = new MutationObserver(callback);
            myVars.moveObserver.observe(targetNode, observerConfig);

            console.log("%c[Observer] ðŸ‘ï¸ Mata Bot Aktif + Virtual Board Sinkron!", "color:#4caf50; font-weight:bold;");
        };

        // ===========================================================================
        // ðŸ§© ACCURATE FEN GENERATOR (lebih aman)
        // ===========================================================================
        myFunctions.getFenFromBoard = function() {
            try {
                const boardElement = document.querySelector('wc-chess-board') || document.querySelector('chess-board');
                if (!boardElement) return null;

                // 1. Utamakan FEN bawaan dari game state
                if (boardElement.game?.getFen) {
                    const fen = boardElement.game.getFen();
                    if (fen) return fen;
                }

                // 2. Kalau game belum siap, langsung return startpos
                if (!boardElement.querySelector('.piece')) {
                    return "rnbqkbnr/pppppppp/8/8/8/8/PPPPPPPP/RNBQKBNR w KQkq - 0 1";
                }

                // 3. Fallback manual parsing
                let board = Array(8).fill(null).map(() => Array(8).fill(null));
                const pieces = boardElement.querySelectorAll('.piece');

                pieces.forEach(el => {
                    const classes = el.getAttribute('class');
                    const pieceMatch = classes.match(/\b([wb][prnbqk])\b/);
                    const squareMatch = classes.match(/square-(\d)(\d)/);

                    if (pieceMatch && squareMatch) {
                        const color = pieceMatch[1][0];
                        const type = pieceMatch[1][1];
                        const col = parseInt(squareMatch[1]) - 1;
                        const row = 8 - parseInt(squareMatch[2]);

                        const fenChar = color === 'w' ? type.toUpperCase() : type.toLowerCase();
                        if (row >= 0 && row < 8 && col >= 0 && col < 8) {
                            board[row][col] = fenChar;
                        }
                    }
                });

                let fenRows = [];
                for (let r = 0; r < 8; r++) {
                    let emptyCount = 0;
                    let rowStr = "";
                    for (let c = 0; c < 8; c++) {
                        if (!board[r][c]) {
                            emptyCount++;
                        } else {
                            if (emptyCount > 0) { rowStr += emptyCount; emptyCount = 0; }
                            rowStr += board[r][c];
                        }
                    }
                    if (emptyCount > 0) rowStr += emptyCount;
                    fenRows.push(rowStr);
                }

                const sideToMove = boardElement.game?.getTurn?.() || "w";
                const castling = boardElement.game?.getOptions?.().castlingRights || "KQkq";

                const finalFen = `${fenRows.join('/')} ${sideToMove} ${castling} - 0 1`;

                // 4. Validasi opsional
                try {
                    const game = new Chess(finalFen);
                    return game.fen();
                } catch (e) {
                    console.warn("[FEN] Fallback ke startpos karena parsing gagal");
                    return "rnbqkbnr/pppppppp/8/8/8/8/PPPPPPPP/RNBQKBNR w KQkq - 0 1";
                }

            } catch (err) {
                return null;
            }
        };

        // Reset engine state saat halaman load
        window.addEventListener("load", () => {
            myFunctions.setEngineState(ENGINE_STATE.READY);
            myVars.lastObservedFen = null;
        });

        // Helper untuk mendeteksi giliran siapa (berdasarkan move list terakhir)
        myFunctions.getSideToMove = function() {
            const moveList = document.querySelectorAll('.move-node');
            if (moveList.length === 0) return 'w';
            return (moveList.length % 2 !== 0) ? 'b' : 'w';
        };

        // ======================================================================
        // ðŸ”„ Convert FEN â†’ Board Array (8x8)
        // ======================================================================
        function fenToBoardArray(fen) {
            const rows = fen.split(" ")[0].split("/");
            const board = [];
            for (let row of rows) {
                const boardRow = [];
                for (let char of row) {
                    if (isNaN(char)) {
                        boardRow.push(char);
                    } else {
                        for (let i = 0; i < parseInt(char); i++) boardRow.push(null);
                    }
                }
                board.push(boardRow);
            }
            return board;
        }

        // ======================================================================
        // âš–ï¸ Evaluate Board Complexity
        // ======================================================================
        function evaluateBoardComplexity(boardState) {
            let pieceCount = 0;
            for (let r = 0; r < 8; r++) {
                for (let c = 0; c < 8; c++) {
                    if (boardState[r][c]) pieceCount++;
                }
            }
            return { count: pieceCount };
        }

        // ======================================================================
        // â±ï¸ Dynamic Thinking Time & Depth
        // ======================================================================
        function getDynamicThinkingTime(complexityObj, timeLeftMs = 30000) {
            const baseTime = 800;
            const extraTime = complexityObj.count * 60;

            let multiplier = 1.0;
            if (timeLeftMs < 5000) {
                multiplier = 0.3;
            } else if (timeLeftMs < 15000) {
                multiplier = 0.6;
            }

            const jitter = Math.random() * 500;
            return Math.min((baseTime + extraTime + jitter) * multiplier, 3500);
        }

        function getDynamicDepth(complexityObj) {
            if (complexityObj.count <= 10) return 24; // Endgame
            if (complexityObj.count <= 20) return 20; // Middlegame
            if (complexityObj.count <= 28) return 18; // Early Middlegame
            return 15; // Opening
        }

        function shouldIncreaseDepth(currentEval, lastEval) {
            if (!lastEval) return false;
            const delta = Math.abs(currentEval - lastEval);
            return delta > 1.5; // perubahan besar â†’ naikkan depth
        }

        // ======================================================================
        // ðŸš€ Engine Wake Up dengan penyesuaian depth otomatis
        // ======================================================================
        myFunctions.wakeUpEngine = function(currentEval, lastEval) {
            myVars.isThinking = false;

            const currentFen = myFunctions.getFenFromBoard();
            if (!currentFen) return;

            const boardArray = fenToBoardArray(currentFen);
            const complexity = evaluateBoardComplexity(boardArray);

            let depth = getDynamicDepth(complexity);
            const time = getDynamicThinkingTime(complexity);

            // Tambahkan depth jika evaluasi berubah drastis
            if (shouldIncreaseDepth(currentEval, lastEval)) {
                depth += 4; // contoh: naikkan 4 ply
                console.log(`[Engine] Depth increased due to eval swing! New Depth=${depth}`);
            }

            console.log(`[Engine] Wake Up | Depth: ${depth} | Time: ${time}ms`);

            if (myVars?.analysisEngine) {
                myVars.analysisEngine.postMessage(`position fen ${currentFen}`);
                myVars.analysisEngine.postMessage(`go depth ${depth}`);
            }

            if (myVars.autoRun && typeof scheduleAutoRun === 'function') {
                scheduleAutoRun(time);
            }
        };

        // ======================================================================
        // ðŸš€ Dynamic Analysis
        // ======================================================================
        function runDynamicAnalysis(boardState, currentEval, lastEval) {
            const complexity = evaluateBoardComplexity(boardState);
            let depth = getDynamicDepth(complexity);
            const thinkingTime = getDynamicThinkingTime(complexity);

            if (shouldIncreaseDepth(currentEval, lastEval)) {
                depth += 4;
                console.log(`[Dynamic] Depth increased due to eval swing! New Depth=${depth}`);
            }

            console.log(`[Dynamic] Complexity=${complexity.count}, Time=${thinkingTime}ms, Depth=${depth}`);

            if (myVars?.analysisEngine) {
                myVars.analysisEngine.postMessage(`position fen ${myVars.game.fen()}`);
                myVars.analysisEngine.postMessage(`go depth ${depth}`);
            }

            if (typeof scheduleAutoRun === 'function') {
                scheduleAutoRun(thinkingTime);
            }
        }

        function onMoveDetected() {
            const currentFen = myVars.game.fen();

            if (currentFen !== myVars.lastObservedFen) {
                myVars.lastObservedFen = currentFen;
                console.log(`[Observer] Move Detected!`, '#4CAF50');

                if (myVars.autoRun) {
                    scheduleAutoRun();
                }
            }
        }

        // ===========================================================================================================================================
        //                                                      âš™ï¸ papan virtual âš™ï¸
        // ===========================================================================================================================================
        // ======================================================================
        // ðŸ§­ Board Orientation & Square Utilities
        // ======================================================================
        // 5. Utility
        myFunctions.getBoardOrientation = function() {
            // Coba deteksi dari DOM class chess.com
            const board = document.querySelector('chess-board, wc-chess-board');
            if (board && board.getAttribute('flipped') !== null) return 'black';
            if (board && board.classList.contains('flipped')) return 'black';

            // Fallback ke variabel internal jika ada
            return myVars.boardOrientation || 'white';
        };

        myFunctions.squareToPosition = function (square, orientation) {
            const validSquare = /^[a-h][1-8]$/;
            if (!validSquare.test(square)) return { x: NaN, y: NaN };

            const file = square.charCodeAt(0) - 97;
            const rank = parseInt(square[1], 10) - 1;

            let col, row;
            if (orientation === 'white') {
                col = file;
                row = 7 - rank;
            } else {
                col = 7 - file;
                row = rank;
            }
            return { x: col * 12.5, y: row * 12.5 };
        };

        myFunctions.squareToCenter = function (square, orientation) {
            const p = myFunctions.squareToPosition(square, orientation);
            return { x: p.x + 6.25, y: p.y + 6.25 };
        };

        // ======================================================================
        // ðŸ“¥ Virtual Chessboard Renderer (dengan angka & huruf)
        // ======================================================================
        myFunctions.updateVirtualChessboard = function () {
            const boardEl = document.getElementById("virtualChessboard");
            if (!boardEl) return;

            const fen = myFunctions.getStableFen?.() || myVars.lastObservedFen;
            if (!fen) return;

            const orientation = myFunctions.getBoardOrientation(); // 'white' atau 'black'

            // Optimasi: Jangan gambar ulang jika FEN dan Orientasi tidak berubah
            const stateKey = fen + orientation;
            if (stateKey === myVars.lastRenderedKey) {
                myFunctions.updateArrowsOnly();
                return;
            }
            myVars.lastRenderedKey = stateKey;

            boardEl.innerHTML = "";
            boardEl.style.position = "relative";
            boardEl.style.backgroundColor = "#262421"; // Warna dasar kontras

            // 1. Gambar Petak (Squares)
            for (let r = 0; r < 8; r++) {
                for (let c = 0; c < 8; c++) {
                    const sq = document.createElement("div");
                    sq.style.position = "absolute";
                    sq.style.width = "12.5%";
                    sq.style.height = "12.5%";
                    sq.style.left = (c * 12.5) + "%";
                    sq.style.top = (r * 12.5) + "%";
                    sq.style.background = (r + c) % 2 === 0 ? "#f0d9b5" : "#b58863";
                    boardEl.appendChild(sq);
                }
            }

            // 2. Gambar Bidak (Pieces) Berdasarkan FEN & Orientasi
            const boardArray = fenToBoardArray(fen); // Gunakan fungsi helper sebelumnya

            for (let r = 0; r < 8; r++) {
                for (let c = 0; c < 8; c++) {
                    // Jika Black, kita balik indeks pembacaan array
                    const rowIdx = orientation === 'white' ? r : 7 - r;
                    const colIdx = orientation === 'white' ? c : 7 - c;

                    const pieceChar = boardArray[rowIdx][colIdx];
                    if (pieceChar) {
                        const piece = document.createElement("div");
                        piece.style.position = "absolute";
                        piece.style.width = "12.5%";
                        piece.style.height = "12.5%";
                        piece.style.left = (c * 12.5) + "%";
                        piece.style.top = (r * 12.5) + "%";
                        piece.style.zIndex = 5;
                        piece.style.backgroundSize = "contain";
                        piece.style.backgroundRepeat = "no-repeat";

                        const color = pieceChar === pieceChar.toLowerCase() ? "b" : "w";
                        const type = pieceChar.toLowerCase();
                        piece.style.backgroundImage = `url(https://www.chess.com/chess-themes/pieces/neo/150/${color}${type}.png)`;
                        boardEl.appendChild(piece);
                    }
                }
            }

            // 3. Gambar Label Dinamis (Rank & File)
            for (let i = 0; i < 8; i++) {
                // Label Rank (1-8)
                const rankLabel = document.createElement("div");
                rankLabel.textContent = orientation === 'white' ? (8 - i) : (i + 1);
                rankLabel.style.cssText = `position:absolute; left:-18px; top:${i*12.5}%; height:12.5%; display:flex; align-items:center; font-size:10px; color:#fff;`;
                boardEl.appendChild(rankLabel);

                // Label File (a-h)
                const fileLabel = document.createElement("div");
                fileLabel.textContent = orientation === 'white' ? String.fromCharCode(97 + i) : String.fromCharCode(104 - i);
                fileLabel.style.cssText = `position:absolute; top:100%; left:${i*12.5}%; width:12.5%; text-align:center; font-size:10px; color:#fff;`;
                boardEl.appendChild(fileLabel);
            }

            myFunctions.updateArrowsOnly();
        };

        // ======================================================================
        // 3. Helper: Draw Single SVG Arrow with Number
        // ======================================================================
        myFunctions.drawSvgArrow = function(svg, fromSq, toSq, color, opacity, orientation, rankNumber) {
            const getCenter = (sq) => {
                const col = sq.charCodeAt(0) - 97; // 'a'->0
                const row = 8 - parseInt(sq[1]); // '8'->0

                const x = orientation === 'white' ? col : 7 - col;
                const y = orientation === 'white' ? row : 7 - row;

                return { x: x * 12.5 + 6.25, y: y * 12.5 + 6.25 };
            };

            const start = getCenter(fromSq);
            const end = getCenter(toSq);
            const markerId = `head-${color.replace("#","")}`;

            // Define Marker (Arrowhead) if not exists
            let defs = svg.querySelector("defs");
            if (!defs) {
                defs = document.createElementNS("http://www.w3.org/2000/svg", "defs");
                svg.appendChild(defs);
            }
            if (!defs.querySelector(`#${markerId}`)) {
                const marker = document.createElementNS("http://www.w3.org/2000/svg", "marker");
                marker.setAttribute("id", markerId);
                marker.setAttribute("markerWidth", "3"); // Sedikit diperkecil agar rapi
                marker.setAttribute("markerHeight", "3");
                marker.setAttribute("refX", "2");
                marker.setAttribute("refY", "1.5");
                marker.setAttribute("orient", "auto");

                const poly = document.createElementNS("http://www.w3.org/2000/svg", "polygon");
                poly.setAttribute("points", "0 0, 3 1.5, 0 3, 1 1.5"); // Bentuk panah lebih tajam
                poly.setAttribute("fill", color);
                marker.appendChild(poly);
                defs.appendChild(marker);
            }

            // Draw Line
            const path = document.createElementNS("http://www.w3.org/2000/svg", "path");
            path.setAttribute("d", `M${start.x},${start.y} L${end.x},${end.y}`);
            path.setAttribute("stroke", color);
            path.setAttribute("stroke-width", rankNumber === 1 ? "1.8" : "1.2"); // Best move lebih tebal
            path.setAttribute("marker-end", `url(#${markerId})`);
            path.setAttribute("opacity", opacity);
            path.setAttribute("fill", "none");
            svg.appendChild(path);

            // --- LOGIKA PENOMORAN (NUMBER BADGE) ---
            if (rankNumber !== undefined && rankNumber !== null) {
                // Hitung titik tengah
                const midX = (start.x + end.x) / 2;
                const midY = (start.y + end.y) / 2;

                // Group untuk teks agar berada di atas garis
                const g = document.createElementNS("http://www.w3.org/2000/svg", "g");

                // Lingkaran latar belakang (agar angka terbaca jelas di atas papan/garis)
                const circle = document.createElementNS("http://www.w3.org/2000/svg", "circle");
                circle.setAttribute("cx", midX);
                circle.setAttribute("cy", midY);
                circle.setAttribute("r", "3.5"); // Radius lingkaran
                circle.setAttribute("fill", color); // Warna sama dengan panah
                circle.setAttribute("stroke", "#fff");
                circle.setAttribute("stroke-width", "0.5");
                circle.setAttribute("opacity", "1"); // Selalu solid agar teks terbaca

                // Teks Angka
                const text = document.createElementNS("http://www.w3.org/2000/svg", "text");
                text.setAttribute("x", midX);
                text.setAttribute("y", midY);
                text.setAttribute("dy", "1.2"); // Adjustment vertical center
                text.setAttribute("text-anchor", "middle"); // Horizontal center
                text.setAttribute("fill", "#ffffff"); // Warna teks putih
                text.setAttribute("font-size", "4");
                text.setAttribute("font-family", "Arial, sans-serif");
                text.setAttribute("font-weight", "bold");
                text.textContent = rankNumber;

                g.appendChild(circle);
                g.appendChild(text);
                svg.appendChild(g);
            }
        };

        // 4. Helper: Highlight Square
        myFunctions.highlightBestMoveSquares = function(from, to) {
            const boardEl = document.getElementById("virtualChessboard");
            if (!boardEl) return;

            const orientation = myFunctions.getBoardOrientation();

            [from, to].forEach(sq => {
                const col = sq.charCodeAt(0) - 97;
                const row = 8 - parseInt(sq[1]);

                const x = orientation === 'white' ? col : 7 - col;
                const y = orientation === 'white' ? row : 7 - row;

                const hl = document.createElement("div");
                hl.className = "bestmove-highlight";
                hl.style.cssText = `position:absolute; width:12.5%; height:12.5%; left:${x*12.5}%; top:${y*12.5}%; background-color:rgba(255, 215, 0, 0.4); z-index:4;`;
                boardEl.appendChild(hl);
            });
        };

        // ======================================================================
        // Restore arrows setelah board di-reset
        // ======================================================================
        myFunctions.restoreArrows = function() {
            if (!myVars.lastArrows) return;
            myVars.lastArrows.forEach(a => {
                myFunctions.renderSvgArrowsVirtual(a.fromSquare, a.toSquare, a.color, a.opacity, myFunctions.getBoardOrientation());
            });
        };

        // ======================================================================
        // 2. Render SVG Arrows (Layer terpisah)
        // ======================================================================
        myFunctions.updateArrowsOnly = function() {
            const boardEl = document.getElementById("virtualChessboard");
            if (!boardEl) return;

            // Hapus SVG lama
            const oldSvg = boardEl.querySelector("svg.virtual-arrows");
            if (oldSvg) oldSvg.remove();

            // Hapus Highlight lama
            boardEl.querySelectorAll(".bestmove-highlight").forEach(el => el.remove());

            const orientation = myFunctions.getBoardOrientation();
            const moves = myVars.virtualBoardBestMoves || [];

            if (moves.length === 0) return;

            // Highlight Best Move Squares
            const bestMove = moves[0];
            if (bestMove) {
                myFunctions.highlightBestMoveSquares(bestMove.from, bestMove.to);
            }

            // Setup SVG Container
            const svg = document.createElementNS("http://www.w3.org/2000/svg", "svg");
            svg.setAttribute("class", "virtual-arrows");
            svg.setAttribute("viewBox", "0 0 100 100");
            svg.style.cssText = "position:absolute; top:0; left:0; width:100%; height:100%; pointer-events:none; z-index:20;";

            // Warna Panah: Biru (Utama), Hijau (Alternatif 1), Merah (Alternatif 2)
            const colors = ["#0055FF", "#00AA00", "#FF4400"];

            // Loop moves dan kirim index (i) untuk penomoran
            moves.forEach((move, i) => {
                const color = colors[i % colors.length];
                const opacity = i === 0 ? 0.9 : 0.6;

                // Parameter terakhir 'i + 1' adalah nomor urut yang akan ditampilkan
                myFunctions.drawSvgArrow(svg, move.from, move.to, color, opacity, orientation, i + 1);
            });

            boardEl.appendChild(svg);
        };

        // ======================================================================
        // ðŸ‘ï¸ Observer dengan Debounce (Anti-Lag)
        // ======================================================================
        myFunctions.setupVirtualBoardObserver = function () {
            const target = document.querySelector('.board-layout-main, .board-container, #board-single');
            if (!target) return;

            let lastFen = null;
            let debounceTimer = null;

            const observer = new MutationObserver(() => {
                clearTimeout(debounceTimer);
                debounceTimer = setTimeout(() => {
                    const fen = myFunctions.getStableFen?.() || myFunctions.getFenFromBoard?.();
                    if (!fen || fen === lastFen) return;
                    lastFen = fen;

                    //console.log("%c[VirtualBoard] Board Updated", "color: #9c27b0");
                    myFunctions.updateVirtualChessboard();

                    // Auto-cleanup highlight
                    const boardEl = document.getElementById("virtualChessboard");
                    if (boardEl) {
                        boardEl.querySelectorAll(".bestmove-highlight").forEach(el => el.remove());
                    }
                }, 100); // Tunggu 100ms setelah gerakan berhenti
            });

            observer.observe(target, { childList: true, subtree: true, attributes: true, attributeFilter: ['class', 'style'] });
            console.log('[VirtualBoard] Observer aktif dengan Debounce.');
        };

        // ======================================================================
        // â™Ÿï¸ Engine â†’ UCI Converter (Multi-Move Support)
        // ======================================================================
        myFunctions.sanToUciList = function(sanList) {
            const fen = myFunctions.getStableFen?.() || myVars.lastObservedFen;
            if (!fen || !Array.isArray(sanList)) return [];

            try {
                // Memeriksa apakah library Chess tersedia (chess.js)
                const game = new Chess(fen);
                const uciMoves = [];

                for (const san of sanList) {
                    if (!san) continue;

                    // Jika format sudah UCI (misal: e2e4), masukkan langsung
                    if (/^[a-h][1-8][a-h][1-8][qrbn]?$/.test(san)) {
                        uciMoves.push(san);
                        game.move(san, { sloppy: true }); // Tetap update state game
                        continue;
                    }

                    // Konversi SAN (misal: Nf3) ke UCI
                    const mv = game.move(san);
                    if (mv) {
                        const promo = mv.promotion ? mv.promotion : "";
                        uciMoves.push(mv.from + mv.to + promo);
                    } else {
                        // Berhenti jika langkah dalam PV tidak legal di posisi ini
                        break;
                    }
                }
                return uciMoves;
            } catch (e) {
                console.error("[UCI-Conv] Error converting SAN:", e);
                return [];
            }
        };

        // ======================================================================
        // ðŸ¹ PV Handler (Menggambar Banyak Jalur Analisis)
        // ======================================================================
        myFunctions.onEnginePV = function(pvList) {
            if (!Array.isArray(pvList) || pvList.length === 0) return;

            // Simpan PV terakhir untuk restore jika window resize/refresh
            myVars.lastPVList = pvList;

            // Deteksi apakah list berisi UCI atau SAN
            let uciMoves = pvList.filter(m => /^[a-h][1-8][a-h][1-8][qrbn]?$/.test(m));

            // Jika engine mengirim SAN (seperti Stockfish versi lama/tertentu), konversi dulu
            if (uciMoves.length === 0) {
                uciMoves = myFunctions.sanToUciList(pvList);
            }

            // Update koordinat untuk Arrow Renderer
            myVars.virtualBoardBestMoves = uciMoves.map(m => ({
                from: m.slice(0, 2),
                to: m.slice(2, 4)
            }));

            const evalScore = parseFloat(myVars.currentEvaluationText);
            myFunctions.checkAutoResign(evalScore);
            // Trigger penggambaran ulang panah pada SVG layer
            myFunctions.updateArrowsOnly();

            // Highlight petak asal dan tujuan dari Langkah Terbaik (Best Move)
            if (uciMoves.length > 0) {
                const best = uciMoves[0];
                myFunctions.highlightBestMoveSquares(best.slice(0, 2), best.slice(2, 4));
            }
        };

        // ======================================================================
        // ðŸ”„ State Change Manager
        // ======================================================================
        myFunctions.afterBoardStateChanged = function () {
            // 1. Gambar ulang seluruh bidak sesuai FEN terbaru
            myFunctions.updateVirtualChessboard();

            // 2. Jika ada data PV yang tersisa dari langkah sebelumnya, bersihkan atau update
            if (myVars.lastPV) {
                const pvMoves = myVars.lastPV.trim().split(/\s+/);
                myFunctions.onEnginePV(pvMoves);
            } else {
                // Jika giliran lawan, bersihkan panah analisis kita
                myVars.virtualBoardBestMoves = [];
                myFunctions.updateArrowsOnly();
            }
        };

        // ======================================================================
        // âš™ï¸ Turn Check (White/Black Aware)
        // ======================================================================
        myFunctions.isEngineTurn = function () {
            try {
                const boardElement = document.querySelector('wc-chess-board, chess-board');
                if (!boardElement || !boardElement.game) return false;

                const turn = boardElement.game.getTurn(); // 'w' atau 'b'

                // Konversi playingAs (1=w, 2=b) ke karakter 'w'/'b'
                const playingAsInt = boardElement.game.getPlayingAs();
                const playingAsStr = playingAsInt === 1 ? 'w' : (playingAsInt === 2 ? 'b' : null);

                return turn === playingAsStr;
            } catch (e) {
                return false;
            }
        };


        // Simpan ID interval secara global agar bisa dibersihkan
        myVars.watchdogId = null;

        function watchdogVirtualBoard(intervalMs = 5000) {
            // Stop jika sudah ada watchdog yang berjalan sebelumnya (mencegah duplikasi)
            if (myVars.watchdogId) {
                clearInterval(myVars.watchdogId);
            }

            myVars.watchdogId = setInterval(() => {
                // Cek apakah data FEN hilang
                if (!myVars.virtualBoardFen || myVars.virtualBoardFen === '') {
                    console.warn('âš ï¸ Virtual board lost, restoring...');

                }

                // Opsional: Validasi apakah modal masih ada di DOM
                // Jika modal sudah dihapus selamanya, watchdog harus berhenti
                const modal = document.getElementById('humanModeInfoModal');
                if (!modal && myVars.watchdogId) {
                    console.log('Stopping watchdog: Modal not found');
                    clearInterval(myVars.watchdogId);
                    myVars.watchdogId = null;
                }
            }, intervalMs);
        }

        // ======================================================================
        // ðŸš€ Bootstrap
        // ======================================================================
        window.addEventListener('DOMContentLoaded', () => {
            watchdogVirtualBoard(5000); // aktifkan watchdog
        });

        // ===========================================================================================================================================
        //                                                      âš™ï¸  âš™ï¸
        // ===========================================================================================================================================
        // ======================================================================
        // Send UCI Command (Universal Guard)
        // ======================================================================
        myFunctions.sendUciCommand = function(cmd) {
            if (engine?.controller) {
                if (cmd === 'stop' || cmd === 'quit') {
                    myVars.isThinking = false;
                } else if (cmd.startsWith('go')) {
                    myVars.isThinking = true;
                } else if (cmd === 'ucinewgame') {
                }

                engine.controller.send(cmd);
                return true;
            }
            return false;
        };
        // ======================================================================
        // Acquire AutoRun Lock
        // ======================================================================
        myFunctions.acquireAutoRunLock = function() {
            if (myVars._autoRunLock) return false;
            myVars._autoRunLock = true;
            setTimeout(() => {
                myVars._autoRunLock = false;
                console.log("[AutoRun] lock released");
            }, 2500);
            console.log("[AutoRun] lock acquired");
            return true;
        };
        // ===============================END====================================

        // ===========================================================================================================================================
        // Helper umum (AMAN)
        // ===========================================================================================================================================
        function debounce(fn, delay = 150) {
            let timer = null;
            return function (...args) {
                clearTimeout(timer);
                timer = setTimeout(() => {
                    fn.apply(this, args);
                }, delay);
            };
        }
        // ===============================END====================================

        // ===========================================================================================================================================
        //                                                      âš™ï¸ LOGOKA MOVE âš™ï¸
        // ===========================================================================================================================================
        // ===========================================================================
        // myFunctions.color (FINAL â€“ Persistent Arrow & Highlight)
        // ===========================================================================
        myFunctions.color = function(bestMove) {
            // Kalau AutoRun OFF â†’ jangan pasang observer
            if (!myVars.autoRun) {
                //  console.log("[guard] AutoRun OFF â†’ observer tidak dipasang.");
                return;
            }

            if (!bestMove || bestMove.length < 4) {
                console.warn("[Color] Best move invalid:", bestMove);
                return;
            }

            const fromSquare = bestMove.substring(0, 2);
            const toSquare = bestMove.substring(2, 4);
            const promotionPiece = bestMove.length > 4 ? bestMove.substring(4) : undefined;

            // 1. AUTO-MOVE
            if (myVars.autoMovePiece === true && typeof myFunctions.movePiece === "function") {
                try {
                    myFunctions.movePiece(fromSquare, toSquare, promotionPiece);
                } catch (err) {
                    console.error("[Color] Auto-move error:", err);
                }
            }

            // Update engine state & turn status
            myFunctions.setEngineState?.(ENGINE_STATE.READY);
            myFunctions.updateTurnStatus?.();
            myFunctions.updateVirtualChessboard();
            myFunctions.setupVirtualBoardObserver();

            // Simpan ke histori langkah
            myFunctions.addMoveToHistory?.(
                bestMove,
                myVars.lastEvalText1,
                lastValue,
                myVars.lastMoveGrade
            );

            // 2. HIGHLIGHT & ARROW
            myFunctions.clearHighlights?.();
            drawArrow({ remove: true }); // selalu bersihkan dulu

            if (!myVars.highlightEnabled) return;

            const highlightColor = myVars.highlightColor1 || "blue";
            const highlightDurationMs = myVars.highlightDurationMs || 5000;

            // Utility konversi 'd4' â†’ '44'
            const convertLetterToNumber = (char) => ({
                a: '1', b: '2', c: '3', d: '4',
                e: '5', f: '6', g: '7', h: '8'
            }[char] || char);

            const startSquareId = convertLetterToNumber(fromSquare[0]) + fromSquare[1];
            const endSquareId = convertLetterToNumber(toSquare[0]) + toSquare[1];

            // Ambil container board dengan guard
            if (!board || !board.nodeName) {
                console.warn("[Color] Board node not available.");
                return;
            }
            const boardNode = $(board.nodeName);
            if (!boardNode.length) {
                console.warn("[Color] Board DOM not found.");
                return;
            }

            // Utility highlight kotak
            const addHighlightBox = (squareId) => {
                boardNode.find(`.highlight-box[data-square="${squareId}"]`).remove();
                boardNode.prepend(`<div class="highlight-box" data-square="${squareId}"></div>`);
            };

            // Utility suggested move box
            const addSuggestedBox = (squareId) => {
                boardNode.find(`.suggested-box[data-square="${squareId}"]`).remove();
                boardNode.prepend(`<div class="suggested-box" data-square="${squareId}"></div>`);
            };

            // a. Tampilkan arrow
            const arrowObj = { f: fromSquare, t: toSquare, color: highlightColor, o: 0.8 };
            drawArrow(arrowObj);

            // b. Highlight kotak
            addHighlightBox(startSquareId);
            addHighlightBox(endSquareId);

            // c. Kotak bingkai suggested move
            addSuggestedBox(startSquareId);
            addSuggestedBox(endSquareId);

            // d. Simpan state agar bisa restore
            myVars.lastArrow = arrowObj;
            myVars.lastHighlights = [startSquareId, endSquareId];

            // e. Hapus otomatis setelah durasi
            setTimeout(() => {
                drawArrow({ remove: true });
                $(".suggested-box").remove();
                myVars.lastArrow = null;
                myVars.lastHighlights = null;
            }, highlightDurationMs);

            console.log(`[Color] Highlighted move ${bestMove} for ${highlightDurationMs}ms.`);
        };

        // ===========================================================================
        // Tambahan: Restore arrow & highlight setelah board di-update
        // ===========================================================================
        myFunctions.restoreHighlights = function() {
            // Kalau AutoRun OFF â†’ jangan pasang observer
            if (!myVars.autoRun) {
                //  console.log("[guard] AutoRun OFF â†’ observer tidak dipasang.");
                return;
            }

            if (!myVars.highlightEnabled) return;
            if (!myVars.lastArrow || !myVars.lastHighlights) return;

            // Restore arrow
            drawArrow(myVars.lastArrow);

            // Restore highlight boxes
            const boardNode = $(board.nodeName);
            if (boardNode.length) {
                myVars.lastHighlights.forEach(squareId => {
                    boardNode.find(`.highlight-box[data-square="${squareId}"]`).remove();
                    boardNode.prepend(`<div class="highlight-box" data-square="${squareId}"></div>`);
                    boardNode.find(`.suggested-box[data-square="${squareId}"]`).remove();
                    boardNode.prepend(`<div class="suggested-box" data-square="${squareId}"></div>`);
                });
            }
        };

        // ===========================================================================
        // myFunctions.getMyColor (Upgrade: Cache + Strong Fallback)
        // ===========================================================================
        myFunctions.getMyColor = function () {
            // 1. Cek cache dulu
            if (myVars.myColor && (myVars.myColor === "w" || myVars.myColor === "b")) {
                return myVars.myColor;
            }

            let detectedColor = null;

            // 2. PRIORITAS: Ambil dari engine / board API
            try {
                if (board?.game?.getPlayingAs) {
                    const color = board.game.getPlayingAs();
                    if (color === "w" || color === "b") {
                        detectedColor = color;
                    }
                }
            } catch (e) {
                console.warn("[getMyColor] gagal dari board.game.getPlayingAs()", e);
            }

            // 3. FALLBACK: Deteksi dari DOM
            if (!detectedColor) {
                try {
                    const playerTag = document.querySelector(".player-tag.is-self");
                    if (playerTag) {
                        let colorAttr = playerTag.getAttribute("data-color");

                        if (!colorAttr) {
                            if (playerTag.classList.contains("white")) colorAttr = "w";
                            else if (playerTag.classList.contains("black")) colorAttr = "b";
                        }

                        if (colorAttr === "w" || colorAttr === "b") {
                            detectedColor = colorAttr;
                        }
                    }
                } catch (e) {
                    console.warn("[getMyColor] gagal membaca warna dari DOM", e);
                }
            }

            // 4. FALLBACK terakhir: dari konfigurasi engine, lalu FEN
            if (!detectedColor) {
                if (myVars.autoAnalysisColor === 'white') detectedColor = 'w';
                else if (myVars.autoAnalysisColor === 'black') detectedColor = 'b';
                else {
                    const fen = myFunctions.getAccurateFen?.();
                    if (fen) {
                        const sideToMove = fen.split(" ")[1];
                        detectedColor = (sideToMove === "w") ? "b" : "w";
                        console.log("[getMyColor] fallback dari FEN:", detectedColor);
                    }
                }
            }

            // 5. Simpan ke cache
            if (detectedColor) {
                myVars.myColor = detectedColor;
                return detectedColor;
            }

            // 6. Gagal total
            console.warn("[getMyColor] Tidak bisa mendeteksi warna pemain.");
            return null;
        };

        // ===============================END====================================

        // ===========================================================================================================================================
        // myFunctions.movePiece (VERSI PERBAIKAN: ANTI-ILLEGAL MOVE & GAME-OVER LOCK)
        // ===========================================================================================================================================
        // ======================================================================
        // ðŸš€ myFunctions.movePiece (Versi Final: Robust & Centralized)
        // ======================================================================
        myFunctions.movePiece = async function (from, to, promotionChar, isPremove = false) {
            if (!myVars.autoRun) return { success: false, error: "AutoRun Off" };

            if (myVars.blockMove === true) {
                console.warn("â›” [BLOCK] Move dikunci (Game selesai/Paused)");
                return { success: false, error: "Move Locked" };
            }

            const game = (typeof getGame === 'function') ? getGame() : null;
            // Validasi dasar
            if (!game || !from || !to) {
                return { success: false, error: "Invalid args" };
            }

            const beforeFen = myFunctions.getStableFen ? myFunctions.getStableFen() : getFen(game);
            if (!beforeFen) return { success: false, error: "Invalid FEN" };

            // --- [IMPROVED] Reset Cache Logic ---
            // Cek berdasarkan jumlah langkah (jika tersedia) atau FEN awal standar
            const isStartPos = beforeFen.startsWith("rnbqkbnr/pppppppp/8/8/8/8/PPPPPPPP/RNBQKBNR");
            const isMoveZero = (game.getHistory && game.getHistory().length === 0);

            if ((isStartPos || isMoveZero) && !myVars.hasResetThisGame) {
                console.warn("[RESET] New game detected via FEN/History.");
                myFunctions.updateAutoRunStatus(ENGINE_STATUS1.DELAY, "AUTO_RUN_EXEC");
                myVars.topMoves = [];
                myVars.lastAnalyzedFen = null;
                myVars.hasResetThisGame = true;
                if(typeof myFunctions.clearMoveHistory === 'function') myFunctions.clearMoveHistory();
            }

            const promo = normalizePromotion(promotionChar);

            // --- Legal Move Check ---
            if (!isLegalMove(game, from, to, promo)) {
                console.error(`âŒ Illegal move detected: ${from}-${to}`);
                myVars.topMoves = [];
                return { success: false, error: "Illegal Move" };
            }

            // --- Turn Check ---
            if (!isPlayersTurn(game) && !isPremove) {
                // Jangan spam log jika memang menunggu giliran
                return { success: false, error: "Not your turn" };
            }

            let success = false;
            let error = null;
            const maxRetries = myVars.moveRetries || 3;

            // --- EKSEKUSI ---
            for (let attempt = 1; attempt <= maxRetries; attempt++) {
                try {
                    // Panggil makeMove (hanya untuk klik/drag, tanpa validasi FEN berat)
                    await makeMove(from, to, promo, isPremove);

                    // Tunggu sebentar agar server/UI merespon (Anti-Lag)
                    // Waktu tunggu bertambah setiap retry gagal
                    const waitTime = 100 + (attempt * 50);
                    await new Promise(res => setTimeout(res, waitTime));

                    const afterFen = myFunctions.getStableFen ? myFunctions.getStableFen() : getFen(game);

                    // Validasi sukses: FEN berubah
                    if (afterFen && afterFen !== beforeFen) {
                        success = true;
                        // Log sukses hanya sekali
                        console.log(`[MOVE SUCCESS] ${from}${to} (Attempt ${attempt})`);

                        // Cleanup
                        myVars.topMoves = [];
                        if (typeof logMoveResult === 'function') {
                            logMoveResult(true, from, to, promo, beforeFen, afterFen);
                        }
                        break; // Keluar dari loop retry
                    } else {
                        console.warn(`[MOVE RETRY] ${from}${to} Attempt ${attempt}: FEN not updated.`);
                    }
                } catch (e) {
                    error = e;
                    console.error(`[MOVE ERROR] Attempt ${attempt}:`, e.message);
                }
            }

            if (success) {
                // Trigger update UI/Analisa setelah move sukses
                if (typeof myFunctions.afterBoardStateChanged === 'function') {
                    myFunctions.afterBoardStateChanged();
                }
            } else {
                console.error(`âŒ [MOVE FAILED] ${from}${to} after ${maxRetries} attempts.`);
            }

            return { success, error };
        };
        // ======================================================================
        // makeMove (Pure Execution - Lightweight)
        // ======================================================================
        async function makeMove(from, to, promotionChar, isPremove = false) {
            const game = getGame();
            if (!game) return false;

            // Cek mode eksekusi
            const isFreeMoveMode = !!myVars.useSecondDelay;
            const isPremoveExecution = isPremove || isFreeMoveMode;

            if (myVars.isSmoothDragging && !isPremoveExecution) {
                console.log("Smooth drag active, skipping instant move.");
                return false;
            }

            const finalExecutionFunction = isPremoveExecution
            ? simulateTwoClickMove // Premove selalu klik (lebih aman)
            : (myVars.moveExecutionMode === 'drag'
               ? simulateDragAndDrop
               : simulateTwoClickMove);

            // Tangani Promosi atau Move Biasa
            if (promotionChar) {
                const isCurrentPlayerTurn = isPlayersTurn(game);
                return await handlePromotion(game, from, to, promotionChar, isCurrentPlayerTurn, isPremoveExecution);
            } else {
                return await finalExecutionFunction(from, to, undefined, isPremoveExecution);
            }
        }

        // ===============================END====================================

        // ======================================================================
        // myFunctions.handleBestMove (Integrated with movePiece)
        // ======================================================================
        myFunctions.handleBestMove = async function(bestMove) {
            if (!myVars.autoRun) return;

            if (!bestMove || bestMove.length < 4) return;

            const context = myVars.analysisContext || "none";

            // 1. Visualisasi (Highlight)
            try { if(myFunctions.color) myFunctions.color(bestMove); } catch (e) {}

            // Parsing Move
            const from = bestMove.slice(0, 2);
            const to = bestMove.slice(2, 4);
            const promotion = bestMove.length > 4 ? bestMove.slice(4) : undefined;

            // 2. Mode PREMOVE
            if (context === "premove") {
                myVars.premoveMove = bestMove;
                myVars.premoveFen = myFunctions.getStableFen ? myFunctions.getStableFen() : null;
                console.log(`[Premove] Queued: ${bestMove}`);
                myVars.analysisContext = "none";
                return;
            }

            // 3. Mode AUTO MOVE
            if (context === "autoMove") {
                // Cek apakah move diizinkan oleh settingan user (misal: humanize)
                if (myFunctions.isPremoveAllowedByMode && !myFunctions.isPremoveAllowedByMode(bestMove)) {
                    console.warn(`[AutoMove] Skipped by mode config: ${bestMove}`);
                    myVars.analysisContext = "none";
                    return;
                }

                // --- INTI PERBAIKAN: Panggil movePiece, bukan clickElementByMove ---
                // Ini memastikan retry logic dan FEN check berjalan
                const result = await myFunctions.movePiece(from, to, promotion, false);

                if (result.success) {
                    // Reset state engine agar tidak berpikir ulang pada posisi lama
                    myVars.lastMoveIsPremove = false;
                    if(myFunctions.stopEngineThinking) myFunctions.stopEngineThinking();
                    if(myFunctions.setEngineState) myFunctions.setEngineState(ENGINE_STATE.READY);

                    // Dispatch Event Sukses (untuk modul lain)
                    try {
                        document.dispatchEvent(new CustomEvent("bestMoveExecuted", {
                            detail: { move: bestMove, timestamp: Date.now() }
                        }));
                    } catch(e){}
                }
            }

            // Reset Context
            myVars.analysisContext = "none";
        };

        // ===========================================================================
        // myFunctions.humanizeMoveExecution (Upgrade: Realistic Drag + Easing)
        // ===========================================================================
        myFunctions.humanizeMoveExecution = function(moveUci) {
            // Kalau AutoRun OFF â†’ jangan pasang observer
            if (!myVars.autoRun) {
                //  console.log("[guard] AutoRun OFF â†’ observer tidak dipasang.");
                return;
            }
            if (!board || !board.game || !myFunctions.simulateMouseEvents) {
                console.warn("[Humanize] Board/simulateMouseEvents tidak siap.");
                myFunctions.movePieceAnalysisAPI?.(moveUci); // fallback instan
                return;
            }

            const fromSquare = moveUci.substring(0, 2);
            const toSquare = moveUci.substring(2, 4);

            const startPos = myFunctions.getSquareCenterCoordinates?.(fromSquare);
            const endPos = myFunctions.getSquareCenterCoordinates?.(toSquare);

            if (!startPos || !endPos) {
                console.warn("[Humanize] Koordinat tidak ditemukan, fallback API.");
                myFunctions.movePieceAnalysisAPI?.(moveUci);
                return;
            }

            // 1. Configurable jitter
            const jitterMax = myVars.jitterMax || 5;
            const jitter = () => Math.random() * jitterMax * 2 - jitterMax;

            startPos.x += jitter();
            startPos.y += jitter();
            endPos.x += jitter();
            endPos.y += jitter();

            // 2. Configurable duration
            const duration = myVars.dragDurationMs || (100 + Math.random() * 200);

            // 3. Easing function (easeInOutQuad)
            const easeInOutQuad = (t) => (t < 0.5)
            ? 2 * t * t
            : -1 + (4 - 2 * t) * t;

            // 4. Simulasi drag dengan step animasi
            const steps = myVars.dragSteps || 20;
            let currentStep = 0;

            const animateDrag = () => {
                const progress = currentStep / steps;
                const eased = easeInOutQuad(progress);

                const x = startPos.x + (endPos.x - startPos.x) * eased;
                const y = startPos.y + (endPos.y - startPos.y) * eased;

                myFunctions.simulateMouseEvents("mousemove", { x, y });

                if (currentStep < steps) {
                    currentStep++;
                    setTimeout(animateDrag, duration / steps);
                } else {
                    // Drop piece
                    myFunctions.simulateMouseEvents("mouseup", endPos);
                    console.log(`[Humanize] Drag selesai: ${fromSquare} â†’ ${toSquare}, durasi ${duration.toFixed(0)}ms.`);
                }
            };

            // Mulai drag
            myFunctions.simulateMouseEvents("mousedown", startPos);
            animateDrag();
        };

        // ===============================END====================================

        // ======================================================================
        // ðŸ“ getSquareCenterClientXY (Robust Calculation)
        // ======================================================================
        function getSquareCenterClientXY(square) {
            if (!/^[a-h][1-8]$/.test(square)) return null;

            // 1. Cari elemen papan catur (wc-chess-board, chess-board, atau .board)
            const boardEl = document.querySelector('wc-chess-board') || document.querySelector('chess-board') || document.querySelector('.board');
            if (!boardEl) return null;

            // 2. Coba cari elemen kotak langsung (Best accuracy)
            // Beberapa situs menggunakan class .square-11, .square-a1, atau data-square="a1"
            const targetElement = document.querySelector(`.square-${square}`) ||
                  document.querySelector(`[data-square="${square}"]`);

            if (targetElement) {
                const rect = targetElement.getBoundingClientRect();
                // Pastikan rect valid (tidak 0x0)
                if (rect.width > 0 && rect.height > 0) {
                    return {
                        x: rect.left + rect.width / 2,
                        y: rect.top + rect.height / 2
                    };
                }
            }

            // 3. Fallback: Hitung posisi manual (Geometry Math)
            const boardRect = boardEl.getBoundingClientRect();
            const { width, height } = boardRect;

            // Deteksi orientasi papan
            const isFlipped =
                  boardEl.classList.contains('flipped') ||
                  boardEl.getAttribute('flipped') !== null ||
                  (boardEl.game && boardEl.game.getPlayingAs && boardEl.game.getPlayingAs() === 2);

            const file = square.charCodeAt(0) - 97; // 0 (a) - 7 (h)
            const rank = parseInt(square.charAt(1)) - 1; // 0 (1) - 7 (8)

            const squareWidth = width / 8;
            const squareHeight = height / 8;

            // Logic:
            // White Bottom (Normal): a1 ada di kiri bawah (x=0, y=7)
            // Black Bottom (Flipped): a1 ada di kanan atas (x=7, y=0)

            const xIndex = isFlipped ? (7 - file) : file;
            const yIndex = isFlipped ? rank : (7 - rank);

            const x = boardRect.left + (xIndex * squareWidth) + (squareWidth / 2);
            const y = boardRect.top + (yIndex * squareHeight) + (squareHeight / 2);

            return { x, y };
        }

        // ======================================================================
        // â³ Helper: Wait For FEN Change (Polling)
        // ======================================================================
        async function waitForFenChange(prevFen, timeout = 1000) {
            const start = Date.now();

            while (Date.now() - start < timeout) {
                // Gunakan getStableFen agar konsisten dengan cache
                const currentFen = myFunctions.getStableFen();

                if (currentFen && currentFen !== prevFen) {
                    return true; // Sukses berubah
                }

                // Jeda 50ms (lebih responsif daripada 100ms)
                await new Promise(r => setTimeout(r, 50));
            }
            return false; // Timeout
        }




        // ===========================================================================================================================================
        // Fungsi untuk Dispatch Pointer atau Mouse Event pada Elemen
        // ===========================================================================================================================================
        function dispatchPointerOrMouse(el, type, opts = {}, usePointer = true) {
            if (!el) return false; // Cek apakah elemen valid

            const eventInit = { bubbles: true, cancelable: true, composed: true, ...opts };
            const fallbackType = type.startsWith("pointer") ? type.replace("pointer", "mouse") : type;

            // Validasi tipe event
            const validTypes = ['pointerdown', 'pointerup', 'pointermove', 'click', 'mousedown', 'mouseup', 'mousemove'];
            if (!validTypes.includes(type)) {
                //console.warn("[dispatchPointerOrMouse] Tipe event tidak valid:", type);
                return false;
            }

            try {
                // Pilih event untuk digunakan (PointerEvent atau MouseEvent)
                if (usePointer && window.PointerEvent) {
                    // console.log(`[dispatchPointerOrMouse] Dispatching PointerEvent: ${type}`);
                    el.dispatchEvent(new PointerEvent(type, eventInit));
                } else {
                    // console.log(`[dispatchPointerOrMouse] Dispatching MouseEvent: ${fallbackType}`);
                    el.dispatchEvent(new MouseEvent(fallbackType, eventInit));
                }
                return true;
            } catch (err) {
                //console.warn("[dispatchPointerOrMouse] Gagal dispatch:", err.message);
                return false;
            }
        }
        // ===============================END====================================

        // ===========================================================================================================================================
        //
        // ===========================================================================================================================================

        // ===============================END====================================

        // ===========================================================================================================================================
        //
        // ===========================================================================================================================================
        async function simulateTwoClickMove(from, to, promotionChar, isPremove = false) {
            const randomDelay = (min = 10, max = 50) =>
            Math.floor(Math.random() * (max - min + 1)) + min;

            const getRandomClickOffset = (forceMiss = false) => {
                if (forceMiss) {
                    let offset = Math.floor(Math.random() * 51) - 30;
                    if (offset === 0) offset = Math.random() < 0.5 ? -20 : 20;
                    return offset;
                }
                return Math.floor(Math.random() * 10) - 5;
            };

            const a = getSquareCenterClientXY(from);
            const b = getSquareCenterClientXY(to);
            if (!a || !b) return false;

            const usePointer = !!window.PointerEvent;

            const aOffset = {
                x: a.x + getRandomClickOffset(true),
                y: a.y + getRandomClickOffset(true)
            };

            const bOffset = {
                x: b.x + getRandomClickOffset(),
                y: b.y + getRandomClickOffset()
            };

            const startEl = getTargetAt(a.x, a.y);
            const endEl = getTargetAt(b.x, b.y);
            if (!startEl || !endEl) return false;

            const makeEvent = (x, y, down) => ({
                clientX: x,
                clientY: y,
                pointerId: 1,
                pointerType: 'mouse',
                isPrimary: true,
                buttons: down ? 1 : 0
            });

            dispatchPointerOrMouse(startEl, usePointer ? 'pointerdown' : 'mousedown', makeEvent(aOffset.x, aOffset.y, true), usePointer);
            await sleep(randomDelay(5, 15));
            dispatchPointerOrMouse(startEl, usePointer ? 'pointerup' : 'mouseup', makeEvent(aOffset.x, aOffset.y, false), usePointer);
            startEl.dispatchEvent(new MouseEvent('click', { bubbles: true, cancelable: true, composed: true, clientX: aOffset.x, clientY: aOffset.y }));

            await sleep(randomDelay(30, 80));

            dispatchPointerOrMouse(endEl, usePointer ? 'pointerdown' : 'mousedown', makeEvent(bOffset.x, bOffset.y, true), usePointer);
            await sleep(randomDelay(5, 15));
            dispatchPointerOrMouse(endEl, usePointer ? 'pointerup' : 'mouseup', makeEvent(bOffset.x, bOffset.y, false), usePointer);
            endEl.dispatchEvent(new MouseEvent('click', { bubbles: true, cancelable: true, composed: true, clientX: bOffset.x, clientY: bOffset.y }));

            await sleep(randomDelay(70, 150));

            if (promotionChar) {
                await sleep(randomDelay(100, 200));
                const promoPiece = String(promotionChar).toLowerCase();
                const promotionSelector = `.promotion-piece.${promoPiece}`;
                const promotionEl = document.querySelector(promotionSelector);
                if (promotionEl) {
                    promotionEl.click();
                    await sleep(randomDelay(50, 100));
                } else {
                    const queenFallbackEl = document.querySelector('.promotion-piece.q');
                    if (queenFallbackEl) {
                        queenFallbackEl.click();
                        await sleep(randomDelay(50, 100));
                    }
                }
            }

            if (isPremove) {
                await sleep(randomDelay(150, 300));
                const premoveUndoButton = document.querySelector('.move-history-item .undo-premove-btn');
                if (premoveUndoButton) {
                    premoveUndoButton.click();
                    await sleep(randomDelay(50, 100));
                }
            }

            await sleep(randomDelay(100, 200));
            return true;
        }


        // ===========================================================================
        // ðŸ–±ï¸ HUMAN-LIKE DRAG & DROP (Improved)
        // ===========================================================================

        // Helper: jeda acak 0.5â€“1.5 detik
        myFunctions.getHumanPauseDelay = function() {
            const minMs = 500;
            const maxMs = 1500;
            return Math.floor(Math.random() * (maxMs - minMs + 1)) + minMs;
        };

        // Helper Bezier & Easing
        function easeInOutCubic(t) { return t < .5 ? 4 * t * t * t : (t - 1) * (2 * t - 2) * (2 * t - 2) + 1; }
        function quadraticBezier(t, p0, p1, p2) { return (1 - t) * (1 - t) * p0 + 2 * (1 - t) * t * p1 + t * t * p2; }
        function getRandomOffset(range) { return Math.random() * range - (range / 2); }


        // ===========================================================================
        // Fungsi inti: simulasi drag & drop bidak + arrow (klik kanan tahan)
        // ===========================================================================
        async function simulateDragAndDrop(from, to, isPremove = false) {
            if (!from || !to) {
                console.warn('simulateDragAndDrop: Kotak awal atau akhir tidak valid.');
                return false;
            }

            const a = getSquareCenterClientXY(from);
            const b = getSquareCenterClientXY(to);
            if (!a || !b) {
                console.warn('simulateDragAndDrop: Koordinat klien tidak ditemukan.');
                return false;
            }

            const boardEl = document.querySelector('wc-chess-board') || document.querySelector('chess-board') || document.querySelector('.board');
            if (!boardEl) {
                console.error("simulateDragAndDrop: Elemen papan catur tidak ditemukan.");
                return false;
            }

            console.log(`[MoveSim] simulateDragAndDrop from ${from} â†’ ${to} (premove=${isPremove})`);

            // --- Dispatcher (Pointer + Mouse fallback) ---
            const dispatchEvent = (el, type, x, y, buttons = 1, button = 0) => {
                const viewRef = el.ownerDocument ? el.ownerDocument.defaultView : window;
                const isRightClick = buttons === 2;

                try {
                    const ev = new PointerEvent(type, {
                        bubbles: true, cancelable: true, view: viewRef,
                        clientX: x, clientY: y,
                        pointerId: 1, pointerType: "mouse", isPrimary: true,
                        buttons: buttons, button: button,
                        pressure: buttons ? 0.5 : 0
                    });
                    el.dispatchEvent(ev);
                } catch(e) { /* ignore */ }

                // Legacy fallback
                if (type.includes('down')) {
                    el.dispatchEvent(new MouseEvent('mousedown', { bubbles: true, clientX: x, clientY: y, buttons: buttons, button: button, view: viewRef }));
                } else if (type.includes('up')) {
                    el.dispatchEvent(new MouseEvent('mouseup', { bubbles: true, clientX: x, clientY: y, buttons: 0, button: button, view: viewRef }));
                    if (!isRightClick) el.dispatchEvent(new MouseEvent('click', { bubbles: true, clientX: x, clientY: y, view: viewRef }));
                    else el.dispatchEvent(new MouseEvent('contextmenu', { bubbles: true, clientX: x, clientY: y, view: viewRef }));
                } else if (type.includes('move')) {
                    el.dispatchEvent(new MouseEvent('mousemove', { bubbles: true, clientX: x, clientY: y, buttons: buttons, view: viewRef }));
                }
            };

            // Cari elemen bidak
            let pieceEl = document.elementFromPoint(a.x, a.y);
            if (!pieceEl || pieceEl === boardEl) pieceEl = boardEl;
            const downTarget = pieceEl;

            // ===================================================================
            // STEP 1: Arrow (klik kanan tahan)
            // ===================================================================
            dispatchEvent(downTarget, 'pointermove', a.x, a.y, 0, 0);
            await sleep(Math.random() * 50 + 30);

            dispatchEvent(downTarget, 'pointerdown', a.x, a.y, 2, 2);
            await sleep(Math.random() * 50 + 40);

            dispatchEvent(boardEl, 'pointermove', b.x, b.y, 2, 0);
            await sleep(Math.random() * 50 + 60);

            dispatchEvent(boardEl, 'pointerup', b.x, b.y, 0, 2);
            await sleep(100);

            // Pause humanisasi
            const pauseTime = myFunctions.getHumanPauseDelay();
            console.log(`[Human] Jeda mikir setelah panah: ${pauseTime}ms`);
            await sleep(pauseTime);

            // ===================================================================
            // STEP 2: Drag & Drop Bidak
            // ===================================================================
            if (isPremove) {
                // Versi cepat
                dispatchEvent(downTarget, 'pointermove', a.x, a.y, 0, 0);
                dispatchEvent(downTarget, 'pointerdown', a.x, a.y, 1, 0);
                await sleep(10);
                dispatchEvent(boardEl, 'pointermove', b.x, b.y, 1, 0);
                await sleep(10);
                dispatchEvent(boardEl, 'pointerup', b.x, b.y, 0, 0);
                console.log(`[Move] Premove ${from}â†’${to} (Fast)`);
                return true;
            }

            // Smooth drag
            myVars.isSmoothDragging = true;
            try {
                const steps = Math.max(15, Math.floor(Math.random() * 10 + 20)); // 20â€“30 langkah
                const offsetStart = { x: getRandomOffset(15), y: getRandomOffset(15) };
                const offsetEnd = { x: getRandomOffset(15), y: getRandomOffset(15) };
                const aOffset = { x: a.x + offsetStart.x, y: a.y + offsetStart.y };
                const bOffset = { x: b.x + offsetEnd.x, y: b.y + offsetEnd.y };

                const midX = (aOffset.x + bOffset.x) / 2;
                const midY = (aOffset.y + bOffset.y) / 2;
                const controlPoint = { x: midX + getRandomOffset(50), y: midY + getRandomOffset(50) };

                // Klik tahan
                dispatchEvent(downTarget, 'pointermove', aOffset.x, aOffset.y, 0, 0);
                await sleep(Math.random() * 50 + 20);
                dispatchEvent(downTarget, 'pointerdown', aOffset.x, aOffset.y, 1, 0);
                await sleep(100);

                // Drag loop
                for (let i = 1; i <= steps; i++) {
                    const progress = i / steps;
                    const eased = easeInOutCubic(progress);
                    const currX = quadraticBezier(eased, aOffset.x, controlPoint.x, bOffset.x);
                    const currY = quadraticBezier(eased, aOffset.y, controlPoint.y, bOffset.y);
                    dispatchEvent(boardEl, 'pointermove', currX, currY, 1, 0);
                    await sleep(Math.random() * 10 + 5);
                }

                // Drop
                dispatchEvent(boardEl, 'pointermove', bOffset.x, bOffset.y, 1, 0);
                await sleep(Math.random() * 50 + 50);
                dispatchEvent(boardEl, 'pointerup', bOffset.x, bOffset.y, 0, 0);
                await sleep(100);

                console.log(`[Move] AutoMove ${from}â†’${to} (Smooth)`);
                return true;
            } catch (e) {
                console.error("Error drag simulation:", e);
                return false;
            } finally {
                myVars.isSmoothDragging = false;
            }
        }


        // ===========================================================================================================================================
        //
        // ===========================================================================================================================================
        function logMoveResult(success, from, to, promo, beforeFen, afterFen) {
            const moveStr = `${from}${to}${promo || ''}`;
            const timestamp = new Date().toISOString();
            if (success) {
                console.log(`[${timestamp}] [AutoMove] Langkah berhasil: ${moveStr}`);
                myFunctions.updateAutoRunStatus(ENGINE_STATUS1.WAITING, 'Menunggu giliran lawan');
            } else {
                console.warn(`[${timestamp}] [AutoMove ERROR] Langkah gagal: ${moveStr}.`, `Before FEN: ${beforeFen}, After FEN: ${afterFen}`);
            }
        }
        // ===============================END====================================

        // ===========================================================================================================================================
        //
        // ===========================================================================================================================================
        function isLegalMove(game, from, to, promo) {
            const legalMoves = game.getLegalMoves();
            return legalMoves.some(m => m.from === from && m.to === to && (!promo || m.promotion === promo));
        }
        // ===============================END====================================

        // ===========================================================================================================================================
        //
        // ===========================================================================================================================================
        function logMakeMove(msg) {
            console.warn(`[MakeMove] ${msg}`);
            return false;
        }
        // ===============================END====================================

        // ===========================================================================================================================================
        // handlePromotion (Logika penanganan bidak promosi)
        // ===========================================================================================================================================
        async function handlePromotion(game, from, to, promo, isCurrentPlayerTurn, isPremoveExecution) {
            // 1. Validasi Dasar
            if (!promo) return logMakeMove("Promosi dibatalkan: karakter promosi hilang.");

            // 2. Jika BUKAN Premove (AutoMove biasa atau Manual Move Engine)
            if (!isPremoveExecution) {
                if (!isCurrentPlayerTurn) return logMakeMove("Promosi dibatalkan: bukan giliran.");

                // Validasi legal move promosi
                const legalMove = game.getLegalMoves().find(m =>
                                                            m.from === from && m.to === to && m.promotion === promo
                                                           );

                if (legalMove) {
                    // Asumsi game.move() adalah metode di objek game catur situs
                    game.move({
                        ...legalMove,
                        animate: true,
                        userGenerated: true
                    });
                    console.log(`[MakeMove] Promosi berhasil: ${from}${to}${promo}`);
                    return true;
                } else {
                    return logMakeMove(`Promosi tidak legal atau tidak ditemukan: ${from}${to}${promo}`);
                }
            }

            // 3. Jika Premove Execution
            // Untuk Premove, kita paksa menggunakan Two-Click karena lebih stabil untuk memicu jendela promosi dan klik pilihan bidak.
            const success = await simulateTwoClickMove(from, to, promo, isPremoveExecution);
            if (!success) return logMakeMove("Simulasi promosi premove gagal.");
            console.log(`[MakeMove] Simulasi Promosi Premove berhasil: ${from}${to}${promo}`);
            return true;
        }
        // ===============================END====================================

        function getGame() {
            const boardEl = qs('wc-chess-board') || qs('chess-board') || qs('.board');
            if (boardEl?.game) return boardEl.game;

            if (typeof Chess !== 'undefined' && myFunctions.getAccurateFen) {
                const fen = myFunctions.getAccurateFen();
                if (fen) {
                    try {
                        const game = new Chess(fen);
                        Object.assign(game, {
                            getFEN: () => game.fen(),
                            getPlayingAs: () => {
                                const el = qs('.user-username-component.white') || qs('.user-username-component.black');
                                return el?.classList.contains('white') ? 'w' : 'b';
                            },
                            getTurn: () => game.turn(),
                            getLegalMoves: () => game.moves({ verbose: true })
                        });
                        console.warn("[getGame] Fallback aktif: Chess.js dari FEN.");
                        return game;
                    } catch (error) {
                        console.error("[getGame] Error saat membuat Chess.js:", error.message);
                        return new Chess(); // fallback ke posisi awal
                    }
                }
            }
            return null;
        }
        // ===============================END====================================

        function getFen(game) {
            try {
                const fen = myFunctions.getAccurateFen?.();
                if (typeof fen === 'string' && fen.trim()) return fen;

                const gameFen = game?.getFEN?.();
                if (typeof gameFen === 'string' && gameFen.trim()) return gameFen;

                return null;
            } catch (err) {
                console.warn("[getFen] Gagal ambil FEN:", err.message);
                return null;
            }
        }
        // ===============================END====================================

        // ===========================================================================================================================================
        //
        // ===========================================================================================================================================
        function getTargetAt(x, y) {
            if (typeof x !== "number" || typeof y !== "number" || isNaN(x) || isNaN(y)) {
                console.warn("[getTargetAt] Koordinat tidak valid.");
                return qs("chess-board") || document.body;
            }
            return document.elementFromPoint(x, y) || qs("chess-board") || document.body;
        }
        // ===============================END====================================

        // ===========================================================================================================================================
        //
        // ===========================================================================================================================================
        function getRandomInt(min, max) {
            min = Math.ceil(min);
            max = Math.floor(max);
            return Math.floor(Math.random() * (max - min + 1)) + min;
        }
        // ===============================END====================================

        // ===========================================================================================================================================
        // Fungsi untuk Memeriksa Apakah Giliran Pemain
        // ===========================================================================================================================================
        function isPlayersTurn(game) {
            if (!game || typeof game.getPlayingAs !== "function" || typeof game.getTurn !== "function") {
                console.warn("[Turn Check] Game tidak valid atau fungsi tidak tersedia.");
                return false;
            }

            try {
                const turn = String(game.getTurn()).trim().toLowerCase();
                const player = String(game.getPlayingAs()).trim().toLowerCase();
                const isTurn = turn === player;

                console.log(`[Turn Check] Giliran: ${turn.toUpperCase()}, Pemain: ${player.toUpperCase()}, Status: ${isTurn ? "YA" : "BUKAN"}`);

                return isTurn;
            } catch (err) {
                console.warn("[Turn Check] Error saat memeriksa giliran:", err.message);
                return false;
            }
        }
        // ===============================END====================================

        // ===========================================================================================================================================
        //
        // ===========================================================================================================================================
        function getPlayingAs() {
            const game = getGame();
            if (game && typeof game.getPlayingAs === 'function') {
                return game.getPlayingAs();
            }
            return null;
        }

        // ===============================END====================================

        // ===========================================================================================================================================
        //
        // ===========================================================================================================================================
        function getTurn() {
            const game = getGame();
            if (game && typeof game.getTurn === 'function') {
                return game.getTurn();
            }
            return null;
        }

        // ===============================END====================================

        // ===========================================================================================================================================
        //
        // ===========================================================================================================================================
        function isValidGameAndArgs(game, from, to) {
            return game && typeof from === "string" && from.length === 2 && typeof to === "string" && to.length === 2;
        }
        // ===============================END====================================

        // ===========================================================================================================================================
        //
        // ===========================================================================================================================================
        function isValidUci(from, to, promo) {
            const squareRegex = /^[a-h][1-8]$/;
            const promoRegex = /^[qrbn]?$/;
            return squareRegex.test(from) && squareRegex.test(to) && promoRegex.test(promo || '');
        }
        // ===============================END====================================

        // ===========================================================================================================================================
        //
        // ===========================================================================================================================================
        function normalizePromotion(promotionChar) {
            return promotionChar && /^[qrbn]$/i.test(promotionChar) ? promotionChar.toLowerCase() : undefined;
        }
        // ===============================END====================================

        // ===========================================================================================================================================
        //
        // ===========================================================================================================================================
        function logAndReturn(msg, fen = null) {
            const timestamp = new Date().toISOString();
            console.error(`[${timestamp}] [AutoMove ERROR] ${msg}`);
            return { success: false, beforeFen: fen, afterFen: fen, error: msg };
        }
        // ===============================END====================================

        // ===========================================================================================================================================
        //
        // ===========================================================================================================================================
        function drawArrow({ f, t, color = "blue", o = 1, remove = false } = {}) {
            const game = getBoard();
            if (!game) {
                console.warn("drawArrow: Papan tidak ditemukan.");
                return;
            }

            if (remove) {
                game.markings.removeAll();
                return;
            }

            game.markings.addOne({
                data: { keyPressed: "none", from: f, to: t, opacity: o },
                type: "arrow"
            });

            setTimeout(() => {
                const arrowId = `arrow-${f}${t}`;
                const arrowEl = document.getElementById(arrowId) || qs(`#${arrowId}`);
                if (arrowEl) {
                    arrowEl.style.fill = color;
                } else {
                    console.warn(`drawArrow: Panah ${arrowId} tidak ditemukan.`);
                }
            }, 50);
        }

        // ===============================END====================================

        // ===========================================================================================================================================
        //                                                      âš™ï¸ LOGIKA UPDATE lampu 7 led âš™ï¸
        // ===========================================================================================================================================
        // ===========================================================================
        // 1. ENGINE STATUS ENUM
        // ===========================================================================
        const ENGINE_STATUS1 = {
            INIT:     'INIT',
            STOPPED:  'STOPPED',
            LOADING:  'LOADING',
            WAITING:  'WAITING',
            IDLE:     'IDLE',
            DELAY:    'DELAY',
            THINKING: 'THINKING',
            ERROR:    'ERROR',
            READY:    'READY',
            RUNNING:  'RUNNING',
            OFF:      'OFF',
            ON:      'ON'
        };

        // ===========================================================================
        // 2. ENGINE STATUS GUARD (DIPERBAIKI + EVENT EMITTER)
        // ===========================================================================
        myFunctions.setEngineStatus = function (nextStatus, reason = '') {
            const current = (myVars.engineStatus || ENGINE_STATUS1.READY).toUpperCase();
            const next = (nextStatus || ENGINE_STATUS1.READY).toUpperCase();

            // ðŸ”’ Hanya lock THINKING, bukan RUNNING
            const lockedStates = [
                ENGINE_STATUS1.THINKING
            ];

            const unlockReasons = [
                'ENGINE_DONE',
                'BESTMOVE',
                'STOP',
                'GAME_OVER',
                'RELOAD',
                'DELAY'
            ];

            // ðŸ”’ GUARD LOGIC
            if (lockedStates.includes(current)) {
                if (!unlockReasons.includes(reason)) {
                    if (current === next) return true; // status sama â†’ abaikan
                    console.warn(`[STATUS-GUARD] BLOCKED ${current} â†’ ${next} (reason=${reason || 'NONE'})`);
                    return false;
                }
            }

            // âœ… Update status di memory
            myVars.engineStatus = next;
            myVars.isThinking = (next === ENGINE_STATUS1.THINKING);

            //console.log(`[STATUS-GUARD] ${current} â†’ ${next} (reason=${reason || 'NONE'})`);

            // ðŸ’¡ Update LED
            if (typeof myFunctions.updateLEDBar === 'function') {
                myFunctions.updateLEDBar();
            } else {
                myFunctions.updateAutoRunStatus?.(next);
            }

            // ðŸ“¢ Emit event ke listener eksternal
            if (typeof myFunctions.onStatusChange === 'function') {
                try {
                    myFunctions.onStatusChange(next, reason);
                } catch (err) {
                    //console.error('[STATUS-GUARD] onStatusChange error', err);
                }
            }

            return true;
        };

        // ===========================================================================
        // 3. UPDATE LED VISUAL
        // ===========================================================================
        myFunctions.updateLEDBar = function () {
            const status = (myVars.engineStatus || 'IDLE').toUpperCase();
            const items = document.querySelectorAll('.engine-led-item');

            items.forEach(item => {
                const itemState = item.getAttribute('data-state');
                if (itemState === status) {
                    item.classList.add('active');
                } else {
                    item.classList.remove('active');
                }
            });
        };

        // ===========================================================================
        // 4. UPDATE AUTO RUN (Wrapper untuk status & evaluasi bar)
        // ===========================================================================
        myFunctions.updateAutoRunStatus = function (state, reason = '') {
            const updated = myFunctions.setEngineStatus(state, reason);
            if (!updated) return;

            myFunctions.startInactivityWatchdog();

            if (myVars.currentRawScore !== undefined && typeof myFunctions.updateEvalBar === 'function') {
                myFunctions.updateEvalBar(
                    myVars.currentRawScore,
                    myVars.currentMateValue,
                    myVars.currentDepth
                );
            }
        };
        // ===========================================================================================================================================
        //
        // ===========================================================================================================================================
        myFunctions.spinner = function() {
            const led = document.getElementById('engine-status-led');
            if (!led) return; // Keluar jika elemen tidak ada

            // 1. Reset class (Gunakan myVars.isThinking)
            led.classList.remove('active', 'running', 'error', 'ready');

            // 2. Cek status "Thinking" dari myVars
            if (myVars.isThinking) {
                led.classList.add('active');
            }

            // 3. Update berdasarkan status engine resmi di script
            switch (myVars.engineStatus) {
                case 'RUNNING':
                    led.classList.add('running');
                    break;
                case 'READY':
                    led.classList.add('ready');
                    break;
                case 'ERROR':
                    led.classList.add('error');
                    break;
                case 'THINKING':
                    led.classList.add('active');
                    break;
            }
        };
        // ===============================END====================================
        // ===========================================================================================================================================
        //                                                      âš™ï¸ logika elo skill dan dapth âš™ï¸
        // ===========================================================================================================================================
        // ======================================================================
        // Update Opponent ELO UI
        // ======================================================================
        myFunctions.updateOpponentEloUI = function(rating) {
            const eloOpponentLive = document.getElementById('eloOpponentLive');
            if (eloOpponentLive) {
                eloOpponentLive.textContent = rating;
            }
        };
        // ===============================END====================================


        // ======================================================================
        // Sinkronisasi ELO Mesin dengan Lawan (Final Version FLEKSIBEL & CLEAN)
        // ======================================================================
        // ===========================================================================================================================================
        // FUNGSI: Sinkronisasi ELO Mesin dengan Lawan (Final Version FLEKSIBEL & CLEAN)
        // ===========================================================================================================================================
        myFunctions.syncEloWithOpponent = function() {
            // 1. Dapatkan Rating Lawan
            const opponentRating = extractOpponentRating();

            // Pastikan rating valid dan dalam rentang (300-3190)
            if (opponentRating !== null && opponentRating >= 300 && opponentRating <= 3190) {

                if (myVars.eloSyncInterval) {
                    clearInterval(myVars.eloSyncInterval);
                    console.log("[Auto-Sync] ELO lawan berhasil ditemukan. Interval ELO dimatikan.");
                }

                const now = Date.now();
                const ratingChanged = opponentRating !== myVars.opponentRating;
                const logExpired = !myVars.lastLogTime || (now - myVars.lastLogTime > 5000);

                if (ratingChanged || logExpired) {
                    // Perbarui variabel internal skrip
                    myVars.opponentRating = opponentRating;
                    myVars.lastLogTime = now;

                    console.log("[Auto-Sync] Rating lawan terdeteksi:", opponentRating);

                    // ðŸŽ¯ PEMBARUAN ELO LAWAN (Update display 'eloOpponentLive')
                    myFunctions.updateOpponentEloUI(opponentRating);

                    // ðŸŸ¢ PANGGIL FUNGSI TERPUSAT BARU UNTUK SEMUA PEMBARUAN UI ELO/DEPTH
                    myFunctions.updateEloUI(opponentRating);

                    // Logika pengaturan mode
                    const eloModeSelect = document.getElementById('eloModeSelect');
                    if (eloModeSelect) eloModeSelect.value = 'auto';

                    console.log(`[Auto-Sync] ELO mesin disinkronkan ke: ${opponentRating}`);
                }
            } else {
                // console.log("[Auto-Sync] Rating lawan tidak ditemukan / di luar rentang valid.");
                myFunctions.updateOpponentEloUI('-');
            }
        };
        // ===============================END====================================


        // ======================================================================
        // Konversi ELO â†’ Depth + Skill
        // ======================================================================
        myFunctions.calculateDepthAndSkillFromElo = function(elo) {
            let depth, skill;
            if (elo < 100) { depth = 1; skill = 0; }
            else if (elo < 1200) { depth = 2; skill = 3; }
            else if (elo < 1600) { depth = 3; skill = 7; }
            else if (elo < 2000) { depth = 4; skill = 12; }
            else if (elo < 2400) { depth = 5; skill = 16; }
            else if (elo < 2800) { depth = 12; skill = 19; }
            else { depth = 20; skill = 20; }
            return { depth, skill };
        };
        // ===============================END====================================


        // ======================================================================
        // Konversi Skill Level â†’ Error Probability
        // ======================================================================
        myFunctions.calculateSkillSettings = function(skillLevel) {
            if (skillLevel <= -10) return { errorProbability: 100, maxError: 500 };
            else if (skillLevel < 0) return { errorProbability: 50, maxError: 200 };
            else if (skillLevel < 10) return { errorProbability: 20, maxError: 50 };
            else if (skillLevel < 20) return { errorProbability: 5, maxError: 10 };
            else return { errorProbability: 0, maxError: 0 };
        };
        // ===============================END====================================


        // ======================================================================
        // Set Engine Level (Final, Anti Freeze, Anti NaN)
        // ======================================================================
        myFunctions.setEngineLevel = debounce(function (skillLevel) {
            if (!engine.controller) return;
            if (typeof skillLevel !== 'number' || isNaN(skillLevel)) {
                console.warn("[Engine] Skill Level invalid:", skillLevel);
                return;
            }

            const level = Math.max(0, Math.min(20, Math.round(skillLevel)));
            if (level === lastAppliedLevel) return;

            try {
                engine.controller.setOption("Skill Level", level);
                lastAppliedLevel = level;

                console.log(`[Engine] Skill Level diset ke: ${level}`);

                const skillIndicator = document.getElementById('skillLevelIndicator');
                if (skillIndicator) {
                    skillIndicator.textContent = `Skill Level: ${level}`;
                    skillIndicator.style.color = '#4CAF50';
                }
            } catch (e) {
                console.error("Gagal set engine level:", e);
            }
        }, 250);
        // ===============================END====================================


        // ======================================================================
        // Set Engine Strength (Final, FIX invalid value bug)
        // ======================================================================
        myFunctions.setEngineStrength = function(elo) {
            if (typeof elo !== 'number' || isNaN(elo)) {
                console.warn("[Engine] ELO invalid:", elo);
                return;
            }

            if (typeof myFunctions.setEngineElo === 'function') {
                // âœ… panggil dengan benar
                myFunctions.setEngineElo(elo, { silent: true });
            }

            let calculatedSkill = Math.round((elo - 600) / 100);
            if (isNaN(calculatedSkill)) calculatedSkill = 10;
            calculatedSkill = Math.max(0, Math.min(20, calculatedSkill));

            if (typeof myFunctions.setEngineLevel === 'function') {
                myFunctions.setEngineLevel(calculatedSkill);
            }
        };
        // ===============================END====================================

        // ======================================================================
        // Set Engine ELO (Safe, Flexible, Modular)
        // ======================================================================
        myFunctions.setEngineElo = function (
        elo,
         {
            silent = false,
            skipDepthAdjustment = false,
            skillLevel = 20
        } = {}
        ) {
            if (!engine?.engine) return false;

            // Validasi ELO
            const value = parseInt(elo, 10);
            if (!Number.isFinite(value) || value < 100 || value > 3190) {
                if (!silent) console.warn('[ELO] invalid value:', elo);
                return false;
            }

            try {
                engine.controller.setStrength = function (elo, skill) {
                    this.setOption("UCI_LimitStrength", "true");
                    if (elo != null) this.setOption("UCI_Elo", elo);
                    if (skill != null) this.setOption("Skill Level", skill);
                };

                // Hitung depth berdasarkan ELO
                const maxDepth = myFunctions.calculateDepthFromElo
                ? myFunctions.calculateDepthFromElo(value)
                : 22;
                myVars.maxDepthForElo = maxDepth;

                // Sinkronisasi UI slider & note
                const depthSlider = document.getElementById('custom-depth-slider');
                const depthDisplay = document.getElementById('depthValue');
                const depthTextContainer = document.getElementById('depthText');

                if (depthSlider) {
                    depthSlider.max = maxDepth;

                    if (!skipDepthAdjustment && parseInt(depthSlider.value, 10) > maxDepth) {
                        myFunctions.updateDepthUI(maxDepth);
                        myVars.customDepth = maxDepth;
                        if (depthDisplay) depthDisplay.textContent = maxDepth;
                    }

                    let depthNote = document.getElementById('depthNote');
                    if (!depthNote && depthTextContainer) {
                        depthNote = document.createElement('span');
                        depthNote.id = 'depthNote';
                        depthNote.style.cssText = 'font-size: 12px; color: #666; margin-left: 5px;';
                        depthTextContainer.appendChild(depthNote);
                    }

                    if (depthNote) {
                        const newText = `[ Depth Limit ${maxDepth} â†’ ELO ${value} ]`;
                        if (depthNote.textContent !== newText) {
                            depthNote.textContent = newText;
                        }
                    }
                }

                if (!silent) {
                    console.log(`[ELO] Engine set to ${value}, Skill=${skillLevel}, MaxDepth=${maxDepth}`);
                }
                return true;
            } catch (e) {
                console.warn('[ELO] set failed', e);
                return false;
            }
        };
        // ===============================END====================================


        // ======================================================================
        // Update Depth UI (Safe Sync)
        // ======================================================================
        myFunctions.updateDepthUI = function(newDepth) {
            myVars.customDepth = newDepth;
            GM_setValue('customDepth', newDepth);

            const depthSlider = document.getElementById('custom-depth-slider');
            const depthInput = document.getElementById('custom-depth-manual');
            const depthDisplay = document.getElementById('depthValue');

            if (depthSlider) {
                depthSlider.value = newDepth;
                depthSlider.dispatchEvent(new Event('input', { bubbles: true }));
            }
            if (depthInput) depthInput.value = newDepth;
            if (depthDisplay) depthDisplay.textContent = newDepth;

            if (typeof myFunctions.setCustomDepth === 'function') {
                myFunctions.setCustomDepth(newDepth);
            } else if (typeof myFunctions.updateDepth === 'function') {
                myFunctions.updateDepth(newDepth);
            }
        };
        // ===============================END====================================


        // ======================================================================
        // Update ELO UI (Safe, Validated, Centralized)
        // ======================================================================
        myFunctions.updateEloUI = function(newElo) {
            const value = parseInt(newElo, 10);
            if (isNaN(value) || value < 300 || value > 3190) {
                console.warn("[UI Update] Invalid ELO value:", newElo);
                return false;
            }

            // 1. Simpan nilai ELO baru secara global
            myVars.eloRating = value;
            GM_setValue('eloRating', value);

            // 2. Ambil elemen UI
            const eloSlider = document.getElementById('elo-rating-slider');
            const eloValueDisplay = document.getElementById('eloValueDisplay');
            const eloInput = document.getElementById('eloManualInput');

            // 3. Perbarui elemen UI ELO
            if (eloSlider) {
                eloSlider.value = value;
                eloSlider.dispatchEvent(new Event('input', { bubbles: true }));
            }
            if (eloValueDisplay) eloValueDisplay.textContent = value;
            if (eloInput) eloInput.value = value;

            // 4. Terapkan ke Engine
            myFunctions.setEngineElo(value);

            // 5. Sinkronkan Depth secara otomatis
            const newDepth = myFunctions.calculateDepthFromElo(value);
            myFunctions.updateDepthUI(newDepth);

            console.log(`[UI Update] ELO terpusat diperbarui ke: ${value}`);
            return true;
        };
        // ===============================END====================================

        // ===========================================================================
        // ENUM: Status Giliran & Status Engine
        // ===========================================================================
        const TURN_STATE = {
            ME: 'me',
            OPPONENT: 'opponent'
        };

        // ===========================================================================
        // Helper: Update LED Engine
        // ===========================================================================
        function setEngineLed(activityLed, state) {
            if (!activityLed) return;

            if (state === ENGINE_STATE.THINKING) {
                activityLed.classList.add('active');
                activityLed.style.boxShadow = "0 0 10px #ffc107";
                activityLed.title = 'ðŸ¤– Engine Thinking...';
            } else {
                activityLed.classList.remove('active');
                activityLed.style.boxShadow = "none";
                activityLed.title = 'Idle';
            }
        }

        // ===========================================================================
        // myFunctions.updateTurnStatus (FINAL: Giliran + Status Engine)
        // ===========================================================================
        myFunctions.updateTurnStatus = function() {
            // Ambil elemen dengan fallback ID
            const activityLed = document.getElementById('engine-status-led') || document.getElementById('engineStatusLed');
            const myTurnLed = document.getElementById('GILIRAN-SAYA');
            const opponentTurnLed = document.getElementById('GILIRAN-LAWAN');

            if (!myTurnLed || !opponentTurnLed || !activityLed) return;

            // Status giliran
            const isMyTurn = myVars.currentTurn === TURN_STATE.ME;
            const isOpponentTurn = myVars.currentTurn === TURN_STATE.OPPONENT;

            // Status engine
            const engineThinking = Boolean(myVars.isThinking);
            const engineState = engineThinking ? ENGINE_STATE.THINKING : ENGINE_STATE.IDLE;

            // 1. Update Status Giliran
            myTurnLed.classList.toggle('my-turn-active', isMyTurn);
            opponentTurnLed.classList.toggle('opponent-turn-active', isOpponentTurn);

            // 2. Update Status LED Engine
            setEngineLed(activityLed, engineState);
        };

        // ===========================================================================
        // myFunctions.debugTurnState (Monitoring & Logging)
        // ===========================================================================
        myFunctions.debugTurnState = function() {
            if (!board) return "Board not available";

            const currentGameTurn = board.game.getTurn();
            const playingAs = board.game.getPlayingAs();
            const isPlayerTurn = currentGameTurn === playingAs;

            return {
                timestamp: new Date().toISOString(),
                currentGameTurn,
                playingAs,
                isPlayerTurn,
                myTurn: myVars.currentTurn,
                canGo: myVars.canGo,
                isThinking: myVars.isThinking,
                autoRun: myVars.autoRun,
                engineRunning: myVars.engineRunning
            };
        };

        // ===============================END====================================

        // ===========================================================================================================================================
        //
        // ===========================================================================================================================================
        myFunctions.updateEngineStatusText = (text) => {
            const statusElement = document.getElementById('engineStatusText');
            if (statusElement) {
                statusElement.textContent = text;
            }
            console.log(`[STATUS] ${text}`);
        };
        // ===============================END====================================

        // ===========================================================================================================================================
        //                                           === OPENING BOOK MODULE (FULL & STABLE) ===
        // ===========================================================================================================================================
        // ===========================================================================
        // update buku
        // ===========================================================================
        myFunctions.setLoadStatus = function(statusType, count = 0) {
            const statusElement = $('#openingBookLoadStatus');
            if (statusElement.length === 0) return; // Pastikan elemen ada

            switch (statusType) {
                case 'loading':
                    statusElement.text('Opening book not loaded. Loading... ðŸ”„');
                    statusElement.css('color', '#ffcc00'); // Kuning untuk loading
                    break;
                case 'success':
                    statusElement.text(`âœ… Book Loaded: ${count} positions`);
                    statusElement.css('color', '#4CAF50'); // Hijau untuk sukses
                    break;
                case 'failure':
                    statusElement.text('âŒ Failed to load opening book from all sources.');
                    statusElement.css('color', '#F44336'); // Merah untuk gagal
                    break;
            }
        };
        // ===============================END====================================
        // ===========================================================================
        // ðŸ§  STATE (SINGLE SOURCE OF TRUTH)
        // ===========================================================================
        // ======================= Opening Book Management =======================

        // ==============================================================================
        // âš¡ FAST OFFLINE OPENING BOOK (Fixed & Optimized)
        // ==============================================================================

        // Pastikan variabel global terdefinisi
        if (typeof myVars === 'undefined') window.myVars = {};
        if (typeof myFunctions === 'undefined') window.myFunctions = {};

        // Konfigurasi Awal
        myVars.useOpeningBook = true;
        myVars.lastMoveFromBook = false;
        myVars.currentOpeningName = "";
        myVars.selectedOpeningRepertoire = "mixed"; // Default repertoire

        // 1. DATABASE LANGKAH (Format UCI: e2e4, g8f6)
        // Key: FEN String (hanya layout + giliran)
        myVars.offlineBook = {
            // START POS (White to move)
            "rnbqkbnr/pppppppp/8/8/8/8/PPPPPPPP/RNBQKBNR w": [
                "e2e4", "e2e4", "e2e4", // Bobot lebih besar ke e4
                "d2d4", "d2d4",
                "c2c4",
                "g1f3",
                "b2b3"
            ],
            // Respon Hitam terhadap e4
            "rnbqkbnr/pppppppp/8/8/4P3/8/PPPP1PPP/RNBQKBNR b": [
                "c7c5", "e7e5", "e7e6", "c7c6", "d7d6", "g8f6"
            ],
            // Respon Hitam terhadap d4
            "rnbqkbnr/pppppppp/8/8/3P4/8/PPP1PPPP/RNBQKBNR b": [
                "g8f6", "d7d5", "f7f5", "e7e6", "c7c5"
            ],
            // Respon Hitam terhadap c4 (English)
            "rnbqkbnr/pppppppp/8/8/2P5/8/PP1PPPPP/RNBQKBNR b": [
                "e7e5", "c7c5", "g8f6", "e7e6"
            ],
            // Respon Hitam terhadap Nf3 (Reti)
            "rnbqkbnr/pppppppp/8/8/8/5N2/PPPPPPPP/RNBQKB1R b": [
                "d7d5", "g8f6", "c7c5", "g7g6"
            ]
        };

        // 2. DATA NAMA & ECO
        myVars.openingNames = {
            "e2e4": "King's Pawn Opening", "d2d4": "Queen's Pawn Opening", "c2c4": "English Opening", "g1f3": "RÃ©ti Opening", "b2b3": "Nimzo-Larsen Attack",
            "c7c5": "Sicilian Defense", "e7e5": "Open Game", "e7e6": "French Defense", "c7c6": "Caro-Kann Defense", "d7d6": "Pirc Defense",
            "d7d5": "Queen's Pawn Game", "g8f6": "Indian Defense", "f7f5": "Dutch Defense", "g7g6": "Modern Defense"
        };

        myVars.openingEcoMap = {
            "e2e4": "B00", "d2d4": "D00", "c2c4": "A10", "g1f3": "A04", "b2b3": "A01",
            "c7c5": "B20", "e7e5": "C20", "e7e6": "C00", "c7c6": "B10",
            "d7d5": "D00", "g8f6": "A45", "f7f5": "A80"
        };

        // 3. REPERTOIRE DEFINITIONS (Wajib Format UCI: c2c4, bukan c4)
        myVars.openingRepertoires = {
            kings_pawn: ["e2e4", "b1c3", "f2f4"], // e4, Vienna, King's Gambit
            queens_pawn: ["d2d4", "c2c4", "g1f3"], // d4, c4, Nf3 transpositions
            english: ["c2c4", "g2g3", "g1f3"], // English & Reti
            flank: ["b2b3", "g2g3", "b1c3", "f2f4"] // Larsen, Benko, etc
        };

        // --- Normalisasi FEN (Hanya ambil posisi bidak + giliran) ---
        function normalizeFen(fen) {
            if (!fen) return "";
            return fen.split(" ").slice(0, 2).join(" ");
        }

        // --- Fetch Dummy (Agar kompatibel dengan sistem lama) ---
        myFunctions.fetchOpeningBook = async function() {
            console.log("âš¡ Offline Opening Book: READY");
            myFunctions.updateOpeningBookStatus();
            return true;
        };

        // --- Update Status UI Opening Book ---
        myFunctions.updateOpeningBookStatus = function() {
            const el = document.getElementById('openingBookLoadStatus');
            if (el) {
                el.textContent = "âš¡ Fast Book: READY";
                el.style.color = "#4CAF50";
                el.style.fontWeight = "bold";
            }
        };

        // --- CORE LOGIC: Get Move ---
        myFunctions.getOpeningMove = function(fen) {
            if (!myVars.useOpeningBook) return null;

            const normalizedFen = normalizeFen(fen);
            const availableMoves = myVars.offlineBook[normalizedFen];

            // Jika tidak ada langkah di buku untuk posisi ini
            if (!availableMoves || availableMoves.length === 0) {
                myVars.lastMoveFromBook = false;
                return null;
            }

            // Tentukan repertoire
            const selectedRep = myVars.selectedOpeningRepertoire || "mixed";

            // Filter Moves
            let filteredMoves = availableMoves;
            if (selectedRep !== "mixed") {
                const repMoves = myVars.openingRepertoires[selectedRep] || [];
                // Cek apakah ada langkah di buku yang cocok dengan repertoire
                const matches = availableMoves.filter(m => repMoves.includes(m));
                if (matches.length > 0) {
                    filteredMoves = matches;
                }
                // Jika repertoire yang diminta tidak tersedia di posisi ini, fallback ke semua move
            }

            // Pilih langkah acak
            const randomIndex = Math.floor(Math.random() * filteredMoves.length);
            const selectedMove = filteredMoves[randomIndex];

            // Ambil Info Nama & ECO
            const name = myVars.openingNames[selectedMove] || "Book Move";
            const ecoCode = myVars.openingEcoMap[selectedMove] || "";

            console.log(`ðŸ“˜ Book Move: ${name} (${selectedMove}) [Rep: ${selectedRep}]`);

            myVars.lastMoveFromBook = true;
            myVars.currentOpeningName = name;

            // Update UI
            myFunctions.updateOpeningDisplay({ name, move: selectedMove, eco: ecoCode });

            return selectedMove;
        };

        // --- Update UI Nama Opening ---
        myFunctions.updateOpeningDisplay = function(info) {
            const currentDisplay = document.getElementById('currentOpeningDisplay');
            const ecoDisplay = document.getElementById('openingDisplayECO');

            if (!currentDisplay) return;

            if (info && info.name) {
                currentDisplay.textContent = info.name;
                currentDisplay.style.color = "#1E90FF"; // Deep Sky Blue
                if (ecoDisplay) {
                    ecoDisplay.textContent = info.eco ? `ECO: ${info.eco}` : "";
                }
            } else {
                // Jangan reset teks jika sedang berpikir, biarkan user melihat opening terakhir
                if (!myVars.lastMoveFromBook && info === null) {
                    // Opsional: Reset jika game baru dimulai
                }
            }
        };

        // --- Reset saat Game Baru ---
        myFunctions.resetOpeningStatus = function() {
            myVars.lastMoveFromBook = false;
            myVars.currentOpeningName = "";
            const currentDisplay = document.getElementById('currentOpeningDisplay');
            const ecoDisplay = document.getElementById('openingDisplayECO');

            if (currentDisplay) currentDisplay.textContent = "Game Start";
            if (ecoDisplay) ecoDisplay.textContent = "";
        };

        // --- Update Dropdown Repertoire ---
        myFunctions.updateRepertoireDropdown = function () {
            const dropdown = document.getElementById('openingRepertoire');
            const reps = myVars.openingRepertoires;
            if (!dropdown || !reps) return;

            // Helper untuk buat HTML option
            const buildOption = (value, label) => `<option value="${value}">${label}</option>`;

            // Hitung jumlah move (sekedar estimasi visual)
            const counts = {
                e4: reps.kings_pawn.length,
                d4: reps.queens_pawn.length,
                english: reps.english.length,
                flank: reps.flank.length
            };

            let html = '';
            html += buildOption("mixed", "Mixed / General");
            html += buildOption("kings_pawn", `King's Pawn (1.e4)`);
            html += buildOption("queens_pawn", `Queen's Pawn (1.d4)`);
            html += buildOption("english", `English (1.c4/Nf3)`);
            html += buildOption("flank", `Flank Openings`);

            dropdown.innerHTML = html;

            // Restore pilihan terakhir user
            if (myVars.selectedOpeningRepertoire &&
                dropdown.querySelector(`option[value="${myVars.selectedOpeningRepertoire}"]`)) {
                dropdown.value = myVars.selectedOpeningRepertoire;
            }

            // Hindari double event listener
            if (!dropdown.dataset.listenerAttached) {
                dropdown.addEventListener("change", () => {
                    myVars.selectedOpeningRepertoire = dropdown.value;
                    console.log("[OpeningBook] Repertoire set to:", myVars.selectedOpeningRepertoire);
                });
                dropdown.dataset.listenerAttached = "true";
            }
        };

        // ======================= End of Opening Book Management =======================


        // ===========================================================================================================================================
        //                                                      âš™ï¸ ACPL/ ... âš™ï¸
        // ===========================================================================================================================================

        // ===========================================================================================================================================
        //
        // ===========================================================================================================================================
        function extractOpponentRating() {
            try {
                const playerUsernameEl = document.querySelector('.user-username-component');
                const playerUsername = playerUsernameEl ? playerUsernameEl.textContent.trim() : null;

                // Layout baru
                const ratingElementNew = document.querySelector("#board-layout-player-top .cc-user-rating-white") ||
                      document.querySelector("#board-layout-player-bottom .cc-user-rating-black");

                if (ratingElementNew) {
                    const rating = parseInt(ratingElementNew.textContent.replace(/\D/g, ""), 10);
                    if (!isNaN(rating)) return rating;
                }

                // Fallback: tagline rating
                const ratingElements = document.querySelectorAll('.user-tagline-rating');
                for (const element of ratingElements) {
                    const usernameElement = element.closest('.user-tagline')?.querySelector('.user-username-component');
                    const opponentUsername = usernameElement ? usernameElement.textContent.trim() : null;

                    if (opponentUsername && opponentUsername !== playerUsername) {
                        const rating = parseInt(element.textContent.replace(/\D/g, ""), 10);
                        if (!isNaN(rating)) return rating;
                    }
                }
            } catch (error) {
                console.error('[Extract] Error extracting opponent rating:', error);
            }
            return null;
        }
        // ===============================END====================================

        // ===========================================================================
        // configureEngineOptions (Final, Safe, Modular)
        // ===========================================================================
        function configureEngineOptions() {
            if (!engine?.engine || !engine?.controller) {
                console.warn("[Engine Config] Engine belum siap.");
                return;
            }

            try {
                // 1. MultiPV (jumlah variasi yang ditampilkan)
                const multipvValue = myVars.showMultipleMoves
                ? Math.max(1, myVars.numberOfMovesToShow || 3)
                : 1;

                engine.controller.setOption("MultiPV", multipvValue);
                console.log("[Engine Config] MultiPV diset ke:", multipvValue);

                // 2. ELO (jika ada)
                if (myVars.eloRating && typeof myFunctions.setEngineElo === "function") {
                    myFunctions.setEngineElo(myVars.eloRating);
                }

                // 3. Reset game dan konfirmasi kesiapan
                engine.controller.newGame();
                engine.controller.send("isready");
                console.log("[Engine Config] ucinewgame + isready dikirim.");

                // 4. Reset flags internal agar engine fresh
                myVars.topMoves = [];
                myVars.lastAnalyzedFen = null;
                myVars.isThinking = false;

            } catch (err) {
                console.error("[Engine Config] Gagal konfigurasi:", err);
            }
        }
        // ===========================================================================================================================================
        //                                                      âš™ï¸ logika delay âš™ï¸
        // ===========================================================================================================================================
        // ===========================================================================================================================================
        // myFunctions.parseTimeString (Mengkonversi string waktu catur (M:SS.ms, H:M:SS) menjadi detik)
        // ===========================================================================================================================================
        myFunctions.parseTimeString = function(timeString) {
            if (!timeString || typeof timeString !== 'string') return null;

            // Bersihkan string, hanya sisakan angka, titik, dan titik dua
            const cleanTime = timeString.replace(/[^\d:.]/g, '');

            // Mencoba mencocokkan format H:M:S, M:S, atau S
            const parts = cleanTime.split(':').map(p => parseFloat(p) || 0);

            let totalSeconds = 0;

            if (parts.length === 3) {
                // Format H:M:S.ms
                const [hours, minutes, seconds] = parts;
                totalSeconds = hours * 3600 + minutes * 60 + seconds;
            } else if (parts.length === 2) {
                // Format M:S.ms
                const [minutes, seconds] = parts;
                totalSeconds = minutes * 60 + seconds;
            } else if (parts.length === 1) {
                // Format S.ms (hanya detik)
                totalSeconds = parts[0];
            }

            return totalSeconds > 0 ? totalSeconds : (totalSeconds === 0 ? 0 : null);
        };
        // ===============================END====================================

        // ===========================================================================================================================================
        // myFunctions.getClockTimes (Mengambil waktu jam catur kedua pemain dalam detik)
        // ===========================================================================================================================================
        myFunctions.getClockTimes = function() {
            try {
                const clockSelectors = [
                    '.clock-time-monospace[role="timer"]',
                    '.clock-time-monospace',
                    '.clock-component .clock-time-monospace',
                    '#board-layout-player-top .clock-time-monospace',
                    '#board-layout-player-bottom .clock-time-monospace'
                ];

                let allClockElements = [];
                for (const selector of clockSelectors) {
                    const elements = document.querySelectorAll(selector);
                    if (elements.length > 0) {
                        allClockElements = Array.from(elements);
                        break;
                    }
                }

                if (allClockElements.length === 0) {
                    return { opponentTime: null, playerTime: null, found: false };
                }

                let opponentTime = null;
                let playerTime = null;

                if (allClockElements.length >= 2) {
                    const opponentTimeText = allClockElements[0].textContent || allClockElements[0].innerText;
                    const playerTimeText = allClockElements[1].textContent || allClockElements[1].innerText;

                    opponentTime = myFunctions.parseTimeString(opponentTimeText);
                    playerTime = myFunctions.parseTimeString(playerTimeText);
                } else if (allClockElements.length === 1) {
                    const timeText = allClockElements[0].textContent || allClockElements[0].innerText;
                    const parentElement = allClockElements[0].closest('.player-component, [class*="player"], [class*="top"], [class*="bottom"]');

                    if (parentElement) {
                        const parentClass = parentElement.className.toLowerCase();
                        const myColor = myVars.myColor || 'white';

                        if (parentClass.includes('top') || parentClass.includes('opponent') || (myColor === 'black' && parentClass.includes('white')) || (myColor === 'white' && parentClass.includes('black'))) {
                            opponentTime = myFunctions.parseTimeString(timeText);
                        } else if (parentClass.includes('bottom') || parentClass.includes('player') || (myColor === 'white' && parentClass.includes('white')) || (myColor === 'black' && parentClass.includes('black'))) {
                            playerTime = myFunctions.parseTimeString(timeText);
                        }
                    }
                }

                const result = {
                    opponentTime: opponentTime,
                    playerTime: playerTime,
                    found: opponentTime !== null || playerTime !== null
                };

                return result;

            } catch (error) {
                console.log('Clock Sync: Detection error:', error);
                return { opponentTime: null, playerTime: null, found: false };
            }
        };
        // ===============================END====================================

        // ===========================================================================================================================================
        // myFunctions.calculateClockSyncDelay (Menghitung penundaan langkah berdasarkan waktu jam pemain)
        // ===========================================================================================================================================
        myFunctions.calculateClockSyncDelay = function() {
            if (!myVars.clockSyncEnabled) {
                return 0;
            }

            const clockData = myFunctions.getClockTimes();

            // Periksa apakah data jam pemain dan waktu inkremen tersedia
            if (clockData.found && clockData.playerTime !== null && myVars.incrementSeconds !== undefined && myVars.moveNumber !== undefined) {

                // Konversi waktu ke milidetik untuk fungsi Dinamis
                const myTimeMs = clockData.playerTime * 1000;
                const incrementMs = myVars.incrementSeconds * 1000;
                const moveNum = myVars.moveNumber;

                // Gunakan Kalkulasi Dinamis
                return myFunctions.calculateDynamicMoveTime(myTimeMs, incrementMs, moveNum);

            } else {


                const minDelaySec = myVars.clockSyncMinDelay || 1.5;
                const maxDelaySec = myVars.clockSyncMaxDelay || 5.0;


                const randomDelay = (Math.random() * (maxDelaySec - minDelaySec) + minDelaySec) * 1000;


                if (clockData.playerTime !== null && clockData.playerTime <= 20) {
                    return 300;
                }

                return randomDelay;
            }
        };
        // ===============================END====================================

        // ===========================================================================================================================================
        // myFunctions.getCalculatedDelay (Mendapatkan penundaan langkah, menggunakan clock sync jika diaktifkan)
        // ===========================================================================================================================================
        myFunctions.getCalculatedDelay = function() {
            if (myVars.clockSyncEnabled && typeof myFunctions.calculateClockSyncDelay === 'function') {
                // Panggil fungsi yang kini mencakup logika dinamis dan fallback
                return myFunctions.calculateClockSyncDelay();
            }

            // Logika Delay Standar (Jika Clock Sync dimatikan)
            let minD = myVars.useSecondDelay ? myVars.minDelayTwo : myVars.minDelay;
            let maxD = myVars.useSecondDelay ? myVars.maxDelayTwo : myVars.maxDelay;

            minD = parseFloat(minD) || 1.5;
            maxD = parseFloat(maxD) || 5.0;

            const currentDelay = (Math.random() * (maxD - minD) + minD) * 1000;
            return currentDelay;
        };
        // ===============================END====================================

        // ===========================================================================================================================================
        //
        // ===========================================================================================================================================
        myFunctions.calculateDynamicMoveTime = function(myTimeMs, incrementMs, moveNumber) {
            const minThinkTime = 100; // Minimum delay, 100ms
            const maxThinkTime = 5000; // Maximum delay, 5 detik
            const estimatedTotalMoves = 60; // Asumsi total 60 langkah per pemain

            // Waktu yang harus dipertahankan per langkah
            const remainingMoves = Math.max(1, estimatedTotalMoves - moveNumber);
            const timeForAverageMove = (myTimeMs / remainingMoves);

            // Gunakan 1/20 dari sisa waktu ditambah sedikit inkremen.
            let calculatedTime = (myTimeMs / 20) + (incrementMs / 2);

            // Batasi waktu berpikir agar tidak terlalu cepat atau terlalu lambat
            let finalDelay = Math.min(calculatedTime, timeForAverageMove, maxThinkTime);
            finalDelay = Math.max(finalDelay, minThinkTime);

            // Tambahkan sedikit variasi acak (humanisasi)
            const jitter = Math.random() * 200 - 100; // Jitter antara -100ms hingga +100ms
            finalDelay = Math.max(minThinkTime, finalDelay + jitter);

            console.log(`[Timer] Waktu Pikir Dihitung: ${finalDelay.toFixed(0)}ms (Sisa Waktu Anda: ${(myTimeMs/1000).toFixed(1)}s)`);

            return finalDelay;
        };
        // ===============================END====================================

        // ===========================================================================================================================================
        // myFunctions.calculateWDL (Perkiraan probabilitas Win-Draw-Loss berdasarkan skor CP)
        // ===========================================================================================================================================
        myFunctions.calculateWDL = function(cpScore, depth) {
            // Validasi input
            if (typeof cpScore !== 'number' || isNaN(cpScore)) {
                console.warn("[WDL] Invalid cpScore:", cpScore);
                return "W: 0% D: 0% L: 0%"; // Fallback
            }
            if (typeof depth !== 'number' || isNaN(depth)) {
                depth = 0; // Default jika depth tidak valid
            }

            // Jika skor absolut sangat tinggi (mate atau posisi jelas), langsung return 100%
            if (Math.abs(cpScore) > 5000) {
                return cpScore > 0 ? "W: 100% D: 0% L: 0%" : "W: 0% D: 0% L: 100%";
            }

            // Konstanta dasar (disesuaikan berdasarkan model Stockfish atau formula umum)
            const baseC = 0.00361; // Konstanta sigmoid untuk win probability
            const depthFactor = Math.min(Math.max(depth, 0), 50); // Batasi depth antara 0-50
            const adjustedC = baseC * (1 + 0.04 * (depthFactor / 50)); // Sesuaikan C berdasarkan depth

            // Hitung win probability menggunakan sigmoid (untuk white advantage)
            const pWin = 1.0 / (1.0 + Math.exp(-adjustedC * cpScore));

            // Loss probability sebagai kebalikan win
            const pLoss = 1.0 - pWin;

            // Draw probability: Semakin dekat cpScore ke 0, semakin tinggi peluang draw
            // Menggunakan exponential decay, maksimum ~50% saat cpScore = 0
            const drawFactor = Math.exp(-Math.abs(cpScore) / 250);
            const pDraw = drawFactor * 0.5;

            // Normalisasi agar total probabilitas = 1 (karena pWin + pLoss + pDraw mungkin > 1)
            const total = pWin + pLoss + pDraw;
            if (total === 0) return "W: 0% D: 0% L: 0%"; // Edge case jika semua 0

            const w = Math.round((pWin / total) * 100);
            const l = Math.round((pLoss / total) * 100);
            const d = 100 - w - l; // Pastikan total 100%

            // Pastikan tidak ada nilai negatif atau >100% (meski jarang terjadi)
            const clampedW = Math.max(0, Math.min(100, w));
            const clampedD = Math.max(0, Math.min(100, d));
            const clampedL = Math.max(0, Math.min(100, l));

            return `W: ${clampedW}% D: ${clampedD}% L: ${clampedL}%`;
        };
        // ===============================END====================================
        // ===========================================================================================================================================
        // myFunctions.parseScoreToCP (Mengkonversi string skor (cp atau mate) menjadi nilai centipawn numerik)
        // ===========================================================================================================================================
        myFunctions.parseScoreToCP = (score) => {
            if (typeof score !== 'string') return 0;

            const MATE_CP_BASE = 50000; // Nilai CP yang sangat tinggi, digunakan sebagai dasar mate

            // 1. Tangani Mate (M)
            const mateMatch = score.match(/M([+-]?\d+)/i);
            if (mateMatch) {
                const movesToMate = parseInt(mateMatch[1], 10);

                if (movesToMate > 0) {

                    return MATE_CP_BASE + (3000 - movesToMate); // Nilai > 50000, semakin kecil langkah semakin besar CP
                } else if (movesToMate < 0) {

                    return -MATE_CP_BASE - (3000 + movesToMate); // Nilai < -50000, semakin kecil langkah semakin kecil CP
                }
                return 0; // Kasus M0 atau mateMatch[1] adalah 0
            }

            // 2. Tangani Centipawn (CP)
            // Asumsi score format '1.50' (pawn) atau '150' (centipawn). Kita asumsikan input sudah CP.
            const cpValue = parseFloat(score);
            // Jika input adalah format '1.50' (nilai pion), kalikan 100
            if (score.includes('.') && Math.abs(cpValue) < 100) {
                return Math.round(cpValue * 100);
            }

            // Jika input sudah dalam centipawn
            return isNaN(cpValue) ? 0 : Math.round(cpValue);
        };
        // ===============================END====================================
        // ===========================================================================================================================================
        //                                                      âš™ï¸ BAGIAN OTOMATIS âš™ï¸
        // ===========================================================================================================================================

        // ------------------------------------------------------------------------------------------------------------------------------------------ //
        // FUNGSI myFunctions.autoMatch (OTOMATIS MEMULAI PERMAINAN BARU SETELAH SELESAI)
        // ------------------------------------------------------------------------------------------------------------------------------------------ //
        myFunctions.autoMatch = async function() {
            // Fungsi bantuan untuk penundaan menggunakan Promise
            const delay = (ms) => new Promise(resolve => setTimeout(resolve, ms));

            if (autoStartTriggered) {
                clearInterval(checkInterval);
                console.log("[AutoMatch] Proses auto-start dibatalkan karena sudah aktif.");
                return;
            }

            // â­ Pemeriksaan Awal Modal Game Over
            if (!$('.game-over-modal-container').length) {
                console.log("[AutoMatch] Modal Game Over tidak ditemukan. Asumsi game baru sudah dimulai atau tidak perlu tindakan.");
                if (typeof myVars !== 'undefined') myVars.hasAutoMatched = true;
                clearInterval(checkInterval);
                return;
            }

            // --- 1. TOLAK REMATCH DULU ---
            console.log("[AutoMatch] Langkah 1: Mencari tombol Tolak Rematch...");

            const declineRematchButton = $(
                '.game-over-modal-content .cc-button-component,' +
                '[aria-label="Decline Rematch"],' +
                '[data-cy="rematch-decline-button"]'
            ).filter(function() {
                const text = $(this).text().trim().toLowerCase();
                return text === "x tolak" || text === "tolak";
            });

            // Debug semua tombol yang ada
            $('.game-over-modal-content .cc-button-component').each(function() {
                console.log("DEBUG tombol:", JSON.stringify($(this).text().trim()));
            });

            if (declineRematchButton.length) {
                const buttonText = declineRematchButton.text().trim();
                declineRematchButton[0].click();
                console.log(`[AutoMatch] Tombol Tolak Rematch (${buttonText}) ditemukan dan DIKLIK SEGERA.`);

                // Tunggu agar modal hilang
                await delay(1500);

                // Panggil ulang untuk lanjut ke langkah berikut
                myFunctions.autoMatch();
                return;
            }

            console.log("[AutoMatch] Langkah 1 Selesai: Tombol Tolak Rematch tidak ditemukan. Melanjutkan mencari permainan baru...");

            // --- 2. CARI TOMBOL NEXT GAME ---
            const nextGameSelectors = [
                '.game-over-arena-button-component .cc-button-full:contains("Permainan Arena Selanjutnya")',
                '[data-cy="next-arena-game-button"]',
                '[data-cy="tournament-next-game-button"]',
                '.arena-page-live-panel .button-component:contains("NEXT")',
                '.game-over-arena-button-component .cc-button-full:contains("Next Arena Game")'
            ];
            let buttonToClick = $(nextGameSelectors.join(', '));
            let logMessage = "Arena/Tournament (Next Game)";

            // --- 3. CARI TOMBOL NEW GAME BIASA ---
            if (!buttonToClick.length) {
                const newGameSelectors = [
                    '[data-cy="sidebar-game-over-new-game-button"]',
                    '.game-over-modal-content .game-over-buttons-component .cc-button-component:not([aria-label="Rematch"])',
                    '.game-over-buttons-component .cc-button-component:not([aria-label="Rematch"])'
                ];
                buttonToClick = $(newGameSelectors.join(', '));
                logMessage = "Standard (New Game)";
            }

            // --- 4. EKSEKUSI KLIK ---
            if (buttonToClick.length) {
                const finalButtonText = buttonToClick.text().trim() || logMessage;
                console.log(`[AutoMatch] Tombol target ditemukan: ${finalButtonText}. Menunggu 10 detik untuk klik...`);

                await delay(10000);

                buttonToClick[0].click();
                console.log(`[AutoMatch] DIKLIK: ${finalButtonText}. Mencari game baru.`);

                if (typeof myVars !== 'undefined') {
                    myVars.hasAutoMatched = true;
                    myVars.gameEnded = false;
                    myVars.isGameOver = false; // ðŸ”¥ reset flag game over
                    myVars.isThinking = false;
                    myVars.lastAnalyzedFen = null;

                }
                autoStartTriggered = false;

                // ðŸ”¥ Wake up engine setelah klik
                if (typeof myFunctions.wakeUpEngine === 'function') {
                    setTimeout(() => {
                        myFunctions.wakeUpEngine();
                        myFunctions.clearMoveHistory();
                    }, 2000); // beri jeda agar papan baru render
                } else {
                    // fallback: pasang observer & trigger analisis manual
                    setTimeout(() => {
                        myFunctions.setupMoveObserver?.();
                        myFunctions.checkAndRunAnalysisAutoMove?.();
                    }, 2000);
                }

            } else {
                console.log("[AutoMatch] Peringatan: Tidak ada tombol New Game/Next Arena yang ditemukan. Mencoba lagi di iterasi berikutnya.");
            }
        };
        // ===============================END====================================

        // ===========================================================================
        // Resign Game (compact & ESLint-safe)
        // ===========================================================================
        // =========================================================
        // FUNGSI AUTO RESIGN (MENYERAH OTOMATIS) - BARU
        // =========================================================
        myFunctions.resignGame = function() {
            if (myVars.gameEnded || myVars.resignationPending) return;

            myVars.resignationPending = true;

            const resignButton =
                  document.querySelector('button[data-cy="resign-button"]') ||
                  document.querySelector('.resign-button') ||
                  document.querySelector('button[data-cy="game-controls-resign"]') ||
                  Array.from(document.querySelectorAll('button')).find(btn => {
                      const text = btn.textContent.trim().toLowerCase();
                      return text === 'resign' || text === 'menyerah';
                  });

            if (!resignButton) {
                myVars.resignationPending = false;
                return;
            }

            resignButton.click();

            setTimeout(() => {

                let confirmButton = document.querySelector('button[data-cy="confirm-yes"]');

                if (!confirmButton) {
                    confirmButton = Array.from(document.querySelectorAll('button.cc-button-primary')).find(btn => {
                        const span = btn.querySelector('span');
                        return span && span.textContent.trim().toLowerCase() === 'ya';
                    });
                }

                if (confirmButton) {
                    confirmButton.click();
                    myVars.gameEnded = false;
                    autoStartTriggered = false;
                    console.log("[Resign] Game ended. Auto-start process triggered.");

                    if (myVars.autoMatchEnabled) {
                        setTimeout(() => {
                            myFunctions.autoMatch();
                        }, 500);
                    }
                }
                myVars.resignationPending = false;

            }, 50);
        };
        // ===============================END====================================

        // ===========================================================================
        // Auto-Resign Logic (compact & ESLint-safe)
        // ===========================================================================
        myFunctions.checkAutoResign = function(evalData) {
            if (!myVars.autoResignEnabled || myVars.gameEnded || myVars.resignationPending || !evalData) return;

            try {
                const { type, value } = evalData;
                if (!type || isNaN(value)) return;

                // 1. Normalisasi warna
                const mySide = (myVars.side || 'w').toLowerCase();
                let myActualScore = value;
                if (mySide === 'b' || mySide === 'black') {
                    myActualScore = -value;
                }

                let isResignTriggered = false;

                // 2. Evaluasi: myActualScore < 0 berarti kita kalah
                if (myActualScore < 0) {
                    const absScore = Math.abs(myActualScore);

                    if (type === 'cp') {
                        const thresholdCp = myVars.autoResignThresholdCp ?? 1000;
                        if (absScore >= thresholdCp) {
                            console.log(`[Auto Resign] Kekalahan ${absScore} cP (Threshold: ${thresholdCp}).`);
                            isResignTriggered = true;
                        }
                    } else if (type === 'mate') {
                        const thresholdMate = myVars.autoResignThreshold ?? 3;
                        const fullMovesToMate = Math.ceil(absScore / 2);
                        if (fullMovesToMate <= thresholdMate) {
                            console.log(`[Auto Resign] Mate in ${fullMovesToMate} (Threshold: M${thresholdMate}).`);
                            isResignTriggered = true;
                        }
                    }
                }

                // 3. Eksekusi
                if (isResignTriggered) {
                    console.log("%c[SYSTEM] Auto Resign triggered!", "color: red; font-weight: bold;");
                    myFunctions.resignGame();
                }
            } catch (e) {
                console.error("[Auto Resign ERROR]", e);
            }
        };
        // ===============================END====================================

        // ===========================================================================================================================================
        //                                                      âš™ï¸ HUMAN MODE âš™ï¸
        // ===========================================================================================================================================

        // ===========================================================================================================================================
        // document.onkeydown (Penanganan Pintasan Keyboard Global)
        // ===========================================================================================================================================
        document.onkeydown = function(e) {
            // 1. Kontrol Panel UI (ESC)
            if (e.keyCode === 27) { // ESC Key
                e.preventDefault(); // Mencegah browser melakukan tindakan default
                if (myVars.panelState === 'closed') {
                    myFunctions.setPanelState('maximized'); // Jika tertutup, tampilkan kembali
                } else {
                    myFunctions.setPanelState('closed'); // Jika terbuka, sembunyikan
                }
                return;
            }

            // 2. Cegah pintasan jika panel ditutup atau fokus pada input
            if (myVars.panelState === 'closed' || e.target.tagName === 'INPUT' || e.target.tagName === 'TEXTAREA') {
                return;
            }

            // 3. Pintasan Analisis (Berjalan hanya jika panel terbuka)
            switch (e.keyCode) {
                    // Baris 1: Q(1) - P(10)
                case 81: myFunctions.runChessEngine(1); break; // Q
                case 87: myFunctions.runChessEngine(2); break; // W
                case 69: myFunctions.runChessEngine(3); break; // E
                case 82: myFunctions.runChessEngine(4); break; // R
                case 84: myFunctions.runChessEngine(5); break; // T
                case 89: myFunctions.runChessEngine(6); break; // Y
                case 85: myFunctions.runChessEngine(7); break; // U
                case 73: myFunctions.runChessEngine(8); break; // I
                case 79: myFunctions.runChessEngine(9); break; // O
                case 80: myFunctions.runChessEngine(10); break; // P

                    // Baris 2: A(11) - L(19)
                case 65: myFunctions.runChessEngine(11); break; // A
                case 83: myFunctions.runChessEngine(12); break; // S
                case 68: myFunctions.runChessEngine(13); break; // D
                case 70: myFunctions.runChessEngine(14); break; // F
                case 71: myFunctions.runChessEngine(15); break; // G
                case 72: myFunctions.runChessEngine(16); break; // H
                case 74: myFunctions.runChessEngine(17); break; // J
                case 75: myFunctions.runChessEngine(18); break; // K
                case 76: myFunctions.runChessEngine(19); break; // L

                    // Baris 3: Z(20) - M(26)
                case 90: myFunctions.runChessEngine(20); break; // Z
                case 88: myFunctions.runChessEngine(21); break; // X
                case 67: myFunctions.runChessEngine(22); break; // C
                case 86: myFunctions.runChessEngine(23); break; // V
                case 66: myFunctions.runChessEngine(24); break; // B
                case 78: myFunctions.runChessEngine(25); break; // N
                case 77: myFunctions.runChessEngine(26); break; // M

                    // Pintasan Khusus
                case 187: // Tombol '+' / '='
                case 61: // Tombol '=' pada beberapa keyboard
                    myFunctions.runChessEngine(100); // Kedalaman Super/Unlimit
                    break;

                case 13: // ENTER: Mulai/Hentikan Analisis Cepat (misalnya, depth 15)
                    myFunctions.runChessEngine(15);
                    break;

                case 32: // SPACEBAR: Hentikan Analisis/Engine
                    e.preventDefault(); // Mencegah scroll
                    if (myVars.analysisEngine) {
                        myVars.analysisEngine.postMessage("stop");
                        myFunctions.setEngineState(ENGINE_STATE.READY);
                        myFunctions.updateTurnStatus();
                        if (typeof myFunctions.updateEngineStatusText === 'function') myFunctions.updateEngineStatusText('STOPPED');
                        if (typeof myFunctions.log === 'function') myFunctions.log("Engine", "Analisis Dihentikan oleh user (SPACEBAR).");
                    }
                    break;
            }
        };
        // ===============================END====================================

        // ===========================================================================================================================================
        //
        // ===========================================================================================================================================
        myFunctions.toggleHighlight = function() {
            myVars.highlightEnabled = !myVars.highlightEnabled;
            GM_setValue('highlightEnabled', myVars.highlightEnabled);
            myFunctions.updateEngineLeds();
        };
        // ===============================END====================================

        // ===========================================================================================================================================
        //
        // ===========================================================================================================================================
        myFunctions.clearHighlights = function() {
            document.querySelectorAll('.highlight.bro').forEach(el => el.remove());
        };
        // ===============================END====================================

        // ===========================================================================
        // HUMAN MODE CONFIG (BASE PROFILES)
        // ===========================================================================
        const HUMAN_MODE_CONFIG = {
            beginner:     { elo: 800, moveTime: { min: 1, max: 4 }, errorRate: 0.30, blunderRate: 0.15 },
            casual:       { elo: 1200, moveTime: { min: 2, max: 7 }, errorRate: 0.20, blunderRate: 0.10 },
            intermediate: { elo: 1600, moveTime: { min: 3, max: 10 }, errorRate: 0.15, blunderRate: 0.05 },
            advanced:     { elo: 2000, moveTime: { min: 4, max: 14 }, errorRate: 0.10, blunderRate: 0.03 },
            expert:       { elo: 2400, moveTime: { min: 6, max: 18 }, errorRate: 0.05, blunderRate: 0.01 },
            personalized: { elo: 1500, moveTime: { min: 4, max: 15 }, errorRate: 0.20, blunderRate: 0.06 }
        };

        // ===============================END====================================

        // ===========================================================================
        // 2. FUNGSI LOGIKA (CORE LOGIC)
        // ===========================================================================
        myFunctions.setHumanMode = function (level = 'intermediate', speedFactor = myVars.speedFactor || 1.0) {

            let config = HUMAN_MODE_CONFIG[level];

            // CUSTOM MODE (slider ELO)
            if (!config || level === 'custom') {
                const elo = parseInt(myVars.eloRating, 10) || 1600;
                const normalized = Math.min(1, Math.max(0, (elo - 800) / 1600));

                config = {
                    elo,
                    moveTime: {
                        min: Math.max(0.8, 1.5 + normalized * 4),
                        max: Math.min(20, 4 + normalized * 12)
                    },
                    errorRate: 0.30 - normalized * 0.20,
                    blunderRate: 0.18 - normalized * 0.15
                };
            }

            // SPEED FACTOR
            const adjustedMoveTime = {
                min: Math.max(0.25, config.moveTime.min * speedFactor),
                max: Math.max(0.8, config.moveTime.max * speedFactor)
            };

            myVars.humanMode = {
                active: true,
                level,
                elo: config.elo,
                moveTime: adjustedMoveTime,
                errorRate: config.errorRate,
                blunderRate: config.blunderRate,
                jitter: (adjustedMoveTime.max - adjustedMoveTime.min) * 0.20
            };

            // Sync engine strength
            if (typeof myFunctions.setEngineElo === 'function') {
                myFunctions.setEngineElo(config.elo);
            }

            console.log(
                `[HUMAN MODE] ${level.toUpperCase()} | ELO ${config.elo} | ` +
                `Delay ${adjustedMoveTime.min.toFixed(1)}â€“${adjustedMoveTime.max.toFixed(1)}s`
    );
        };

// ===============================END====================================

myFunctions.calculateHumanDelay = function () {

    // ENGINE MODE
    if (myVars.evaluationMode !== 'human' || !myVars.humanMode) {
        return Math.floor(Math.random() * 400) + 300;
    }

    const { min, max, jitter, errorRate } = myVars.humanMode;

    // Gaussian-ish distribution (lebih manusia)
    const u = Math.random();
    const v = Math.random();
    let base = Math.sqrt(-2 * Math.log(u)) * Math.cos(2 * Math.PI * v);

    base = (base + 3) / 6; // normalize ~0..1
    let delay = min + base * (max - min);

    // jitter
    delay += (Math.random() * 2 - 1) * jitter;

    let finalDelay = delay * 1000;

    // Instinctive move (cepat)
    if (Math.random() < 0.10) {
        finalDelay = Math.random() * 600 + 250;
    }

    // Error hesitation (kadang mikir lama)
    if (Math.random() < errorRate * 0.4) {
        finalDelay += Math.random() * 1500;
    }

    return Math.max(250, finalDelay);
};

// ===============================END====================================

// ===========================================================================
// 3. SINKRONISASI UI DAN EVENT LISTENERS
// ===========================================================================
function setupHumanModeSynchronization() {

    const humanModeSelect = $('#humanLevelDropdown');
    const eloSlider = $('#eloRatingInput');
    const eloDisplay = $('#eloRatingDisplay');
    const speedSlider = $('#speedFactorInput');
    const speedDisplay = $('#speedFactorDisplay');
    const toggleBtn = $('#toggleEvaluationMode');

    // CLEAN LISTENERS
    humanModeSelect.off();
    eloSlider.off();
    speedSlider.off();
    toggleBtn.off();

    humanModeSelect.on('change', function () {
        const mode = this.value;
        GM_setValue('lastHumanLevelMode', mode);

        if (mode !== 'custom') {
            const elo = HUMAN_MODE_CONFIG[mode]?.elo || 1600;
            myVars.eloRating = elo;
            GM_setValue('eloRating', elo);
            eloSlider.val(elo);
            eloDisplay.text(elo);
        }

        if (myVars.evaluationMode === 'human') {
            myFunctions.setHumanMode(mode, myVars.speedFactor);
        }
    });

    eloSlider.on('input', function () {
        eloDisplay.text(this.value);
    }).on('change', function () {
        myVars.eloRating = +this.value;
        GM_setValue('eloRating', myVars.eloRating);
        humanModeSelect.val('custom');
        GM_setValue('lastHumanLevelMode', 'custom');

        if (myVars.evaluationMode === 'human') {
            myFunctions.setHumanMode('custom', myVars.speedFactor);
        }
    });

    speedSlider.on('input', function () {
        speedDisplay.text(+this.value.toFixed(1));
    }).on('change', function () {
        myVars.speedFactor = +this.value;
        GM_setValue('speedFactor', myVars.speedFactor);

        if (myVars.evaluationMode === 'human') {
            myFunctions.setHumanMode(humanModeSelect.val(), myVars.speedFactor);
        }
    });

    toggleBtn.on('click', function () {
        const newMode = myVars.evaluationMode === 'engine' ? 'human' : 'engine';
        myVars.evaluationMode = newMode;
        GM_setValue('evaluationMode', newMode);

        $(this)
            .text(newMode === 'engine' ? 'ðŸ¤–ENGINE' : 'ðŸ§‘HUMAN')
            .toggleClass('on', newMode === 'engine')
            .toggleClass('off', newMode === 'human');

        if (newMode === 'human') {
            myFunctions.setHumanMode(humanModeSelect.val(), myVars.speedFactor);
        } else {
            myFunctions.setEngineElo?.(3190);
        }

        myFunctions.updateEngineLeds?.();
    });
}

// ===============================END====================================

// ===========================================================================
// 4. PERSISTENCE & AUTO-START
// ===========================================================================
myFunctions.checkAndSetupLevelPersistence = function () {

    let initialized = false;
    let observer;

    observer = new MutationObserver(() => {
        const dropdown = document.getElementById('humanLevelDropdown');
        if (!dropdown || initialized) return;

        const savedLevel = GM_getValue('lastHumanLevelMode', 'intermediate');
        const savedElo = GM_getValue('eloRating', 1600);
        const savedSpeed = GM_getValue('speedFactor', 1.0);
        const savedEvalMode = GM_getValue('evaluationMode', 'human');

        myVars.speedFactor = savedSpeed;
        myVars.eloRating = savedElo;
        myVars.evaluationMode = savedEvalMode;

        $('#humanLevelDropdown').val(savedLevel);
        $('#eloRatingInput').val(savedElo);
        $('#eloRatingDisplay').text(savedElo);
        $('#speedFactorInput').val(savedSpeed);
        $('#speedFactorDisplay').text(savedSpeed.toFixed(1));

        setupHumanModeSynchronization();

        if (savedEvalMode === 'human') {
            myFunctions.setHumanMode(savedLevel, savedSpeed);
        }

        initialized = true;
        observer.disconnect();

        console.log('[HUMAN MODE] Persistence loaded & synced');
    });

    observer.observe(document.body, { childList: true, subtree: true });
};

// ===============================END====================================

// ===========================================================================
// âš™ï¸ setPanelState (Mengontrol tampilan panel UI [buka/tutup/minim])
// ===========================================================================
myFunctions.setPanelState = function(state = 'minimized') {
    const panel = document.getElementById('chess-ui-overlay');
    if (!panel) return;

    myVars.panelState = state;
    GM_setValue('panelState', state);

    panel.classList.remove('minimized', 'maximized', 'closed');
    panel.classList.add(state);

    if (myVars.humanMode?.active) {
        myFunctions.updateHumanModeUI();
    }

    if (state !== 'closed' && !document.querySelector('.menu-item.active')) {
        document.querySelector('.menu-item[data-content="engine-settings"]')?.click();
    }
};
// ===============================END====================================

// ===========================================================================
// âš™ï¸ AUTO MINIMIZE ON IDLE
// Panel otomatis minimize jika tidak ada interaksi user dalam 30 detik
// ===========================================================================
(function setupAutoMinimize() {
    let idleTimer;
    const resetIdleTimer = () => {
        clearTimeout(idleTimer);
        idleTimer = setTimeout(() => {
            if (myVars.panelState !== 'closed') {
                myFunctions.setPanelState('minimized');
                console.log('[Panel] Auto minimized karena idle 30 detik.');
            }
        }, 30000);
    };

    ['mousemove','keydown','click','scroll','touchstart'].forEach(evt => {
        document.addEventListener(evt, resetIdleTimer, { passive: true });
    });

    resetIdleTimer();
})();
// ===============================END====================================



// ===========================================================================================================================================
// jam
// ===========================================================================================================================================
function updateClockOverlay() {
    const now = new Date();

    // Format waktu menjadi HH:MM:SS
    let hours = now.getHours().toString().padStart(2, '0');
    let minutes = now.getMinutes().toString().padStart(2, '0');
    let seconds = now.getSeconds().toString().padStart(2, '0');

    const timeString = `${hours}:${minutes}:${seconds}`;

    // Temukan elemen jam yang baru ditambahkan
    const clockElement = document.getElementById('digital-clock');

    // Periksa apakah elemen sudah ada di DOM sebelum memperbarui
    if (clockElement) {
        clockElement.textContent = timeString;
    }
}
// Panggil fungsi saat awal
updateClockOverlay();

// Perbarui jam setiap 1 detik (1000 milidetik)
setInterval(updateClockOverlay, 1000);
// ===============================END====================================

// ===========================================================================================================================================
//
// ===========================================================================================================================================
myFunctions.updateBoardColors = function() {
    if (!board) return;
    const styleId = 'custom-board-style';
    let styleElement = document.getElementById(styleId);
    if (!styleElement) {
        styleElement = document.createElement('style');
        styleElement.id = styleId;
        document.head.appendChild(styleElement);
    }

    let isReversed = false;
    if(board.classList.contains('flipped')){
        isReversed = true;
    }

    // Logika untuk menangani papan yang dibalik
    const lightSelector = isReversed ? `.board .square.dark` : `.board .square.light`;
    const darkSelector = isReversed ? `.board .square.light` : `.board .square.dark`;

    styleElement.textContent = `
        ${lightSelector} {
            background-color: ${myVars.lightSquareColor} !important;
        }
        ${darkSelector} {
            background-color: ${myVars.darkSquareColor} !important;
        }
       `;
        };
// ===============================END====================================F
// ===========================================================================================================================================
//
// ===========================================================================================================================================
function addAnimation(body) {
    if (!dynamicStyles) {
        dynamicStyles = document.createElement('style');
        dynamicStyles.type = 'text/css';
        document.head.appendChild(dynamicStyles);
    }

    if (dynamicStyles.sheet && typeof body === 'string') {
        dynamicStyles.sheet.insertRule(body, dynamicStyles.sheet.cssRules.length);
    } else {
        console.warn('[addAnimation] Invalid CSS rule or dynamicStyles is not initialized.');
    }
}
// ===============================END====================================

// ===========================================================================================================================================
//
// ===========================================================================================================================================
const contentTemplates = {
    'engine-settings': () => `
    <div style="padding: 20px; color: #eee; font-family: 'Segoe UI', Tahoma, sans-serif;">
    <!-- Header -->
<header class="text-center mb-6 bg-gradient-to-r from-purple-700 via-yellow-500 to-red-500 p-6 rounded-lg shadow-lg">
  <h1 class="text-4xl sm:text-5xl font-extrabold text-white drop-shadow-md mb-3">
    â™” Chess Analysis Dashboard â™•
  </h1>
  <p class="text-gray-100 text-lg sm:text-xl tracking-wide">
    Engine Analysis dengan Centipawn Loss Tracking
  </p>
</header>
      <!-- =================== MONITOR BOX =================== -->
      <div id="monitorBox" style="background: #111; border-radius: 8px; border: 1px solid #333; overflow: hidden; width: 100%; box-shadow: 0 10px 30px rgba(0,0,0,0.5);">

        <!-- HEADER -->
        <div style="padding: 8px 12px; background: #1a1a1a; font-size: 10px; color: #888; display: flex; justify-content: space-between; align-items: center; border-bottom: 1px solid #333;">
          <div style="display: flex; align-items: center; gap: 12px;">
            <span style="display: flex; align-items: center; gap: 6px; font-weight: bold; color: #4caf50;">
              <span id="monitorStatusLight" style="width: 8px; height: 8px; background: #4caf50; border-radius: 50%; box-shadow: 0 0 5px #4caf50;"></span>
              SYSTEM MONITOR
            </span>
            <div id="enginePanel" style="display: flex; align-items: center; gap: 6px; border-left: 1px solid #333; padding-left: 12px;">
              <div id="engine-led" style="width: 8px; height: 8px; border-radius: 50%; background: #555; transition: 0.3s;"></div>
              <span id="engine-status-text" style="font-size: 10px; color: #aaa; text-transform: uppercase;">Idle</span>
              <span class="control-btn" id="note-elo-human" title="visual bord" style="cursor:pointer; margin-left:4px;">â„¹ï¸</span>
            </div>
          </div>
          <div style="display: flex; align-items: center; gap: 10px;">
            <span class="menu-item help-btn" data-content="Pesan-Eror" title="pesan eror" style="cursor: pointer; font-size: 14px; opacity: 0.7;">âœ‰ï¸</span>
            <button id="clearLogBtn" style="background: #2a2a2a; border: 1px solid #444; color: #ccc; cursor: pointer; font-size: 9px; padding: 3px 10px; border-radius: 4px;">CLEAR</button>
          </div>
        </div>

        <!-- ENGINE INFO BAR -->
        <div style="background:#0f0f0f; padding: 10px; border-bottom: 1px solid #222; font-family: 'Consolas', monospace; font-size: 11px; display: flex; gap: 8px;">
          <div style="flex:1; display:flex; gap:6px; align-items:center; background:#161616; padding:6px 8px; border-radius:4px;">
            <span style="color:#9b59b6; font-weight:bold;">NODES</span>
            <span id="nodesDisplay" style="color:#fff;">0</span>
          </div>
          <div style="flex:1; display:flex; gap:6px; align-items:center; background:#161616; padding:6px 8px; border-radius:4px;">
            <span style="color:#e67e22; font-weight:bold;">NPS</span>
            <span id="npsDisplay" style="color:#fff;">0</span>
          </div>
          <div style="flex:1; display:flex; gap:6px; align-items:center; background:#161616; padding:6px 8px; border-radius:4px;">
            <span style="color:#ff4444; font-weight:bold;">TIME</span>
            <span id="timeDisplay" style="color:#fff;">0 ms</span>
          </div>
        </div>

        <!-- MINI LOG CONSOLE -->
        <div id="miniLogConsole" style="height: 120px; overflow-y: auto; padding: 12px; font-family: 'Consolas', monospace; font-size: 11px; line-height: 1.6; background: #070707; color: #888;">
          <div style="color: #444;">[SYSTEM] Initializing logger...</div>
          <div style="color: #00eb9b;">[READY] Script Go-Kill active.</div>
        </div>

        <!-- ENGINE STATE LED BAR -->
        <style>
          .engine-led-item { display: flex; align-items: center; gap: 5px; color: #666; font-weight: bold; }
          .led-dot { width: 6px; height: 6px; background: #333; border-radius: 50%; }
        </style>
        <div id="engineStateLEDBar" style="display: flex; justify-content: center; flex-wrap: wrap; gap: 15px; padding: 10px; background: #1a1a1a; border-top: 1px solid #333; font-family: 'Consolas', monospace; font-size: 9px;">
          <div class="engine-led-item" data-state="READY"><span class="led-dot"></span> READY</div>
          <div class="engine-led-item" data-state="WAITING"><span class="led-dot"></span> WAITING</div>
          <div class="engine-led-item" data-state="RUNNING"><span class="led-dot"></span> RUNNING</div>
          <div class="engine-led-item" data-state="THINKING"><span class="led-dot"></span> THINKING</div>
          <div class="engine-led-item" data-state="DELAY"><span class="led-dot"></span> DELAY</div>
          <div class="engine-led-item" data-state="IDLE"><span class="led-dot"></span> IDLE</div>
          <div class="engine-led-item" data-state="ERROR"><span class="led-dot"></span> ERROR</div>
        </div>
      </div>

      <!-- DEPTH & ELO DISPLAY -->
      <div class="setting-row" style="display: flex; justify-content: space-between; align-items: center; margin: 10px 0; background-color: #3a3634; padding: 8px 12px; border-radius: 4px;">
        <span id="depthText" class="depth-display" style="margin:0;">
          Current Depth: <strong id="depthLive" style="color: #7fa650;">..</strong>
        </span>
        <span id="eloOpponentText" class="elo-display" style="margin:0;">
          Elo Lawan: <strong id="eloOpponentLive" style="color: #7fa650;">..</strong>
        </span>
      </div>

      <!-- PV DISPLAY -->
      <div style="background: #1e1e1e; padding: 10px; border-radius: 6px; border: 1px solid #333; margin-bottom: 10px;">
        <div style="display: flex; gap: 8px; font-size: 13px;">
          <span style="color: #00eb9b; font-weight: bold;">PV:</span>
          <div id="pvDisplay" style="font-family: 'Consolas', monospace; color: #ddd; word-break: break-all;">Waiting...</div>
        </div>
      </div>

            <div class="setting-row" style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 10px; background-color: #3a3634; padding: 8px 12px; border-radius: 4px;">
                <div style="display: flex; align-items: center; padding-right: 15px; border-right: 1px solid #555555;">
                    <span>Current Depth:</span>
                    <span id="depthValue" style="font-weight: bold; color: #7fa650; background:#333; padding:2px 6px; border-radius:4px; margin-left: 5px;">${myVars.customDepth}</span>
                </div>
                <div style="display: flex; align-items: center; padding-left: 15px; padding-right: 15px; border-right: 1px solid #555555;">
                    <span>Current Elo:</span>
                    <span id="eloValueDisplay" style="font-weight: bold; color: #7fa650; background:#333; padding:2px 6px; border-radius:4px; margin-left: 5px;">${myVars.eloRating}</span>
                </div>
                <div style="display: flex; align-items: center; padding-left: 15px;">
                    <span>Current skill:</span>
                    <span id="skillLevelValue" style="font-weight:bold; font-size:14px; color: #7fa650; background:#333; padding:2px 6px; border-radius:4px; margin-left: 5px;">10</span>
                </div>
            </div>

            <div class="setting-row" style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 10px; background-color: #3a3634; padding: 8px 12px; border-radius: 4px; border: 2px solid ${myVars.autoSyncElo ? '#4caf50' : '#eb6150'};">
           <label style="font-weight: bold;">Auto Sync ELO Lawan:</label>
          <button type="button" id="toggleAutoSyncElo" class="on-off-button ${myVars.autoSyncElo ? 'on' : 'off'}">
           ${myVars.autoSyncElo ? 'ON' : 'OFF'}
           </button>
           </div>

            <div class="setting-row" style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 10px; background-color: #3a3634; padding: 8px 12px; border-radius: 4px;">
                <label for="elo-rating-slider">Set Elo:</label>
                <input type="range" id="elo-rating-slider" min="300" max="3190" step="50" value="${myVars.eloRating}">
                <input type="number" id="eloManualInput" min="300" max="3190" value="${myVars.eloRating}" aria-label="Input manual rating ELO" style="width: 80px; padding: 4px;">
            </div>

            <div class="setting-row" style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 10px; background-color: #3a3634; padding: 8px 12px; border-radius: 4px;">
                <label for="custom-depth-slider">Set Depth:</label>
                <input type="range" id="custom-depth-slider" min="1" max="21" step="1" value="${myVars.customDepth}">
                <input type="number" id="custom-depth-manual" min="1" max="21" value="${myVars.customDepth}" aria-label="Input manual kedalaman hitungan" style="width: 80px; padding: 4px;">
            </div>

            <div class="setting-row" style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 10px; background-color: #3a3634; padding: 8px 12px; border-radius: 4px;">
                <label for="skillLevelSlider">Set Skill:</label>
                <input type="range" id="skillLevelSlider" min="-20" max="20" value="10" style="flex:1; cursor:pointer;" />
                <input type="number" id="skillLevelManual" min="-20" max="20" value="10" aria-label="Input manual skill level" style="width: 80px; padding: 4px;" />
            </div>

            <div class="setting-row" style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 5px; background-color: #3a3634; padding: 8px 12px; border-radius: 4px; border: 2px solid ${myVars.useSecondDelay ? '#4caf50' : '#eb6150'};">
                <label style="font-weight: bold;">Mode Fee Move:</label>
                <button type="button" id="toggleSecondDelay" class="on-off-button ${myVars.useSecondDelay ? 'on' : 'off'}">
                    ${myVars.useSecondDelay ? 'ON (Free Move)' : 'OFF (Mode Normal)'}
                </button>
            </div>

            <div class="setting-row" style="margin-top: -0px; margin-bottom: 10px; text-align: center;">
                <span style="font-size: 11px; color: #aaa;">Status saat ini: ${myVars.useSecondDelay ? 'Fokus ke Pengaturan Kedua (Free Move)' : 'Fokus ke Pengaturan Normal (Random)'}</span>
            </div>

            <div class="setting-row"
     style="display:flex; justify-content:space-between; align-items:center; margin-bottom:8px; background-color:#3a3634; padding:10px 14px; border-radius:6px; border:2px solid ${myVars.evaluationMode === 'engine' ? '#4caf50' : '#eb6150'};">

  <!-- Dropdown Level -->
  <label for="humanLevelDropdown" style="font-weight:bold; color:#fff;">Pilih Level:</label>
  <select id="humanLevelDropdown" style="margin-left:8px; padding:4px; border-radius:4px;">
    <option value="beginner">Beginner</option>
    <option value="casual">Casual</option>
    <option value="intermediate">Intermediate</option>
    <option value="advanced">Advanced</option>
    <option value="expert">Expert</option>
    <option value="personalized">Personalized</option>
    <!-- Custom akan ditambahkan otomatis oleh script -->
  </select>

  <!-- Mode Toggle -->
  <label style="font-weight:bold; color:#fff; margin-left:12px;">Auto Move Mode:</label>
  <button type="button" id="toggleEvaluationMode"
          class="on-off-button ${myVars.evaluationMode === 'engine' ? 'on' : 'off'}"
          style="margin-left:8px; padding:4px 10px; border-radius:4px; font-weight:bold;">
    ${myVars.evaluationMode === 'engine' ? 'ðŸ¤–ENGINE' : 'ðŸ§‘HUMAN'}
  </button>
</div>

<!-- Status -->
<div class="setting-row" style="margin-top:0; margin-bottom:10px; text-align:center;">
  <span id="statusEvaluationMode" style="font-size:11px; color:#aaa;">
    Status saat ini: ${myVars.evaluationMode === 'engine' ? 'Best Move' : 'Bermain Seperti Manusia / Pilihan Level Berlaku'}
  </span>
</div>

<!-- Slider ELO -->
<div class="setting-row" style="display:flex; align-items:center; justify-content:space-between; background-color:#3a3634; padding:8px 12px; border-radius:6px; margin-bottom:8px;">
  <label for="eloRatingInput" style="font-weight:bold; color:#fff;">ELO Rating:</label>
  <input type="range" id="eloRatingInput" min="800" max="2400" step="50" value="1600" style="flex:1; margin:0 10px;">
  <span id="eloRatingDisplay" style="color:#fff;">1600</span>
</div>

<!-- Slider SpeedFactor -->
<div class="setting-row" style="display:flex; align-items:center; justify-content:space-between; background-color:#3a3634; padding:8px 12px; border-radius:6px;">
  <label for="speedFactorInput" style="font-weight:bold; color:#fff;">Speed Factor:</label>
  <input type="range" id="speedFactorInput" min="0.1" max="2.0" step="0.1" value="1.0" style="flex:1; margin:0 10px;">
  <span id="speedFactorDisplay" style="color:#fff;">1.0</span>
</div>
<div style="text-align:center; font-size:11px; color:#aaa; margin-top:4px;">
  0.5 = lebih cepat, 2.0 = lebih lambat
</div>

            <div class="setting-row" style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 10px; background-color: #3a3634; padding: 8px 12px; border-radius: 4px; border: 2px solid #484848;">
                <label for="moveModeSelect" style="font-weight: bold;">Mode Gerakan Otomatis:</label>
                <select id="moveModeSelect" style="padding: 5px; border-radius: 3px; background-color: #36393f; color: white;">
                    <option value="drag">Klik Drag (Smooth)</option>
                    <option value="two-click">Klik Normal (Two-Click)</option>
                </select>
            </div>

            <div class="setting-row" style="margin-top: -0px; margin-bottom: 10px; text-align: center;">
                <span id="statusMoveMode" style="font-size: 11px; color: #aaa;">
                    Status saat ini: ${myVars.moveExecutionMode === 'drag' ? 'Klik Drag' : 'Klik Normal'}
                </span>
            </div>

            <div class="setting-row" style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 5px; background-color: #3a3634; padding: 8px 12px; border-radius: 4px; border: 2px solid ${myVars.autoRun ? '#4caf50' : '#eb6150'};">
                <label for="toggleHighlight">Highlight Best Move:</label>
                <button type="button" id="toggleHighlight" class="on-off-button ${myVars.highlightEnabled ? 'on' : 'off'}">${myVars.highlightEnabled ? 'ON' : 'OFF'}</button>
                <label for="toggleAutoRun" style="font-weight: bold;">Auto Run:</label>
                <button type="button" id="toggleAutoRun" class="on-off-button ${myVars.autoRun ? 'on' : 'off'}">${myVars.autoRun ? 'ON' : 'OFF'}</button>
            </div>

            <div class="setting-row" style="margin-top: -0px; margin-bottom: 10px; text-align: center;">
                <span id="statusAutoRun" style="font-size: 11px; color: #aaa;">
                    Status saat ini: ${myVars.autoRun ? 'Menyorot langkah terbaik' : 'Tidak menyorot langkah'}
                </span>
            </div>

            <div class="setting-row" style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 5px; background-color: #3a3634; padding: 8px 12px; border-radius: 4px; border: 2px solid ${myVars.autoMovePiece ? '#4caf50' : '#eb6150'};">
                <label for="engineSelector">Pilih Mesin Catur:</label>
                <select id="engineSelector">
                    <option value="Stockfish">Stockfish</option>
                    <option value="FairyStockfish">FairyStockfish</option>
                    <option value="Lozza Engine">Lozza Engine</option>
                </select>
                <label style="font-weight: bold;">Auto Move:</label>
                <button type="button" id="toggleAutoMove" class="on-off-button ${myVars.autoMovePiece ? 'on' : 'off'}">${myVars.autoMovePiece ? 'ON' : 'OFF'}</button>
            </div>

            <div class="setting-row" style="margin-top: -0px; margin-bottom: 10px; text-align: center;">
                <span id="statusAutoMove" style="font-size: 11px; color: #aaa;">
                    Status saat ini: ${myVars.autoMovePiece ? 'Otomatis memindahkan langkah' : 'Hanya menyorot'}
                </span>
            </div>

            <div class="setting-row" style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 5px; background-color: #3a3634; padding: 8px 12px; border-radius: 4px; border: 2px solid ${myVars.autoMatchEnabled ? '#4caf50' : '#eb6150'};">
                <label style="font-weight: bold;">Auto Match:</label>
                <button type="button" id="toggleAutoMatch" class="on-off-button ${myVars.autoMatchEnabled ? 'on' : 'off'}">${myVars.autoMatchEnabled ? 'ON' : 'OFF'}</button>
            </div>

            <div class="setting-row" style="margin-top: -0px; margin-bottom: 10px; text-align: center;">
                <span id="statusAutoMatch" style="font-size: 11px; color: #aaa;">
                    Status saat ini: ${myVars.autoMatchEnabled ? 'Membuat pertandingan baru secara otomatis' : 'Tidak membuat pertandingan baru'}
                </span>
            </div>

            <h5 style="margin-top: 20px; text-align: center;">Pengaturan Auto Resign</h5>

            <div class="setting-row" style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 10px; background-color: #3a3634; padding: 8px 12px; border-radius: 4px; border: 2px solid ${myVars.autoResignEnabled ? '#4caf50' : '#eb6150'};">
                <label for="resignThresholdInput">Batas Resign (M-):</label>
                <input type="number" id="resignThresholdInput" min="1" max="10" style="width: 60px; padding: 5px; border-radius: 3px;" value="${myVars.autoResignThreshold}" aria-label="Batas Resign Minimum (Skak Mat)">
                <label for="resignThresholdCpInput">(cP-):</label>
                <input type="number" id="resignThresholdCpInput" min="100" max="2000" step="100" style="width: 60px; padding: 5px; border-radius: 3px;" value="${myVars.autoResignThresholdCp || 500}" aria-label="Batas Resign Centipawn">
                <button type="button" id="toggleAutoResign" class="on-off-button ${myVars.autoResignEnabled ? 'on' : 'off'}">${myVars.autoResignEnabled ? 'ON' : 'OFF'}</button>
            </div>

            <div class="setting-row" style="margin-top: -0px; margin-bottom: 10px; text-align: center;">
                <span id="statusAutoResign" style="font-size: 11px; color: #aaa;">
                    Status saat ini: ${myVars.autoResignEnabled ? 'Aktif (Menyerah jika -M ' + myVars.autoResignThreshold + ', atau -cP ' + (myVars.autoResignThresholdCp || 500) + ')' : 'Nonaktif'}
                </span>
            </div>

            <div class="setting-row" style="display: flex; flex-direction: column; margin-bottom: 10px; background-color: #3a3634; padding: 10px 12px; border-radius: 6px; border: 2px solid ${myVars.clockSyncEnabled ? '#7fa650' : '#4d4d4d'}; transition: border-color 0.3s;">
                <div style="display: flex; justify-content: space-between; align-items: center;">
                    <div style="display: flex; align-items: center; padding-right: 15px; border-right: 1px solid #4d4d4d;">
                        <label style="margin-right: 10px; font-weight: bold; color: #f0f0f0; font-size: 13px;">Clock Sync:</label>
<button type="button" id="toggleClockSync" class="on-off-button ${myVars.clockSyncEnabled ? 'on' : 'off'}" style="padding: 4px 10px; border-radius: 4px; border: none; font-weight: bold; cursor: pointer; color: #fff; background-color: ${myVars.clockSyncEnabled ? '#7fa650' : '#4d4d4d'}; transition: background-color 0.2s; font-size: 12px; margin-right: 15px;">
    ${myVars.clockSyncEnabled ? 'ON' : 'OFF'}
</button>
<label for="minDelayValue" style="margin-right: 8px; font-size: 12px; color: #ddd;">Min (s):</label>
<input type="number" id="minDelayValue" name="minDelayValue" min="0.1" max="30" step="0.1" value="${myVars.clockSyncMinDelay || 1.5}" ${myVars.clockSyncEnabled ? '' : 'disabled'} style="width: 50px; padding: 4px; border-radius: 4px; border: 1px solid #555; font-size: 12px; background-color: ${myVars.clockSyncEnabled ? '#222' : '#1a1a1a'}; color: ${myVars.clockSyncEnabled ? '#fff' : '#aaa'}; text-align: center; margin-right: 10px; transition: background-color 0.3s;">
    <label for="maxDelayValue" style="margin-right: 8px; font-size: 12px; color: #ddd;">Max (s):</label>
<input type="number" id="maxDelayValue" name="maxDelayValue" min="0.1" max="30" step="0.1" value="${myVars.clockSyncMaxDelay || 5.0}" ${myVars.clockSyncEnabled ? '' : 'disabled'} style="width: 50px; padding: 4px; border-radius: 4px; border: 1px solid #555; font-size: 12px; background-color: ${myVars.clockSyncEnabled ? '#222' : '#1a1a1a'}; color: ${myVars.clockSyncEnabled ? '#fff' : '#aaa'}; text-align: center; transition: background-color 0.3s;">
    </div>
</div>
</div>

<h3 style="margin-top: 0; margin-bottom: 10px; font-size: 16px; color: #fff;">Analysa setting</h3>
<hr style="border: none; height: 2px; background-color: #4caf50; margin-top: 0;">

    <div class="setting-row mode-switch-container" id="modeSwitchContainer" style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 10px; background-color: #3a3634; padding: 8px 12px; border-radius: 4px; border: 2px solid ${myVars.analysisMode ? '#4caf50' : '#eb6150'};">
        <button type="button" id="toggleAnalysisWhite" class="analysis-color-toggle-btn white-btn ${myVars.autoAnalysisColor === 'white' ? 'is-active' : ''}" onclick="myFunctions.toggleAutoAnalysisColor('white')" aria-label="Atur analisis otomatis untuk Putih">
            <span class="icon-check">${myVars.autoAnalysisColor === 'white' ? ' ' : ''}</span> PUTIH
</button>
<button type="button" id="toggleAnalysisBlack" class="analysis-color-toggle-btn black-btn ${myVars.autoAnalysisColor === 'black' ? 'is-active' : ''}" onclick="myFunctions.toggleAutoAnalysisColor('black')" aria-label="Atur analisis otomatis untuk Hitam">
    <span class="icon-check">${myVars.autoAnalysisColor === 'black' ? ' ' : ''}</span> HITAM
</button>
<button type="button" id="toggleAnalysisNone" class="analysis-color-toggle-btn none-btn ${myVars.autoAnalysisColor === 'none' ? 'is-active' : ''}" onclick="myFunctions.toggleAutoAnalysisColor('none')" aria-label="Nonaktifkan analisis otomatis">
    MATI
</button>
<span class="control-btn" id="note-analysis-mode" title="Informasi tentang Mode Analisa" style="font-size: 14px; margin-left: 5px; cursor: pointer;">â„¹ï¸</span>
<div class="mode-switch-labels" style="display: flex; align-items: center; gap: 10px;">
    <span class="mode-label" id="engineLabel" style="color: ${myVars.analysisMode ? '#aaa' : '#fff'};"></span>
<label class="switch" for="modeToggleSetting">
    <input type="checkbox" id="modeToggleSetting" ${myVars.analysisMode ? 'checked' : ''} aria-label="Toggle antara Mode Engine dan Mode Analisa">
        <span class="slider round"></span>
</label>
<span class="mode-label" id="analysisLabel" style="color: ${myVars.analysisMode ? '#fff' : '#aaa'};">ðŸ”Analisa Mode</span>
</div>
</div>

<div class="setting-row" style="margin-top: -8px; margin-bottom: 10px; text-align: center;">
    <span id="statusAnalysisMode" style="font-size: 11px; color: #aaa;">
        Status saat ini: ${myVars.analysisMode ? 'Mode Analisa Aktif' : 'Mode Engine (Otomatis Main) Aktif'}
</span>
</div>

<div class="setting-row" style="margin-top: -8px; margin-bottom: 10px; text-align: center;">
    <span id="analysisStatusText" style="font-size: 11px; color: #aaa;">
        Status: ${myVars.autoAnalysisColor === 'none'
            ? '<span style="color: #f44336; font-weight: 500;">Mati</span>'
        : (myVars.autoAnalysisColor === 'white'
           ? '<span style="color: #64dd17; font-weight: 500;">Aktif (Egine Bermain Sebagai Putih)</span>'
           : '<span style="color: #64dd17; font-weight: 500;">Aktif (Egine Bermain Sebagai Hitam)</span>'
          )}
</span>
</div>
</div>

`,
            'main-control': () => `
        <div style="padding: 20px;">
            <h4 style="margin-top: 0; text-align: center;">Delay Settings</h4>
<h5 style="margin-top: 20px; text-align: center;">Pengaturan Delay Normal</h5>

<div class="setting-row" style=" display: flex;
justify-content: space-between;
align-items: center;
margin-bottom: 10px;
background-color: #3a3634;
padding: 8px 12px;
border-radius: 4px;">

<label for="timeDelayMin">Delay Min (s):</label>
<input type="number" id="timeDelayMin" name="timeDelayMin" min="0.1" step="0.1" value="${myVars.minDelay || 0.1}">
    </div>

<div class="setting-row" style=" display: flex;
justify-content: space-between;
align-items: center;
margin-bottom: 10px;
background-color: #3a3634;
padding: 8px 12px;
border-radius: 4px;">

<label for="timeDelayMax">Delay Max (s):</label>
<input type="number" id="timeDelayMax" name="timeDelayMax" min="0.1" step="0.1" value="${myVars.maxDelay || 5}">
    </div>

</div>
`,
            'display-setting': () => `
        <div style="padding: 20px;">
            <h4 style="margin-top: 0; text-align: center;">Display</h4>

<div style="margin-bottom: 20px;">
    <div style=" display: flex; justify-content: space-between; align-items: center; margin-bottom: 10px;">
        <label for="highlight-color1" style="font-weight: bold;">Warna Highlight Auto Run:</label>
<input type="color" id="highlight-color1" name="highlight-color1" value="${myVars.highlightColor1}" style="width: 40px; height: 30px; border: none; padding: 0;">
    </div>

<div class="color-presets-highlight" data-target="highlight-color1" style=" display: flex; justify-content: space-between; align-items: center; margin-bottom: 10px; background-color: #3a3634; padding: 8px 12px; border-radius: 4px;">
    <button type="button" class="preset-btn-highlight" data-color="#4287f5" style="background-color: #4287f5;" aria-label="Pilih Warna Biru"></button>
<button type="button" class="preset-btn-highlight" data-color="#00bcd4" style="background-color: #00bcd4;" aria-label="Pilih Warna Cyan"></button>
<button type="button" class="preset-btn-highlight" data-color="#4caf50" style="background-color: #4caf50;" aria-label="Pilih Warna Hijau"></button>
<button type="button" class="preset-btn-highlight" data-color="#eb6150" style="background-color: #eb6150;" aria-label="Pilih Warna Merah"></button>
<button type="button" class="preset-btn-highlight" data-color="#ff9800" style="background-color: #ff9800;" aria-label="Pilih Warna Oranye"></button>
<button type="button" class="preset-btn-highlight" data-color="#ffc107" style="background-color: #ffc107;" aria-label="Pilih Warna Kuning"></button>
<button type="button" class="preset-btn-highlight" data-color="#9c27b0" style="background-color: #9c27b0;" aria-label="Pilih Warna Ungu"></button>
<button type="button" class="preset-btn-highlight" data-color="#e1bee7" style="background-color: #e1bee7;" aria-label="Pilih Warna Lavender"></button>
</div>
</div>

<div style="margin-bottom: 20px;">
    <div style=" display: flex; justify-content: space-between; align-items: center; margin-bottom: 10px;">
        <label for="highlight-color2" style="font-weight: bold;">Warna Highlight Analisa Mode:</label>
<input type="color" id="highlight-color2" name="highlight-color2" value="${myVars.highlightColor2}" style="width: 40px; height: 30px; border: none; padding: 0;">
    </div>

<div class="color-presets-highlight" data-target="highlight-color2" style=" display: flex; justify-content: space-between; align-items: center; margin-bottom: 10px; background-color: #3a3634; padding: 8px 12px; border-radius: 4px;">
    <button type="button" class="preset-btn-highlight" data-color="#4287f5" style="background-color: #4287f5;" aria-label="Pilih Warna Biru"></button>
<button type="button" class="preset-btn-highlight" data-color="#00bcd4" style="background-color: #00bcd4;" aria-label="Pilih Warna Cyan"></button>
<button type="button" class="preset-btn-highlight" data-color="#4caf50" style="background-color: #4caf50;" aria-label="Pilih Warna Hijau"></button>
<button type="button" class="preset-btn-highlight" data-color="#eb6150" style="background-color: #eb6150;" aria-label="Pilih Warna Merah"></button>
<button type="button" class="preset-btn-highlight" data-color="#ff9800" style="background-color: #ff9800;" aria-label="Pilih Warna Oranye"></button>
<button type="button" class="preset-btn-highlight" data-color="#ffc107" style="background-color: #ffc107;" aria-label="Pilih Warna Kuning"></button>
<button type="button" class="preset-btn-highlight" data-color="#9c27b0" style="background-color: #9c27b0;" aria-label="Pilih Warna Ungu"></button>
<button type="button" class="preset-btn-highlight" data-color="#e1bee7" style="background-color: #e1bee7;" aria-label="Pilih Warna Lavender"></button>
</div>
</div>
</div>
`,
            'action': () => `
    <div style="padding: 20px;">
        <h4 style="margin-top: 0; text-align: center;">Actions</h4>
<div id="openingBookSettings" style="margin-bottom: 15px; padding: 12px; background-color: #3a3634; border-radius: 8px; border: 2px solid #4CAF50;">
    <h4 style="margin-top: 0; margin-bottom: 10px; text-align: center; color: #ddd; font-size: 16px;">ðŸ“š Opening Book Settings</h4>

<!-- Toggle Opening Book -->
<div class="setting-row" style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 5px; padding: 8px 12px; background-color: #3a3634; border-radius: 4px; border: 2px solid ${myVars.useOpeningBook ? '#4caf50' : '#eb6150'};">
    <label for="useOpeningBook" style="font-weight: bold; color: #ddd; font-size: 13px;">Use Opening Book:</label>
<button type="button" id="toggleOpeningBook" class="on-off-button ${myVars.useOpeningBook ? 'on' : 'off'}">
    ${myVars.useOpeningBook ? 'ON' : 'OFF'}
</button>
</div>

<!-- Status -->
<div class="setting-row" style="margin-top: -0px; margin-bottom: 10px; text-align: center;">
    <span id="openingBookStatus" style="font-size: 11px; color: #aaa;">
        Status saat ini: ${myVars.useOpeningBook ? 'Opening Book Aktif' : 'Opening Book Nonaktif'}
</span>
</div>

<div id="openingBookLoadStatus" style="font-size: 11px; color: #aaa; margin-top: 5px; margin-bottom: 10px; text-align: center;">
    Opening book not loaded. Loading...
        </div>


<!-- Current Opening Display -->
<div class="opening-display" style="margin-top: 15px; padding-top: 10px; border-top: 1px solid #4a4a4a; text-align: center;">
    <span style="font-weight: bold; color: #ddd; font-size: 14px; display: block; margin-bottom: 5px;">
        Current Opening:
</span>
<div id="currentOpeningDisplay" style="font-size: 16px; font-weight: bold; color: #1E90FF; min-height: 20px;">
    Game Start (Waiting for 1st move)
</div>
<span id="openingDisplayECO" style="font-size: 11px; color: #aaa;"></span>
</div>
</div>
</div>
</div>
`
            ,

            'top-move': () => `
        <div style="padding: 20px;">
            <h4 style="margin-top: 0;">Top Moves</h4>

<div id="opponentMoveLabel">Belum ada analisis</div>

<div id="wdl-output" style="font-size:11px;color:#C0C0C0;margin-top:5px;font-weight:bold;margin-bottom:10px;"> W: --% D: --% L: --% </div>

<div class="multi-pv-container" style="margin-bottom: 15px;">
    <div class="move-table-header" style="display: flex; justify-content: space-between; padding: 5px 0; border-bottom: 1px solid #484848; font-weight: bold; font-size: 0.9em; color: #7fa650;">
        <span class="col-move" style="width: 25%; text-align: left; padding-left: 15px;">MOVE</span>
<span class="col-eval" style="width: 75%; text-align: right; padding-right: 5px;">EVAL</span>
</div>

<div class="pv-row top-move-item" style="display: flex; align-items: center; padding: 5px 0;">
    <span class="move-rank-badge" style="width: 15%; font-weight: bold; padding-left: 5px;">1.</span>
<span id="topMove1" class="col-move" style="width: 40%;">...</span>
<span id="topMoveEval1" class="col-eval eval-equal" style="width: 45%; text-align: right; padding-right: 5px;">0.00</span>
</div>

<div class="pv-row top-move-item" style="display: flex; align-items: center; padding: 5px 0;">
    <span class="move-rank-badge" style="width: 15%; font-weight: bold; padding-left: 5px;">2.</span>
<span id="topMove2" class="col-move" style="width: 40%;">...</span>
<span id="topMoveEval2" class="col-eval eval-equal" style="width: 45%; text-align: right; padding-right: 5px;">0.00</span>
</div>

<div class="pv-row top-move-item" style="display: flex; align-items: center; padding: 5px 0;">
    <span class="move-rank-badge" style="width: 15%; font-weight: bold; padding-left: 5px;">3.</span>
<span id="topMove3" class="col-move" style="width: 40%;">...</span>
<span id="topMoveEval3" class="col-eval eval-equal" style="width: 45%; text-align: right; padding-right: 5px;">0.00</span>
</div>
</div>

<h4 style="margin-top: 20px; margin-bottom: 5px;">Average Centipawn Loss (ACPL)</h4>

<div style="display: flex; align-items: center; margin-bottom: 5px;">
    <span style="width: 50px; font-weight: bold; color: white;">W:</span>
<div id="acplBarWhiteWrapper" style="flex-grow: 1;">
    <div id="acplBarWhite" style="height: 20px; background-color: #4caf50; transition: width 0.5s; border-radius: 2px; width: 0;"></div>
</div>
</div>

<div style="display: flex; align-items: center;">
    <span style="width: 50px; font-weight: bold; color: white;">B:</span>
<div id="acplBarBlackWrapper" style="flex-grow: 1;">
    <div id="acplBarBlack" style="height: 20px; background-color: #f44336; transition: width 0.5s; border-radius: 2px; width: 0;"></div>
</div>
</div>

<div class="setting-row acpl-display-row" style="
display: flex;
justify-content: space-between;
align-items: center;
margin-top: 10px;
margin-bottom: 10px;
background-color: #3a3634;
padding: 8px 12px;
border-radius: 4px;">

<span style="font-weight: bold;">ACPL:</span>
<span id="acplTextDisplay" style="font-weight: bold; color: #C0C0C0;">W 0.00 / B 0.00</span>
<span style="margin-left: 20px;">Moves (W/B):</span>
<span style="font-weight: bold;">
    <span id="cplMoveCountWhiteDisplay" style="color: #4caf50;">0</span> /
<span id="cplMoveCountBlackDisplay" style="color: #f44336;">0</span>
</span>
</div>

<div
id="acplChartContainerWrapper"
style="
width: 100%;
height: 120px;
border: 1px solid #484848;
border-radius: 4px;
margin-top: 15px;
box-sizing: border-box;
/* --- KOREKSI WARNA BENDERA: PUTIH (ATAS) / HITAM (BAWAH) --- */
background: linear-gradient(
    to bottom,
    #FFFFFF 0%,        /* Putih dari 0% */
    #FFFFFF 50%,       /* Putih hingga 50% */
    #333333 50%,       /* Hitam mulai dari 50% */
    #333333 100%       /* Hitam hingga 100% */
);
/* -------------------------------------------------------- */
position: relative;
"
>
    <svg id="acplChartSvg" style="width: 100%; height: 100%;"></svg>
<div style="position: absolute; top: 50%; width: 100%; border-top: 1px dashed #484848; opacity: 0.8;"></div>
</div>
</div>

<div id="fenHistoryContainer" style="margin-top: 15px; border: 1px solid #484848; border-radius: 4px; padding: 10px; max-height: 200px; overflow-y: auto; background-color: #2c2927;">
    <h3 style="margin-top: 0; margin-bottom: 10px; font-size: 16px; color: #fff;">Current FEN</h3>
<div id="currentFen" style="font-size: 12px; color: #aaa; word-break: break-all;">FEN akan dimuat di sini...</div>

<h3 style="margin-top: 15px; margin-bottom: 10px; font-size: 16px; color: #fff; border-top: 1px dashed #484848; padding-top: 10px;">FEN History</h3>
<table id="fenHistoryTable" style="width: 100%; border-collapse: collapse; font-size: 12px;">
    <tbody id="fenHistoryTableBody">
        </tbody>
</table>
</div>

<div id="moveHistoryContainer" style="margin-top: 15px; border: 1px solid #484848; border-radius: 4px; padding: 10px; max-height: 200px; overflow-y: auto; background-color: #2c2927;">
    <h3 style="margin-top: 0; margin-bottom: 10px; font-size: 16px; color: #fff;">Engine Move History</h3>
<table id="moveHistoryTable" style="width: 100%; border-collapse: collapse; table-layout: fixed !important; font-size: 12px;">
    <thead>
    <tr>
    <th style="padding: 5px; border-bottom: 1px solid #484848; color: #C0C0C0; font-weight: bold; width: 10%;">No.</th>
<th style="padding: 5px; border-bottom: 1px solid #484848; color: #C0C0C0; font-weight: bold; width: 20%;">Move</th>
<th style="padding: 5px; border-bottom: 1px solid #484848; color: #C0C0C0; font-weight: bold; width: 20%;">Eval</th>
<th style="padding: 5px; border-bottom: 1px solid #484848; color: #C0C0C0; font-weight: bold; width: 15%;">Depth</th>
<th style="padding: 5px; border-bottom: 1px solid #484848; color: #C0C0C0; font-weight: bold; width: 35%;">Report</th>
</tr>
</thead>
<tbody id="moveHistoryTableBody" style="color: #ccc;">
    </tbody>
</table>
</div>
<button id="clearHistoryBtn" style="margin-top: 10px; padding: 5px 10px; background-color: #f44336; color: white; border: none; border-radius: 4px; cursor: pointer; width: 100%;">Clear History</button>

`,
            'setting': () => `
    <div style="padding: 20px;">
        <h4 style="margin-top: 0; text-align: center;">Settings</h4>
<div style="text-align: center;">
    <button type="button" id="isBut" style="padding: 10px 20px;">Got An Issue/Bug?</button>
</div>
<div class="setting-row" style="margin-top: 20px; justify-content: center;">
        <button type="button" id="relEngBut" style="padding: 10px 20px;">Reload Engine</button>
        </div>
        </div>
`,
            'Pesan-Eror': () => `
        <div id="errorTab">

        <div id="errorBoxContainer">
        <h3 style="
    margin-top:0;
margin-bottom:10px;
font-size:16px;
color:#fff;
display:flex;
align-items:center;
gap:8px;
">
<span style="font-size:18px;">ðŸ“«</span>
Error Logs
    <span
id="errorCountBadge"
style="
display:none;
background:#ff4444;
color:#fff;
border-radius:12px;
padding:2px 8px;
font-size:12px;
font-weight:600;
">
0
</span>
</h3>

<table id="errorBoxTable">
    <thead>
    <tr>
    <th style="width:20%;">Waktu</th>
<th style="width:25%;">Kategori</th>
<th style="width:55%;">Pesan & Aksi</th>
</tr>
</thead>
<tbody id="errorLogContent">
    <tr>
    <td colspan="3" style="text-align:center; padding:20px; color:#666;">
        <em>Menunggu pesan error...</em>
</td>
</tr>
</tbody>
</table>
</div>

<button
id="clearErrorBtn"
style="
margin-top:10px;
padding:8px;
background-color:#f44336;
color:white;
border:none;
border-radius:4px;
cursor:pointer;
width:100%;
font-weight:bold;
transition:opacity 0.2s;
">
Clear Error Logs
    </button>

</div>

<!-- ================= SECURITY TAB ================= -->

<div id="securityTab" style="display:none; height:100%; flex-direction:column;">

    <div style="
padding:6px 10px;
font-weight:600;
color:#ff5555;
display:flex;
align-items:center;
gap:6px;
">
ðŸ”’ Security Violations
    <span
id="securityCountBadge"
style="
display:none;
background:#ff4444;
color:#fff;
border-radius:12px;
padding:2px 8px;
font-size:12px;
font-weight:600;
">
0
</span>
</div>

<div id="securityLogContainer" style="
flex:1;
overflow-y:auto;
background:#0f0f0f;
border-top:1px solid #333;
font-family:monospace;
font-size:12px;
padding:5px;
">
<div style="color:#666; text-align:center; padding:10px;">
    Menunggu pelanggaran keamananâ€¦
        </div>
</div>

<button
id="clearSecurityBtn"
style="
background:#ff4444;
color:#fff;
border:none;
padding:6px;
cursor:pointer;
font-size:12px;
">
Clear Security Logs
    </button>

</div>
`,
            'help-tab': () => `
    <div style="padding: 10px 15px; background-color: #2c2927; border-radius: 6px; color: #f0f0f0; font-family: sans-serif;">
        <h3 style="margin-top: 0; color: #4CAF50; border-bottom: 2px solid #4CAF50; padding-bottom: 5px;">
            ðŸ“š Panduan Penggunaan Engine Assistant
                </h3>
<p style="font-size: 13px; line-height: 1.5; color: #aaa;">
    Panduan ini menjelaskan fungsi setiap tombol dan pengaturan utama di panel kontrol asisten catur Anda.
        </p>

<h4 style="color: #FFC107; margin-top: 20px;">I. Kontrol Mode Utama & ELO</h4>
<div class="guide-section">
    <table class="guide-table">
        <thead>
        <tr>
        <th style="width: 25%;">Kontrol</th>
<th style="width: 37,5%;">Deskripsi & Fungsi</th>
<th style="width: 37,5%;">Catatan</th>
</tr>
</thead>
<tbody>
    <tr>
    <td><strong>Mode (ðŸ¤–/ðŸ§‘)</strong></td>
    <td>Mengganti mode bermain/analisis mesin (Kekuatan Penuh vs. Simulasi Manusia).</td>
<td>"ENGINE:" ELO Maksimal (3190). "HUMAN:" ELO disesuaikan.</td>
</tr>
<tr>
    <td><strong>ELO Slider/Input</strong></td>
        <td>Menyetel tingkat ELO mesin (300-3190).</td>
<td>Hanya berfungsi saat "Mode ðŸ§‘HUMAN" aktif.</td>
</tr>
<tr>
    <td><strong>Depth Slider</strong></td>
        <td>Menyetel kedalaman pencarian Stockfish (misal: D21).</td>
<td>Kedalaman tinggi = langkah lebih baik, kalkulasi lebih lama.</td>
</tr>
<tr>
    <td><strong>Reload Engine</strong></td>
        <td>Memuat ulang "web worker" Stockfish.</td>
<td>Digunakan jika engine macet atau perlu diatur ulang.</td>
</tr>
</tbody>
</table>
</div>

<h4 style="color: #FFC107; margin-top: 20px;">II. Otomatisasi & Bermain (Auto Functions)</h4>
<div class="guide-section">
    <table class="guide-table">
        <tbody>
        <tr>
        <td><strong>Toggle Auto Run</strong></td>
            <td>"[ON]:" Mesin otomatis menghitung dan "menyorot" langkah terbaik di papan.</td>
<td>Mode Analisis Pasif (hanya melihat).</td>
</tr>
<tr>
    <td><strong>Toggle Auto Move</strong></td>
        <td>"[ON]:" Mesin secara otomatis "memindahkan" bidak terbaik ke papan.</td>
<td>Membutuhkan "Auto Run ON" untuk berfungsi.</td>
</tr>
<tr>
    <td><strong>Time Delay (Min/Max)</strong></td>
        <td>Mengatur rentang waktu tunggu (detik) sebelum mesin membuat langkah.</td>
<td>Digunakan untuk mensimulasikan waktu berpikir manusia.</td>
</tr>
</tbody>
</table>
</div>

<h4 style="color: #FFC107; margin-top: 20px;">III. Mode Analisis Khusus</h4>
<div class="guide-section">
    <table class="guide-table">
        <tbody>
        <tr>
        <td><strong>Analisa Mode Switch</strong></td>
            <td>"[ON]:" Engine beralih ke mode "Analysis". Semua fungsi "Auto Move" dinonaktifkan.</td>
<td>Mode terbaik untuk analisis posisi secara mendalam.</td>
</tr>
<tr>
    <td><strong>Segmented Control (Putih/Hitam/Mati)</strong></td>
        <td>Menentukan warna mana yang akan dilayani secara otomatis oleh Engine Analisis.</td>
<td>"MATI:" Menonaktifkan fitur analisis otomatis.</td>
</tr>
</tbody>
</table>
</div>

<h4 style="color: #FFC107; margin-top: 20px;">IV. Riwayat dan Logger</h4>
<div class="guide-section">
    <table class="guide-table">
        <tbody>
        <tr>
        <td><strong>Engine Move History</strong></td>
            <td>Tabel yang mencatat setiap Langkah, Evaluasi (Eval), dan Kedalaman (Depth).</td>
<td>Nilai Eval diwarnai secara dinamis (misalnya, Hijau untuk Putih Unggul).</td>
</tr>
<tr>
    <td><strong>Clear History Button</strong></td>
        <td>Menghapus semua entri dari tabel riwayat.</td>
<td>Digunakan untuk menjaga kebersihan panel.</td>
</tr>
</tbody>
</table>
</div>

<div class="disclaimer-note" style="margin-top: 20px; border: 1px solid #ffc107; border-radius: 6px; padding: 12px; background-color: #3a3634; color: #f0f0f0;">
    <h4 style="margin-top: 0; margin-bottom: 8px; color: #ffc107; font-size: 14px;">
        ðŸ’¡ Cara Kerja Level ELO Human Mode
            </h4>

<ol style="padding-left: 20px; margin: 0; font-size: 12px; line-height: 1.6;">
    <li style="margin-bottom: 5px;">
        "Fungsi Dasar:" Mode ini dirancang untuk membuat "engine" (Stockfish) bermain dengan kelemahan yang disimulasikan, sesuai dengan ELO yang Anda pilih.
            </li>
<li style="margin-bottom: 5px;">
    "Level vs. Slider:" Ketika Anda memilih Level (misalnya "Expert 2400"), "script" akan secara otomatis mengatur nilai "ELO Slider" dan variabel global (elo Rating) ke 2400.
</li>
<li style="margin-bottom: 5px;">
    "Mode 'Custom':" Jika Anda menggeser "ELO Slider" secara manual, "dropdown" akan otomatis beralih ke "Custom ELO", dan "engine" akan bermain pada nilai ELO yang Anda geser.
        </li>
<li style="margin-bottom: 5px;">
    "Perhatian Depth:" Agar ELO berfungsi secara akurat, "Depth Slider" Anda harus diatur ke nilai yang memadai (minimal "D15" atau lebih). ELO 2400 dengan Depth D1 akan tetap kalah karena "engine" tidak bisa melihat ke depan.
        </li>
<li>
        "Aktifkan Engine:" Pastikan Anda telah menekan tombol "ðŸ§‘ HUMAN Mode" agar semua pengaturan ELO dan kelemahan ("Error Rate", "Blunder Rate") diterapkan ke "engine".
            </li>
</ol>
</div>
<div class="disclaimer-note">
    <p><strong>Peringatan Penting!</strong></p>
        <p>Harap diperhatikan bahwa penggunaan dapat melanggar aturan dan menyebabkan diskualifikasi atau larangan dari turnamen dan platform online. Pengembang dan sistem terkait **TIDAK** akan dimintai pertanggung jawaban atas konsekuensi apa pun yang diakibatkan oleh penggunaannya. Kami sangat menyarankan untuk menggunakan hanya dalam lingkungan yang terkendali secara etis.</p>
</div>
</div>
<span style="font-size: 10px; color: #aaa; margin-top: 5px; font-weight: normal;">By: TikTok Bintang (500)</span>
</div>
`
    };
        // ===============================END====================================

        // ===========================================================================================================================================
        // FUNGSI setupPanelListeners (MENYIAPKAN SEMUA PENANGAN ACARA UNTUK PANEL UI KUSTOM)
        // ===========================================================================================================================================
        function setupPanelListeners() {
            // --- Navigasi Menu (Tab) ---
            document.querySelectorAll('.menu-item').forEach(item => {
                item.addEventListener('click', function () {
                    // Jika panel sedang minimize â†’ otomatis maximize
                    if (myVars.panelState === 'minimized') {
                        myFunctions.setPanelState('maximized');
                    }

                    // Atur status aktif pada menu item
                    document.querySelectorAll('.menu-item').forEach(el => el.classList.remove('active'));
                    this.classList.add('active');

                    const contentId = this.getAttribute('data-content');
                    const scrollContainer = document.getElementById('panel-content-scroll');

                    // Sembunyikan semua konten panel
                    scrollContainer.querySelectorAll('div').forEach(div => {
                        if (div.id?.startsWith('content-')) {
                            div.style.display = 'none';
                        }
                    });

                    // Tampilkan konten aktif
                    const activeContent = document.getElementById(`content-${contentId}`);
                    if (activeContent) {
                        activeContent.style.display = 'block';
                        setupContentListeners(contentId); // listener khusus konten
                    }
                });
            });

            // --- Kontrol Panel (Minimize, Maximize, Close) ---
            const panelElement = document.getElementById('chess-ui-overlay');
            if (!panelElement) return;

            document.getElementById('minimize-btn').addEventListener('click', () => {
                myFunctions.setPanelState('minimized');
            });
            document.getElementById('maximize-btn').addEventListener('click', () => {
                myFunctions.setPanelState('maximized');
            });
            document.getElementById('close-btn').addEventListener('click', () => {
                myFunctions.setPanelState('closed');
            });

            // --- Drag and Drop Panel ---
            const header = document.querySelector('.draggable-handle');
            let isDragging = false;
            let offset = { x: 0, y: 0 };

            header.addEventListener('mousedown', e => {
                isDragging = true;
                const rect = panelElement.getBoundingClientRect();

                // Pindahkan ke posisi absolut sebelum drag
                myVars.panelTop = rect.top;
                myVars.panelLeft = rect.left;
                panelElement.style.top = `${myVars.panelTop}px`;
                panelElement.style.left = `${myVars.panelLeft}px`;
                panelElement.style.transform = 'none';

                offset.x = e.clientX - rect.left;
                offset.y = e.clientY - rect.top;
                panelElement.style.cursor = 'grabbing';
                e.preventDefault();
            });

            document.addEventListener('mousemove', e => {
                if (!isDragging) return;

                let newX = e.clientX - offset.x;
                let newY = e.clientY - offset.y;

                // Boundary check
                const MIN_TOP = 5;
                const MAX_TOP = window.innerHeight - panelElement.offsetHeight - 5;
                const MIN_LEFT = 5;
                const MAX_LEFT = window.innerWidth - panelElement.offsetWidth - 5;

                if (newY < MIN_TOP) newY = MIN_TOP;
                if (newY > MAX_TOP) newY = MAX_TOP;
                if (newX < MIN_LEFT) newX = MIN_LEFT;
                if (newX > MAX_LEFT) newX = MAX_LEFT;

                panelElement.style.left = `${newX}px`;
                panelElement.style.top = `${newY}px`;
            });

            document.addEventListener('mouseup', () => {
                if (!isDragging) return;

                isDragging = false;
                panelElement.style.cursor = 'grab';

                // Simpan posisi panel ke storage
                const finalRect = panelElement.getBoundingClientRect();
                myVars.panelTop = finalRect.top;
                myVars.panelLeft = finalRect.left;

                GM_setValue('panelTop', myVars.panelTop);
                GM_setValue('panelLeft', myVars.panelLeft);
            });
            // --- Akhir Drag and Drop ---
        }
        // ===============================END====================================

        // ===========================================================================================================================================
        // FUNGSI setupContentListeners (FINAL MODIFIED VERSION - FIXED)
        // ===========================================================================================================================================
        function setupContentListeners(contentId) {
            // Definisi variabel elemen (hanya yang relevan di banyak tempat)
            const relBut = document.getElementById('relEngBut');
            const toggleHighlightButton = document.getElementById('toggleHighlight');
            const toggleAnalysisModeButton = document.getElementById('toggleAnalysisMode');
            const analyzeButton = document.getElementById('analyzeBtn');
            const isBut = document.getElementById('isBut'); // Tombol Issues

            // --- Bagian Pengaturan Utama (Engine Settings, Display Setting, Main) ---
            if (contentId === 'engine-settings' || contentId === 'display-setting' || contentId === 'main') {
                const eloSlider = document.getElementById('elo-rating-slider');
                const depthSlider = document.getElementById('custom-depth-slider');
                const eloInput = document.getElementById('eloManualInput');
                const depthInput = document.getElementById('custom-depth-manual');
                const currentEloDisplay = document.getElementById('eloValueDisplay');
                const currentDepthDisplay = document.getElementById('depthValue');
                const skillSlider = document.getElementById('skillLevelSlider');
                const skillInput = document.getElementById('skillLevelManual');
                const skillValueDisplay = document.getElementById('skillLevelValue');

                // Styling slider biar konsisten
                const sliderStyle = "width:100%;-webkit-appearance:none;height:5px;background:#464442;border-radius:5px;outline:none;";

                // Terapkan ke semua slider
                if (eloSlider) eloSlider.style.cssText = sliderStyle;
                if (depthSlider) depthSlider.style.cssText = sliderStyle;
                if (skillSlider) skillSlider.style.cssText = sliderStyle;


                // =========================================================
                // 1. CLOCK SYNC GLOBAL (Tombol ON/OFF + Input Delay) LISTENER
                // =========================================================
                const toggleClockSyncButton = document.getElementById('toggleClockSync');
                const maxDelayInput = document.getElementById('maxDelayValue');
                const minDelayInput = document.getElementById('minDelayValue');

                if (toggleClockSyncButton) {
                    const updateClockSyncUI = (isEnabled) => {
                        toggleClockSyncButton.textContent = isEnabled ? 'ON' : 'OFF';
                        toggleClockSyncButton.className = `on-off-button ${isEnabled ? 'on' : 'off'}`;
                        toggleClockSyncButton.style.backgroundColor = isEnabled ? '#7fa650' : '#4d4d4d';
                        const container = toggleClockSyncButton.closest('.setting-row');
                        if (container) {
                            container.style.borderColor = isEnabled ? '#7fa650' : '#4d4d4d';
                        }
                        [maxDelayInput, minDelayInput].forEach(input => {
                            if (input) {
                                input.disabled = !isEnabled;
                                input.style.backgroundColor = isEnabled ? '#222' : '#1a1a1a';
                                input.style.color = isEnabled ? '#fff' : '#aaa';
                            }
                        });
                    };

                    updateClockSyncUI(myVars.clockSyncEnabled);

                    $(toggleClockSyncButton).off('click.clockSync').on('click.clockSync', function() {
                        const newState = !myVars.clockSyncEnabled;
                        myVars.clockSyncEnabled = newState;
                        GM_setValue('clockSyncEnabled', newState);
                        updateClockSyncUI(newState);
                        console.log(`[ClockSync] Status diubah menjadi: ${newState ? 'AKTIF' : 'NONAKTIF'}.`);
                    });
                }

                // Fungsi untuk clear log
                document.getElementById("clearLogBtn").addEventListener("click", function() {
                    const box = document.getElementById("miniLogConsole");
                    if (box) {
                        box.innerHTML = '<div style="color:#444;">[SYSTEM] Log cleared.</div>';
                    }
                });

                // Contoh fungsi untuk update status lampu
                function setMonitorStatus(ok = true) {
                    const light = document.getElementById("monitorStatusLight");
                    if (!light) return;
                    light.style.background = ok ? "#4caf50" : "#fa3232"; // hijau atau merah
                }

                // Contoh menambahkan log baru
                function addMiniLog(msg, type = "info") {
                    const box = document.getElementById("miniLogConsole");
                    if (!box) return;

                    const t = new Date().toLocaleTimeString([], { hour:'2-digit', minute:'2-digit', second:'2-digit' });
                    const div = document.createElement("div");
                    div.style.color = type === "error" ? "#fa3232" : "#00eb9b";
                    div.textContent = `[${t}] ${msg}`;
                    box.appendChild(div);
                    box.scrollTop = box.scrollHeight;
                }

                // =========================================================
                // 1b. MAX DELAY INPUT LISTENER
                // =========================================================
                if (maxDelayInput) {
                    maxDelayInput.value = myVars.clockSyncMaxDelay || 5.0;

                    $(maxDelayInput).off('change.maxDelay').on('change.maxDelay', function() {
                        let newValue = parseFloat(this.value);
                        if (isNaN(newValue) || newValue < 0.1) newValue = 0.1;
                        if (newValue > 30) newValue = 30;

                        const minValue = myVars.clockSyncMinDelay || 1.5;
                        if (newValue < minValue) {
                            newValue = minValue;
                            console.warn(`[MaxDelay] Nilai Max dikoreksi menjadi ${newValue} karena lebih kecil dari Min Delay (${minValue}).`);
                        }

                        myVars.clockSyncMaxDelay = newValue;
                        GM_setValue('clockSyncMaxDelay', newValue);
                        this.value = newValue;
                        console.log(`[ClockSync] Max Delay diubah menjadi: ${newValue} detik.`);
                    });
                }

                // =========================================================
                // 1c. MIN DELAY INPUT LISTENER
                // =========================================================
                if (minDelayInput) {
                    minDelayInput.value = myVars.clockSyncMinDelay || 1.5;

                    $(minDelayInput).off('change.minDelay').on('change.minDelay', function() {
                        let newValue = parseFloat(this.value);
                        if (isNaN(newValue) || newValue < 0.1) newValue = 0.1;
                        if (newValue > 30) newValue = 30;

                        const maxValue = myVars.clockSyncMaxDelay || 5.0;
                        if (newValue > maxValue) {
                            newValue = maxValue;
                            console.warn(`[MinDelay] Nilai Min dikoreksi menjadi ${newValue} karena lebih besar dari Max Delay (${maxValue}).`);
                        }

                        myVars.clockSyncMinDelay = newValue;
                        GM_setValue('clockSyncMinDelay', newValue);
                        this.value = newValue;
                        console.log(`[ClockSync] Min Delay diubah menjadi: ${newValue} detik.`);
                    });
                }

                const moveModeSelect = document.getElementById('moveModeSelect');
                if (moveModeSelect) {
                    moveModeSelect.value = myVars.moveExecutionMode;
                    $(moveModeSelect).off('change').on('change', function() {
                        const newState = this.value;
                        myVars.moveExecutionMode = newState;
                        GM_setValue('moveExecutionMode', newState);
                        const statusText = newState === 'drag' ? 'Klik Drag' : 'Klik Normal';
                        $('#statusMoveMode').text('Status saat ini: ' + statusText);
                        console.log(`[Setting] Move Execution Mode diubah menjadi: ${newState}`);
                    });
                }

                const toggleAutoResign = document.getElementById('toggleAutoResign');
                if (toggleAutoResign) {
                    $(toggleAutoResign).off('click').on('click', function() {
                        const newState = !myVars.autoResignEnabled;
                        myVars.autoResignEnabled = newState;
                        GM_setValue('autoResignEnabled', newState);

                        const cpThreshold = myVars.autoResignThresholdCp || 500;
                        const statusText = newState
                        ? `Aktif (Menyerah jika -M${myVars.autoResignThreshold}, atau -cP${cpThreshold})`
                    : 'Nonaktif';

                        $(this).text(newState ? 'ON' : 'OFF').toggleClass('on', newState).toggleClass('off', !newState);
                        $(this).closest('.setting-row').css('border-color', newState ? '#4caf50' : '#eb6150');
                        $('#statusAutoResign').text('Status saat ini: ' + statusText);

                        $('#resignThresholdInput').prop('disabled', !newState);
                        $('#resignThresholdCpInput').prop('disabled', !newState);
                    });
                }

                const updateResignStatusDisplay = () => {
                    const cpThreshold = myVars.autoResignThresholdCp || 500;
                    const statusText = `Aktif (Menyerah jika -M${myVars.autoResignThreshold}, atau -cP${cpThreshold})`;
                    $('#statusAutoResign').text('Status saat ini: ' + statusText);
                };


                const resignThresholdInput = document.getElementById('resignThresholdInput');
                if (resignThresholdInput) {
                    resignThresholdInput.value = myVars.autoResignThreshold;
                    $(resignThresholdInput).prop('disabled', !myVars.autoResignEnabled);
                    $(resignThresholdInput).off('change').on('change', function() {
                        const value = parseInt($(this).val());
                        if (!isNaN(value) && value >= 1 && value <= 10) {
                            myVars.autoResignThreshold = value;
                            GM_setValue('autoResignThreshold', value);
                            updateResignStatusDisplay();
                        } else {
                            $(this).val(myVars.autoResignThreshold);
                            alert("Batas Resign (M-) harus antara 1 dan 10.");
                        }
                    });
                }

                const resignThresholdCpInput = document.getElementById('resignThresholdCpInput');
                if (resignThresholdCpInput) {
                    resignThresholdCpInput.value = myVars.autoResignThresholdCp || 500;
                    $(resignThresholdCpInput).prop('disabled', !myVars.autoResignEnabled);
                    $(resignThresholdCpInput).off('change').on('change', function() {
                        const value = parseInt($(this).val());
                        if (!isNaN(value) && value >= 100 && value <= 2000) {
                            myVars.autoResignThresholdCp = value;
                            GM_setValue('autoResignThresholdCp', value);
                            updateResignStatusDisplay();
                        } else {
                            $(this).val(myVars.autoResignThresholdCp || 500);
                            alert("Batas Resign (cP-) harus antara 100 dan 2000.");
                        }
                    });
                }

                // ===========================================================================
                // Masukkan ini di dalam setupContentListeners (blok engine-settings)
                // ===========================================================================

                const toggleAutoSyncEloBtn = document.getElementById('toggleAutoSyncElo');
                if (toggleAutoSyncEloBtn) {
                    $(toggleAutoSyncEloBtn).off('click').on('click', function() {
                        const newState = !myVars.autoSyncElo;
                        myVars.autoSyncElo = newState;
                        GM_setValue('autoSyncElo', newState);

                        // Update Visual Tombol
                        $(this).text(newState ? 'ON' : 'OFF')
                            .toggleClass('on', newState)
                            .toggleClass('off', !newState);

                        // Update Border Row
                        $(this).closest('.setting-row').css('border-color', newState ? '#4caf50' : '#eb6150');

                        console.log(`[ELO Sync] Fitur sekarang: ${newState ? 'AKTIF' : 'NONAKTIF'}`);

                        // Opsional: Jika dimatikan, pastikan engine tahu kita pakai manual depth sekarang
                        if (!newState) {
                            const currentManualDepth = myVars.customDepth || 1;
                            console.log(`[ELO Sync] Beralih ke Manual. Menggunakan Custom Depth: ${currentManualDepth}`);
                            if (myFunctions.setCustomDepth) myFunctions.setCustomDepth(currentManualDepth);
                        }
                    });
                }

                // ===========================================================================
                // PERBAIKAN UTAMA DI SINI (Alias Kompatibilitas)
                // ===========================================================================
                myFunctions.getAdjustedDepth = function(elo) {
                    // LOGIKA BARU: Cek dulu apakah Auto Sync aktif?
                    if (myVars.autoSyncElo) {
                        // Jika ON: Hitung depth berdasarkan ELO
                        const { depth } = myFunctions.calculateDepthAndSkillFromElo(elo);
                        return depth;
                    } else {
                        // Jika OFF: Gunakan nilai manual yang diinput user (customDepth)
                        // Jika customDepth belum ada, default ke 1
                        return myVars.customDepth || 1;
                    }
                };

                // =========================================================
                // 2. Sinkronisasi ELO Slider (hanya aktif jika AutoSyncElo ON)
                // =========================================================
                if (eloSlider && currentEloDisplay && eloInput) {
                    $(eloSlider).off('input').on('input', (e) => {
                        const newElo = parseInt(e.target.value, 10);
                        myVars.eloRating = newElo;

                        currentEloDisplay.innerText = newElo;
                        eloInput.value = newElo;
                        GM_setValue('eloRating', newElo);

                        if (myVars.autoSyncElo) {
                            const { depth, skill } = myFunctions.calculateDepthAndSkillFromElo(newElo);
                            myFunctions.updateDepthUI(depth);

                            if (skillSlider) {
                                skillSlider.value = skill;
                                skillSlider.dispatchEvent(new Event('input', { bubbles: true }));
                            }
                            if (skillInput) skillInput.value = skill;
                            if (skillValueDisplay) skillValueDisplay.textContent = skill;
                            myVars.skillLevel = skill;
                            GM_setValue('skillLevel', skill);

                            myFunctions.setEngineLevel(skill);
                        }
                    });
                }

                // =========================================================
                // 3. Sinkronisasi ELO Input Manual (hanya aktif jika AutoSyncElo ON)
                // =========================================================
                if (eloInput && eloSlider && currentEloDisplay) {
                    $(eloInput).off('change').on('change', function() {
                        const newElo = parseInt(this.value, 10);
                        const storedElo = GM_getValue('eloRating', 300);

                        if (!isNaN(newElo) && newElo >= 300 && newElo <= 3190) {
                            myVars.eloRating = newElo;
                            eloSlider.value = newElo;
                            eloSlider.dispatchEvent(new Event('input', { bubbles: true }));
                            currentEloDisplay.textContent = newElo;
                            this.value = newElo;
                            GM_setValue('eloRating', newElo);

                            if (myVars.autoSyncElo) {
                                const { depth, skill } = myFunctions.calculateDepthAndSkillFromElo(newElo);
                                myFunctions.updateDepthUI(depth);

                                if (skillSlider) {
                                    skillSlider.value = skill;
                                    skillSlider.dispatchEvent(new Event('input', { bubbles: true }));
                                }
                                if (skillInput) skillInput.value = skill;
                                if (skillValueDisplay) skillValueDisplay.textContent = skill;
                                myVars.skillLevel = skill;
                                GM_setValue('skillLevel', skill);

                                myFunctions.setEngineLevel(skill);
                            }
                        } else {
                            this.value = storedElo;
                            eloSlider.value = storedElo;
                            eloSlider.dispatchEvent(new Event('input', { bubbles: true }));
                            currentEloDisplay.textContent = storedElo;
                            alert("Rentang ELO harus antara 300 dan 3190!");
                        }
                    });
                }

                // =========================================================
                // 4. Sinkronisasi Depth Slider (Manual Mode)
                // =========================================================
                if (depthSlider && currentDepthDisplay && depthInput) {
                    $(depthSlider).off('input').on('input', (e) => {
                        const newValue = parseInt(e.target.value, 10);
                        if (isNaN(newValue)) return;

                        myVars.customDepth = newValue; // Simpan ke variabel global
                        currentDepthDisplay.textContent = newValue;
                        depthInput.value = newValue;
                        GM_setValue('customDepth', newValue);

                        // Langsung paksa update jika tersedia
                        if (myFunctions.setCustomDepth) {
                            myFunctions.setCustomDepth(newValue);
                        } else if (myFunctions.updateDepth) {
                            myFunctions.updateDepth(newValue);
                        }

                        console.log(`[Manual Depth Slider] Set ke: ${newValue}`);
                    });
                }

                // =========================================================
                // 5. Sinkronisasi Depth Input Manual (Manual Mode)
                // =========================================================
                if (depthInput && depthSlider && currentDepthDisplay) {
                    $(depthInput).off('change').on('change', function() {
                        const value = parseInt(this.value, 10);
                        const minVal = 1;
                        const maxVal = 21; // Pastikan maxVal sesuai engine Anda (biasanya 20-30)
                        const storedDepth = GM_getValue('customDepth', 1);

                        if (!isNaN(value) && value >= minVal && value <= maxVal) {
                            // Update Variable Penting
                            myVars.customDepth = value;
                            GM_setValue('customDepth', value);

                            // Update UI
                            depthSlider.value = value;
                            depthSlider.dispatchEvent(new Event('input', { bubbles: true }));
                            currentDepthDisplay.textContent = value;
                            this.value = value;

                            console.log(`[Manual Depth Input] Set ke: ${value}`);

                            // Panggil fungsi engine
                            if (myFunctions.setCustomDepth) {
                                myFunctions.setCustomDepth(value);
                            } else if (myFunctions.updateDepth) {
                                myFunctions.updateDepth(value);
                            } else if (myFunctions.updateDepthUI) {
                                // Fallback: kadang updateDepthUI juga mengatur variabel engine
                                myFunctions.updateDepthUI(value);
                            }
                        } else {
                            // Revert jika invalid
                            this.value = storedDepth;
                            depthSlider.value = storedDepth;
                            depthSlider.dispatchEvent(new Event('input', { bubbles: true }));
                            currentDepthDisplay.textContent = storedDepth;
                            alert(`Rentang Depth harus antara ${minVal} dan ${maxVal}!`);
                        }
                    });
                }

                // =========================================================
                // Sinkronisasi Skill Level
                // =========================================================
                if (skillSlider && skillInput && skillValueDisplay) {
                    $(skillSlider).off('input').on('input', (e) => {
                        const newValue = parseInt(e.target.value, 10);
                        if (isNaN(newValue)) return;
                        skillInput.value = newValue;
                        skillValueDisplay.textContent = newValue;
                        myVars.skillLevel = newValue;
                        GM_setValue('skillLevel', newValue);
                        myFunctions.setEngineLevel(newValue);
                    });

                    $(skillInput).off('change').on('change', function() {
                        let value = parseInt(this.value, 10);
                        const minVal = 0, maxVal = 20;
                        const storedSkill = GM_getValue('skillLevel', 10);
                        if (!isNaN(value) && value >= minVal && value <= maxVal) {
                            skillSlider.value = value;
                            skillSlider.dispatchEvent(new Event('input', { bubbles: true }));
                            skillValueDisplay.textContent = value;
                            myVars.skillLevel = value;
                            GM_setValue('skillLevel', value);
                            myFunctions.setEngineLevel(value);
                        } else {
                            this.value = storedSkill;
                            skillSlider.value = storedSkill;
                            skillSlider.dispatchEvent(new Event('input', { bubbles: true }));
                            skillValueDisplay.textContent = storedSkill;
                            alert(`Skill Level harus antara ${minVal} dan ${maxVal}!`);
                        }
                    });
                }

                // =========================================================
                // INISIALISASI
                // =========================================================
                function initSliders() {
                    if (typeof myVars === 'undefined') return;

                    // 1. ELO Slider
                    if (eloSlider) {
                        const initElo = myVars.eloRating || GM_getValue('eloRating', 300);
                        eloSlider.value = initElo;
                        eloSlider.dispatchEvent(new Event('input', { bubbles: true }));
                    }

                    // 2. Depth Slider (Pastikan myVars.customDepth terisi)
                    if (depthSlider) {
                        const initDepth = GM_getValue('customDepth', 1);
                        myVars.customDepth = initDepth; // Pastikan variable global terisi saat load
                        depthSlider.value = initDepth;
                        depthSlider.dispatchEvent(new Event('input', { bubbles: true }));
                    }

                    // 3. Skill Level Slider
                    if (skillSlider) {
                        const initSkill = myVars.skillLevel || GM_getValue('skillLevel', 10);
                        skillSlider.value = initSkill;
                        skillSlider.dispatchEvent(new Event('input', { bubbles: true }));
                    }
                }

                $(document).ready(() => {
                    initSliders();
                });

                // =========================================================
                // Fungsi Handler untuk Mengubah Status Analysis Mode
                // =========================================================
                const handleAnalysisModeToggle = (newState) => {
                    myVars.analysisMode = newState;
                    GM_setValue('analysisMode', newState);

                    // Highlight mengikuti Analysis Mode
                    const highlightNewState = newState;
                    myVars.highlightEnabled = highlightNewState;
                    GM_setValue('highlightEnabled', highlightNewState);
                    $('#toggleHighlight').text(highlightNewState ? 'ON' : 'OFF')
                        .toggleClass('on', highlightNewState).toggleClass('off', !highlightNewState)
                        .closest('.setting-row').css('border-color', highlightNewState ? '#4caf50' : '#eb6150');
                    $('#statusHighlight').text('Status saat ini: ' + (highlightNewState ? 'Menampilkan Sorotan' : 'Menyembunyikan Sorotan'));

                    // AutoRun, AutoMove, AutoMatch berlawanan dengan Analysis Mode
                    const autoRunNewState = !newState;
                    myVars.autoRun = autoRunNewState;
                    GM_setValue('autoRun', autoRunNewState);
                    $('#toggleAutoRun').text(autoRunNewState ? 'ON' : 'OFF')
                        .toggleClass('on', autoRunNewState).toggleClass('off', !autoRunNewState)
                        .closest('.setting-row').css('border-color', autoRunNewState ? '#4caf50' : '#eb6150');
                    $('#statusAutoRun').text('Status saat ini: ' + (autoRunNewState ? 'Menyorot langkah terbaik' : 'Tidak menyorot langkah'));

                    const autoMoveNewState = !newState;
                    myVars.autoMovePiece = autoMoveNewState;
                    GM_setValue('autoMovePiece', autoMoveNewState);
                    $('#toggleAutoMove').text(autoMoveNewState ? 'ON' : 'OFF')
                        .toggleClass('on', autoMoveNewState).toggleClass('off', !autoMoveNewState)
                        .closest('.setting-row').css('border-color', autoMoveNewState ? '#4caf50' : '#eb6150');
                    $('#statusAutoMove').text('Status saat ini: ' + (autoMoveNewState ? 'Otomatis memindahkan langkah' : 'Hanya menyorot'));

                    const autoMatchNewState = !newState;
                    myVars.autoMatchEnabled = autoMatchNewState;
                    GM_setValue('autoMatchEnabled', autoMatchNewState);
                    $('#toggleAutoMatch').text(autoMatchNewState ? 'ON' : 'OFF')
                        .toggleClass('on', autoMatchNewState).toggleClass('off', !autoMatchNewState)
                        .closest('.setting-row').css('border-color', autoMatchNewState ? '#4caf50' : '#eb6150');
                    $('#statusAutoMatch').text('Status saat ini: ' + (autoMatchNewState ? 'Membuat pertandingan baru secara otomatis' : 'Tidak membuat pertandingan baru'));

                    // Status Analysis Mode
                    $('#modeToggleSetting').prop('checked', newState)
                        .closest('.setting-row.mode-switch-container').css('border-color', newState ? '#4caf50' : '#eb6150');
                    $('#statusAnalysisMode').text('Status saat ini: ' + (newState ? 'Mode Analisa Aktif' : 'Mode Engine (Otomatis Main) Aktif'));

                    if ($('#toggleAnalysisMode').length) {
                        $('#toggleAnalysisMode').text(newState ? 'ON' : 'OFF')
                            .toggleClass('on', newState).toggleClass('off', !newState)
                            .closest('.setting-row').css('border-color', newState ? '#4caf50' : '#eb6150');
                    }

                    // Jalankan / hentikan mesin analisis + sinkronisasi AutoRun
                    if (newState) {
                        // Analysis Mode ON â†’ matikan AutoRun
                        myFunctions.disableAutoRun();
                        myFunctions.loadAnalysisEngine();
                        myFunctions.runAnalysisMode(myVars.customDepth || 25);
                    } else {
                        // Analysis Mode OFF â†’ hidupkan AutoRun lagi
                        if (myVars.analysisEngine) {
                            myVars.analysisEngine.terminate();
                            myVars.analysisEngine = null;
                            myFunctions.clearHighlights();
                        }
                        myFunctions.enableAutoRun();
                    }
                };
                // =========================================================
                // Listener: Toggle Analysis Mode (Switch)
                // =========================================================
                $('#modeToggleSetting').off('change').on('change', function() {
                    const newState = $(this).is(':checked');
                    handleAnalysisModeToggle(newState);
                });

                // =========================================================
                // Listener: Toggle Analysis Mode (Button)
                // =========================================================
                if (toggleAnalysisModeButton) {
                    $(toggleAnalysisModeButton).off('click').on('click', function() {
                        const newState = !myVars.analysisMode;
                        handleAnalysisModeToggle(newState);
                    });
                }

                // Listener: Toggle Opening Book
                $('#toggleOpeningBook').off('click').on('click', function() {
                    const button = $(this);
                    myVars.useOpeningBook = !myVars.useOpeningBook;
                    GM_setValue('useOpeningBook', myVars.useOpeningBook);

                    const displayStatusText = $('#openingBookStatus');
                    const settingRow = button.closest('.setting-row');
                    const loadStatus = $('#openingBookLoadStatus');

                    if (myVars.useOpeningBook) {
                        button.text('ON').removeClass('off').addClass('on');
                        settingRow.css('border-color', '#4caf50');
                        displayStatusText.text('Status saat ini: Opening Book Aktif');
                        loadStatus.html('Opening book not loaded. Loading...');

                        if (typeof myFunctions !== 'undefined' && myFunctions.fetchOpeningBook) {
                            myFunctions.fetchOpeningBook().then(data => {
                                if (myVars.useOpeningBook) {
                                    if (data) {
                                        loadStatus.html(`<span style="color:#7fa650;">âœ“ Book Loaded (${Object.keys(data).length} positions)</span>`);
} else {
    loadStatus.html(`<span style="color:#eb6150;">X Failed to load book. Using Engine.</span>`);
}
}
});
}

} else {
    button.text('OFF').removeClass('on').addClass('off');
    settingRow.css('border-color', '#eb6150');
    displayStatusText.text('Status saat ini: Opening Book Nonaktif');
    loadStatus.html('Disabled.');
}

$('#openingRepertoire').prop('disabled', !myVars.useOpeningBook);
$('#maxOpeningBookMoves').prop('disabled', !myVars.useOpeningBook);
console.log(`[Opening Book] Use Opening Book set to: ${myVars.useOpeningBook}`);
});

// Listener: Dropdown Repertoire Opening Book
$('#openingRepertoire').off('change').on('change', function() {
    myVars.selectedOpeningRepertoire = $(this).val();
    GM_setValue('selectedOpeningRepertoire', myVars.selectedOpeningRepertoire);
    console.log(`[Opening Book] Repertoire set to: ${myVars.selectedOpeningRepertoire}`);
});

// Listener: Input Max Moves Opening Book
$('#maxOpeningBookMoves').off('change').on('change', function() {
    const value = parseInt($(this).val());
    if (!isNaN(value) && value > 0) {
        myVars.maxOpeningBookMoves = value;
        GM_setValue('maxOpeningBookMoves', myVars.maxOpeningBookMoves);
        console.log(`[Opening Book] Max moves set to: ${myVars.maxOpeningBookMoves}`);
    } else {
        $(this).val(myVars.maxOpeningBookMoves);
    }
});

// Listener: Toggle Evaluation Mode (Engine vs Human)
$('#toggleEvaluationMode').off('click').on('click', function() {
    const newState = myVars.evaluationMode === 'engine' ? 'human' : 'engine';
    myVars.evaluationMode = newState;
    GM_setValue('evaluationMode', newState);

    // Panggil fungsi sinkronisasi UI
    syncAutoMoveUI(newState);

    const currentLevel = $('#humanLevelDropdown').val(); // Ambil langsung dari dropdown
    const currentElo = parseInt($('#eloRatingInput').val());

    // Eksekusi Logika Berdasarkan Mode
    if (newState === 'human') {
        if (typeof myFunctions.setHumanMode === 'function') {
            myFunctions.setHumanMode(currentLevel);
        }
        // Opsional: Matikan slider ELO secara visual jika sedang mode Human
        $('#eloRatingInput').css('opacity', '0.5');
    } else {
        if (typeof myFunctions.setEngineElo === 'function') {
            // Gunakan nilai slider ELO atau default tinggi jika ingin "Best Move"
            myFunctions.setEngineElo(currentElo);
        }
        $('#eloRatingInput').css('opacity', '1');
    }

    console.log(`[Setting] Mode: ${newState}, Level: ${currentLevel}, ELO: ${currentElo}`);
    if (typeof myFunctions.updateEngineLeds === 'function') myFunctions.updateEngineLeds();
});

// Fungsi Sinkronisasi UI agar konsisten
function syncAutoMoveUI(mode) {
    const isEngine = mode === 'engine';
    const btn = $('#toggleEvaluationMode');
    const statusText = isEngine ? 'Best Move' : 'Bermain Seperti Manusia / Pilihan Level Berlaku';

    // Update Tombol
    btn.text(isEngine ? 'ðŸ¤–ENGINE' : 'ðŸ§‘HUMAN')
        .toggleClass('on', isEngine)
        .toggleClass('off', !isEngine);

    // Update Border Parent
    btn.closest('.setting-row').css('border-color', isEngine ? '#4caf50' : '#eb6150');

    // Update Teks Status
    $('#statusEvaluationMode').text('Status saat ini: ' + statusText);
}

// Tambahan: Listener untuk Slider ELO agar teks di sampingnya berubah saat digeser
$('#eloRatingInput').on('input', function() {
    const val = $(this).val();
    $('#eloRatingDisplay').text(val);

    // Jika sedang mode Engine, langsung update kekuatannya
    if (myVars.evaluationMode === 'engine' && typeof myFunctions.setEngineElo === 'function') {
        myFunctions.setEngineElo(parseInt(val));
    }
});

// Tambahan: Listener untuk Speed Factor
$('#speedFactorInput').on('input', function() {
    const val = $(this).val();
    $('#speedFactorDisplay').text(val);
    myVars.speedFactor = parseFloat(val);
    GM_setValue('speedFactor', myVars.speedFactor);
});

// Tambahan: Listener untuk Dropdown Level
$('#humanLevelDropdown').on('change', function() {
    const level = $(this).val();
    if (myVars.evaluationMode === 'human' && typeof myFunctions.setHumanMode === 'function') {
        myFunctions.setHumanMode(level);
    }
});

// Listener: Toggle Auto Run (Highlight Best Move)
$('#toggleAutoRun').off('click').on('click', function() {
    const newState = !myVars.autoRun;
    myVars.autoRun = newState;
    GM_setValue('autoRun', newState);

    const statusText = newState ? 'Menyorot langkah terbaik' : 'Tidak menyorot langkah';
    $(this).text(newState ? 'ON' : 'OFF');
    $(this).toggleClass('on', newState).toggleClass('off', !newState);
    $(this).closest('.setting-row').css('border-color', newState ? '#4caf50' : '#eb6150');
    $('#statusAutoRun').text('Status saat ini: ' + statusText);

    // ðŸ”¥ Integrasi dengan fungsi kontrol penuh
    if (newState) {
        myFunctions.enableAutoRun(); // hidupkan semua observer/timer
    } else {
        myFunctions.disableAutoRun(); // matikan semua observer/timer
    }

    myFunctions.updateAutoRunStatus(
        ENGINE_STATUS1.OFF,
        'GAME_OVER'
    );
});


// Listener: Toggle Auto Move Piece
$('#toggleAutoMove').off('click').on('click', function() {
    const newState = !myVars.autoMovePiece;
    myVars.autoMovePiece = newState;
    GM_setValue('autoMovePiece', newState);
    const statusText = newState ? 'Otomatis memindahkan langkah' : 'Hanya menyorot';
    $(this).text(newState ? 'ON' : 'OFF');
    $(this).toggleClass('on', newState).toggleClass('off', !newState);
    $(this).closest('.setting-row').css('border-color', newState ? '#4caf50' : '#eb6150');
    $('#statusAutoMove').text('Status saat ini: ' + statusText);
});

// Listener: Toggle Auto Match
$('#toggleAutoMatch').off('click').on('click', function() {
    const newState = !myVars.autoMatchEnabled;
    myVars.autoMatchEnabled = newState;
    GM_setValue('autoMatchEnabled', newState);
    const statusText = newState ? 'Membuat pertandingan baru secara otomatis' : 'Tidak membuat pertandingan baru';
    $(this).text(newState ? 'ON' : 'OFF');
    $(this).toggleClass('on', newState).toggleClass('off', !newState);
    $(this).closest('.setting-row').css('border-color', newState ? '#4caf50' : '#eb6150');
    $('#statusAutoMatch').text('Status saat ini: ' + statusText);
});

// Listener: Toggle Analysis Mode (Switch)
$('#modeToggleSetting').off('change').on('change', function() {
    const newState = $(this).is(':checked');
    handleAnalysisModeToggle(newState);
});

// Listener: Toggle Analysis Mode (Button)
if (toggleAnalysisModeButton) {
    $(toggleAnalysisModeButton).off('click').on('click', function() {
        const newState = !myVars.analysisMode;
        handleAnalysisModeToggle(newState);
    });
}

// Listener: Analyze Button (Manual)
if (analyzeButton) {
    $(analyzeButton).off('click').on('click', myFunctions.analyze);
}

// Listener: Reload Engine Button (Juga ada di bagian lain, tapi penting di sini)
if (relBut) {
    $(relBut).off('click').on('click', myFunctions.reloadChessEngine);
}
}

// --- Bagian Info Modal ---

// Tombol Info Human Mode
const eloHumanInfoBtn = document.getElementById('note-elo-human');
if (eloHumanInfoBtn) {
    eloHumanInfoBtn.removeAttribute('title');
    $(eloHumanInfoBtn).off('click').on('click', function() {
        myFunctions.showHumanModeInfoModal();
        myFunctions.setupVirtualBoardObserver();
        myFunctions.updateVirtualChessboard();
    });
    console.log("Human Mode Info button listener attached.");
}

// Tombol Info Analysis Mode
const analysisInfoBtn = document.getElementById('note-analysis-mode');
if (analysisInfoBtn) {
    analysisInfoBtn.removeAttribute('title');
    $(analysisInfoBtn).off('click').on('click', function() {
        myFunctions.showAnalysisModeInfoModal();
    });
    console.log("Analysis Mode Info button listener attached.");
}

// --- Bagian Pengaturan Delay (Main Control, Main, Engine Settings) ---
if (contentId === 'main-control' || contentId === 'main' || contentId === 'engine-settings') {
    const timeDelayMin = document.getElementById('timeDelayMin');
    const timeDelayMax = document.getElementById('timeDelayMax');

    // Input Min Delay (Mode Normal)
    if (timeDelayMin) {
        $(timeDelayMin).off('input').on('input', (e) => {
            const value = parseFloat(e.target.value);
            if (!isNaN(value)) {
                myVars.minDelay = value;
                GM_setValue('minDelay', value);
            }
        });
    }

    // Input Max Delay (Mode Normal)
    if (timeDelayMax) {
        $(timeDelayMax).off('input').on('input', (e) => {
            const value = parseFloat(e.target.value);
            if (!isNaN(value)) {
                myVars.maxDelay = value;
                GM_setValue('maxDelay', value);
            }
        });
    }


    // Toggle Second Delay / Free Move Mode
    $('#toggleSecondDelay').off('click').on('click', function() {
        const newState = !myVars.useSecondDelay;
        myVars.useSecondDelay = newState;
        GM_setValue('useSecondDelay', newState);

        $(this).text(newState ? 'ON (Free Move)' : 'OFF (Mode Normal)');
        $(this).toggleClass('on', newState).toggleClass('off', !newState);
        $(this).closest('.setting-row').css('border-color', newState ? '#4caf50' : '#eb6150');

        const statusText = newState ? 'Dalam Keadaan Mode Free Move' : 'Dalam Keadaan Mode Normal';
        // Mencari elemen status display (asumsi di bawah setting-row)
        const statusDisplay = $(this).closest('.setting-row').parent().find('#statusSecondDelay');
        if (statusDisplay.length) {
            statusDisplay.text('Status saat ini: ' + statusText);
        }
    });

    // Input Min Delay (Mode Free Move)
    $('#timeDelayMinTwo').off('change').on('change', function() {
        const val = parseFloat($(this).val()) || 0.1;
        myVars.minDelayTwo = val;
        GM_setValue('minDelayTwo', val);
        $(this).val(val);
    });

    // Input Max Delay (Mode Free Move)
    $('#timeDelayMaxTwo').off('change').on('change', function() {
        const val = parseFloat($(this).val()) || 0.1;
        myVars.maxDelayTwo = val;
        GM_setValue('maxDelayTwo', val);
        $(this).val(val);
    });
}

// --- Bagian Pengaturan Tampilan (Display Setting, Main, Engine Settings) ---
if (contentId === 'display-setting' || contentId === 'main' || contentId === 'engine-settings') {
    const highlightColor1 = document.getElementById('highlight-color1');
    const highlightColor2 = document.getElementById('highlight-color2');
    const toggleHighlightButton = document.getElementById('toggleHighlight'); // âœ… definisikan tombol

    // Input Warna Sorotan 1
    if (highlightColor1) {
        $('#highlight-color1').off('input').on('input', (e) => {
            const color = e.target.value;
            myVars.highlightColor1 = color;
            GM_setValue('highlightColor1', color);
        });
    }

    // Input Warna Sorotan 2
    if (highlightColor2) {
        $('#highlight-color2').off('input').on('input', (e) => {
            const color = e.target.value;
            myVars.highlightColor2 = color;
            GM_setValue('highlightColor2', color);
        });
    }

    // Tombol Preset Warna Sorotan
    $('.preset-btn-highlight').off('click').on('click', function(e) {
        const targetDiv = e.target.closest('.color-presets-highlight');
        if (!targetDiv) return;

        const targetId = targetDiv.dataset.target;
        const color = e.target.dataset.color;

        if (targetId === 'highlight-color1') {
            myVars.highlightColor1 = color;
            GM_setValue('highlightColor1', myVars.highlightColor1);
            highlightColor1.value = color;
        } else if (targetId === 'highlight-color2') {
            myVars.highlightColor2 = color;
            GM_setValue('highlightColor2', myVars.highlightColor2);
            highlightColor2.value = color;
        }
    });

    // Toggle Sorotan
    if (toggleHighlightButton) {
        $(toggleHighlightButton).off('click').on('click', myFunctions.toggleHighlight);
    }
}

// ===========================================================================
// âš™ï¸ TOGGLE HIGHLIGHT BEST MOVE
// ===========================================================================
myFunctions.toggleHighlight = function() {
    myVars.highlightEnabled = !myVars.highlightEnabled;
    GM_setValue('highlightEnabled', myVars.highlightEnabled);

    const btn = document.getElementById('toggleHighlight');
    if (btn) {
        btn.textContent = myVars.highlightEnabled ? 'ON' : 'OFF';
        btn.classList.toggle('on', myVars.highlightEnabled);
        btn.classList.toggle('off', !myVars.highlightEnabled);
    }

    const statusEl = document.getElementById('statusHighlight');
    if (statusEl) {
        statusEl.textContent = 'Status saat ini: ' + (myVars.highlightEnabled ? 'Highlight aktif' : 'Highlight nonaktif');
    }

    console.log('[Highlight] Highlight Best Move ' + (myVars.highlightEnabled ? 'diaktifkan' : 'dimatikan'));
};


// --- Bagian Top Move / History ---
if (contentId === 'top-move') {
    const clearHistoryBtn = document.getElementById('clearHistoryBtn');
    if (clearHistoryBtn) {
        $(clearHistoryBtn).off('click').on('click', myFunctions.clearMoveHistory);
        console.log("Clear History button listener attached.");
    }
}

// --- Bagian Setting (Umum) ---
if (isBut) {
    $(isBut).off('click').on('click', () => {
        const confirmed = window.confirm('Can I take you to the issues page?');
        if (confirmed) {
            window.location.href = 'https://github.com/Auzgame/userscripts/issues';
        } else {
            console.log('User canceled navigation to issues page.');
        }
    });

    // Reload Engine
    if (relBut) {
        $(relBut).off('click').on('click', () => {
            if (myVars.isActuallyLoading) {
                console.log("[Engine] Reload dibatalkan: engine sedang loading.");
                return;
            }
            myFunctions.reloadChessEngine();
        });
    }
}
}
// ===============================END====================================

// ===========================================================================================================================================
//
// ===========================================================================================================================================
myFunctions.loadEx = function(){
    try{
        board = $('chess-board')[0] || $('wc-chess-board')[0];
        if (!board) {
            console.log('Chess board not found. Retrying...');
            return;
        }

        myVars.board = board;

        if (document.getElementById('chess-ui-overlay')) {
            myFunctions.cleanupListeners();
            myFunctions.updateBoardColors();
            myFunctions.setPanelState(myVars.panelState);
            return;
        }

        const overlayContainer = document.createElement('div');
        overlayContainer.id = 'chess-ui-overlay';
        overlayContainer.style.width = `${myVars.panelWidth}px`;
        overlayContainer.style.height = `${myVars.panelHeight}px`;
        overlayContainer.style.background = '#1e1e1e';
        overlayContainer.style.border = '1px solid #333';
        overlayContainer.style.borderRadius = '8px';
        overlayContainer.style.boxShadow = '0 4px 12px rgba(0,0,0,0.4)';

        if (myVars.panelTop !== null && myVars.panelLeft !== null) {
            overlayContainer.style.top = `${myVars.panelTop}px`;
            overlayContainer.style.left = `${myVars.panelLeft}px`;
            overlayContainer.style.transform = 'none';
        } else {
            overlayContainer.style.top = '50%';
            overlayContainer.style.left = '50%';
            overlayContainer.style.transform = 'translate(-50%, -50%)';
        }
        overlayContainer.innerHTML = `
               <table>
               <tr class="header-row">
               <td colspan="3" class="header draggable-handle">
                <span style="display: flex; flex-direction: column; align-items: flex-start; justify-content: center; line-height: 1;">
                    <div style="display: flex; align-items: center;">
                        <span style="margin-right: 10px; font-size: 16px; color: #7fa650;">CHESS.COM</span>

                        <div id="engine-status-led"style="width: 12px; height: 12px; border-radius: 50%; margin-left: 5px; border: 1px solid #111;"></div>
                        <div id="GILIRAN-SAYA"
                        style="width: 12px; height: 12px; border-radius: 50%; margin-left: 5px; border: 1px solid #111;"></div>
                        <div id="GILIRAN-LAWAN"
                        style="width: 12px; height: 12px; border-radius: 50%; margin-left: 5px; border: 1px solid #111;"></div>


                        <span id="digital-clock"
                            style="margin-right: 15px; font-size: 14px; font-family: monospace; font-weight: bold; color: #fff; padding: 2px 5px; border-radius: 3px;">
                            --:--:--:--
                        </span>
                    </div>

                    <span style="font-size: 10px; color: #aaa; margin-top: 3px; font-weight: normal;">[press esc to toggel interface]</span>
                </span>
            </td>
            <td colspan="4" class="header right window-controls">
                <span class="control-btn" id="minimize-btn">ðŸ”¼</span>
                <span class="control-btn" id="maximize-btn">ðŸ”½</span>
                <span class="control-btn" id="close-btn">ðŸ…¾ï¸</span>
                <button type="button" class="menu-item help-btn" data-content="help-tab"
                    style="
                        background: #464442;
                        color: #fff;
                        border: none;
                        padding: 3px 8px;
                        border-radius: 3px;
                        font-weight: bold;
                        cursor: pointer;
                        margin-left: 5px;
                        line-height: 1.2;
                    ">
                    ?
                </button>
            </td>
        </tr>
        <tr class="menu-row">
            <td class="menu-item active" data-content="engine-settings">Main ðŸŽ®</td>
            <td class="menu-item" data-content="main-control">CONTROL â±ï¸</td>
            <td class="menu-item" data-content="display-setting">DISPLAY ðŸ–¥ï¸</td>
            <td class="menu-item" data-content="action">OPENING BOOK ðŸ”Ž</td>
            <td class="menu-item" data-content="top-move">TOP ðŸ“„</td>
            <td class="menu-item" data-content="setting">SET ðŸ› ï¸</td>
        </tr>
        <tr class="content-row">
            <td colspan="6" class="content-area">
                <div class="content-scroll-container" id="panel-content-scroll">
                </div>
            </td>
        </tr>
        <tr class="evaluation-row">
            <td colspan="6" class="evaluation-section">
                <div class="evaluation-bars-wrapper">
                    <div class="evaluation-bar-container auto-run-bar-container">
                        <div id="evaluationFillAutoRun"></div>
                        <span id="autoRunStatusText" class="bar-status-text">READY</span>
                    </div>
                    <div class="evaluation-bar-container analysis-bar-container">
                        <div id="evaluationFillAnalysis"></div>
                    </div>
                </div>
                </td>
                </tr>
                </table>
                `;
        document.body.appendChild(overlayContainer);
        // ===========================================================================================================================================
        //
        // ===========================================================================================================================================
        const style = document.createElement('style');
        style.textContent = `
@import url('https://fonts.googleapis.com/css2?family=JetBrains+Mono:wght@400;600&family=Inter:wght@400;600;700&display=swap');

/* ========================================================================= */
/* CHESS UI OVERLAY PANEL                                                    */
/* ========================================================================= */
#chess-ui-overlay {
  position: fixed;
  background-color: #2e2e2e;
  border: 1px solid #444;
  box-shadow: 0 0 15px rgba(0,0,0,0.5);
  z-index: 9999;
  font-family: 'Inter', sans-serif; /* gunakan Inter untuk UI */
  border-radius: 8px;
  color: #fff;
  display: block;
  transition: width 0.3s ease, height 0.3s ease;
}

/* ========================================================================= */
/* STATE CONTROL                                                             */
/* ========================================================================= */
#chess-ui-overlay.closed {
  display: none !important;
}
#chess-ui-overlay.minimized,
#chess-ui-overlay.maximized {
  width: ${myVars.panelWidth}px !important;
  height: auto !important;
}

/* ========================================================================= */
/* TABLE STRUCTURE                                                           */
/* ========================================================================= */
#chess-ui-overlay table {
  width: 100%;
  border-collapse: collapse;
  border-radius: 8px;
  overflow: hidden;
}
#chess-ui-overlay td {
  border: 1px solid #444;
  padding: 10px;
  text-align: center;
  vertical-align: top;
  user-select: none;
}

/* ========================================================================= */
/* MINIMIZE BEHAVIOR                                                         */
/* ========================================================================= */
#chess-ui-overlay.minimized .menu-row,
#chess-ui-overlay.minimized .content-row {
  display: none;
}
#chess-ui-overlay.minimized .header-row,
#chess-ui-overlay.minimized .evaluation-row {
  display: table-row;
}

/* ========================================================================= */
/* HEADER BAR                                                                */
/* ========================================================================= */
.header {
  background-color: #383838;
  font-weight: 600;
  padding: 15px 10px;
  cursor: grab;
  text-align: left;
  user-select: none;
  font-family: 'JetBrains Mono', monospace; /* gunakan JetBrains untuk header teknis */
}
.window-controls {
  text-align: right;
  cursor: default;
  padding: 0;
  white-space: nowrap;
}
.control-btn {
  display: inline-block;
  padding: 15px 10px;
  cursor: pointer;
  font-weight: 600;
  transition: background-color 0.2s ease;
  line-height: 1;
}
#minimize-btn:hover,
#maximize-btn:hover {
  background-color: #7fa650;
}
#close-btn:hover {
  background-color: #e96150;
}

/* ========================================================================= */
/* MENU ITEMS                                                                */
/* Styling item menu navigasi                                                */
/* ========================================================================= */
.menu-item {
    font-weight: bold;
    cursor: pointer;
    transition: background-color 0.3s;
    background-color: #444;
    font-size: 10px;
    padding: 8px 5px;
}
.menu-item:hover {
    background-color: #555;
}
.menu-item.active {
    background-color: #7fa650;
}

/* ========================================================================= */
/* CONTENT AREA                                                              */
/* Area konten dengan scroll container                                       */
/* ========================================================================= */
.content-area {
    height: 250px;
    background-color: #2e2e2e;
    padding: 0 !important;
}
.content-scroll-container {
    width: 100%;
    height: 100%;
    overflow-y: auto;
    overflow-x: hidden;
}

/* ========================================================================= */
/* EVALUATION SECTION                                                        */
/* Bar evaluasi AutoRun & Analysis                                           */
/* ========================================================================= */
.evaluation-section {
    padding: 10px;
    background-color: #383838;
}
.evaluation-bars-wrapper {
    display: flex;
    gap: 10px;
}
.evaluation-bar-container {
    position: relative;
    width: 50%;
    height: 20px;
    background-color: #e0e0e0;
    border-radius: 5px;
    overflow: hidden;
    margin-bottom: 0;
}
#evaluationFillAutoRun {
    width: 50%;
    height: 100%;
    background-color: #7fa650;
    transition: width 0.2s ease-in-out;
}
#evaluationFillAnalysis {
    width: 50%;
    height: 100%;
    background-color: #4287f5;
    transition: width 0.2s ease-in-out;
}

/* ========================================================================= */
/* ATURAN DASAR LED (Menggunakan ID Baru dan Lama) */
/* Semua LED (Aktivitas, Giliran Saya, Giliran Lawan) */
/* ========================================================================= */
#engine-status-led, #GILIRAN-SAYA, #GILIRAN-LAWAN {
    width: 10px !important;
    height: 10px !important;
    background-color: #444 !important; /* Warna dasar (mati/gelap) */
    border-radius: 50%;
    box-shadow: 0 0 5px #444;
    transition: background-color 0.3s, box-shadow 0.3s;

    /* Properti tambahan dari CSS lama Anda */
    pointer-events: none;
    text-indent: -9999px;
    display: inline-block;
    margin-bottom: -1px;
}


/* ========================================================================= */
/* ðŸŸ¢ LOGIKA GILIRAN SAYA (ID: GILIRAN-SAYA) */
/* (Menggunakan warna Hijau dari logika lama Anda) */
/* ========================================================================= */
#GILIRAN-SAYA.my-turn-active {
    background-color: #4caf50 !important; /* HIJAU untuk Giliran Saya */
    box-shadow: 0 0 8px #4caf50;
}


/* ========================================================================= */
/* ðŸ”´ LOGIKA GILIRAN LAWAN (ID: GILIRAN-LAWAN) */
/* (Menggunakan warna Merah/Orange dari logika lama Anda) */
/* ========================================================================= */
#GILIRAN-LAWAN.opponent-turn-active {
    background-color: #eb6150 !important; /* MERAH/ORANGE untuk Giliran Lawan */
    box-shadow: 0 0 5px #eb6150;
}


/* ========================================================================= */
/* LED UMUM (Activity LED) - Menyala saat Game Aktif */
/* (Menggunakan warna Biru dari logika lama Anda sebagai indikator umum aktif) */
/* ========================================================================= */
#engine-status-led.active {
    background-color: #4287f5 !important; /* BIRU untuk Status Game Aktif */
    box-shadow: 0 0 5px #4287f5;
}


/* Baris ini wajib ada agar lampu mati tetap gelap */
#engine-status-led, #GILIRAN-SAYA, #GILIRAN-LAWAN {
    background-color: #444 !important;
}
/* ========================================================================= */
/* ON/OFF BUTTON + COLOR PRESETS                                             */
/* Tombol toggle ON/OFF dan preset warna highlight                           */
/* ========================================================================= */
.on-off-button {
    padding: 5px 15px;
    border: none;
    cursor: pointer;
    border-radius: 5px;
    font-weight: bold;
    color: white;
}
.on-off-button.on {
    background-color: #7fa650;
}
.on-off-button.off {
    background-color: #e96150;
}

.color-presets, .color-presets-highlight {
    display: flex;
    flex-wrap: wrap;
    gap: 10px;
    justify-content: center; /* Dipusatkan */
}
.preset-btn, .preset-btn-highlight {
    width: 25px; /* Diperkecil */
    height: 25px; /* Diperkecil */
    border-radius: 50%;
    border: 2px solid #fff;
    cursor: pointer;
    padding: 0;
}

.mode-switch-labels {
    display: flex;
    align-items: center;
    gap: 10px;
}
.mode-label {
    font-size: 14px;
    color: #aaa;
    -ms-user-select: none;
    -webkit-user-select: none;
    user-select: none;
}

/* ========================================================================= */
/* SWITCH TOGGLE (SLIDER)                                                    */
/* Komponen switch dengan animasi slider bulat                               */
/* ========================================================================= */
.switch {
    position: relative;
    display: inline-block;
    width: 50px;
    height: 20px;
}
.switch input {
    opacity: 0;
    width: 0;
    height: 0;
}
.slider {
    position: absolute;
    cursor: pointer;
    top: 0;
    left: 0;
    right: 0;
    bottom: 0;
    background-color: #78909C;
    transition: .4s;
}
.slider:before {
    position: absolute;
    content: "";
    height: 14px;
    width: 14px;
    left: 3px;
    bottom: 3px;
    background-color: white;
    transition: .4s;
}
input:checked + .slider {
    background-color: #7fa650;
}
input:checked + .slider:before {
    transform: translateX(25px);
}
.slider.round {
    border-radius: 10px;
}
.slider.round:before {
    border-radius: 50%;
}

/* ========================================================================= */
/* DISCLAIMER NOTE                                                           */
/* Catatan disclaimer dengan styling khusus                                  */
/* ========================================================================= */
.disclaimer-note {
    margin-top: 20px;
    padding: 10px;
    background-color: #58151c;
    border: 1px solid #993333;
    border-radius: 5px;
    font-size: 11px;
    color: #fff;
    line-height: 1.4;
    box-shadow: 0 2px 4px rgba(0, 0, 0, 0.4);
}
.disclaimer-note strong {
    color: #ffcccc;
    font-size: 13px;
}
.disclaimer-note p {
    margin: 5px 0;
}

/* ========================================================================= */
/* EVALUATION BAR + STATUS TEXT                                              */
/* Bilah evaluasi dengan teks status di tengah                               */
/* ========================================================================= */
.evaluation-bar-container {
    position: relative; /* Pastikan properti ini ada */
    width: 50%;
    height: 20px;
    background-color: #e0e0e0;
    border-radius: 5px;
    overflow: hidden;
    margin-bottom: 0;
}
.bar-status-text {
    position: absolute;
    top: 50%;
    left: 50%;
    transform: translate(-50%, -50%); /* Menempatkan tepat di tengah */
    font-size: 11px;
    font-weight: bold;
    color: #fff; /* Warna putih agar terlihat jelas */
    z-index: 20; /* Pastikan di atas bilah evaluasi */
    text-shadow: 0 0 3px #000; /* Tambahkan bayangan agar lebih terbaca */
    pointer-events: none; /* Agar tidak mengganggu klik */
    letter-spacing: 1px;
}
/* ========================================================================= */
/* CHESS TOP MOVES PANEL                                                     */
/* Panel utama untuk menampilkan gerakan terbaik                             */
/* ========================================================================= */
#chess-top-moves-panel {
    position: absolute;
    top: 10px;
    right: 10px;
    z-index: 1000;
    background-color: #e0e0e0;
    border-radius: 6px;
    padding: 10px; /* Padding keseluruhan panel */
    box-shadow: 0 4px 10px rgba(0, 0, 0, 0.4);
    font-family: 'Open Sans', sans-serif;
    color: #FFFFFF;
    width: 200px; /* Lebar tetap, JANGAN DIUBAH! */
    overflow: hidden;
}

/* Header Title */
#chess-top-moves-panel h4 {
    margin: 0 0 5px 0;
    font-size: 16px;
    text-align: center;
    color: #FFFFFF;
}

/* ========================================================================= */
/* FEN HISTORY CONTAINER (Tema Gelap)                                        */
/* Container riwayat FEN dengan gaya gelap                                   */
/* ========================================================================= */
#fenHistoryContainer {
    margin-top: 20px;
    border: 1px solid #484848; /* Border gelap */
    border-radius: 8px;
    padding: 10px;
    max-height: 200px;
    overflow-y: auto;
    background-color: #2c2f33; /* Warna latar belakang gelap */
    box-shadow: 0 4px 8px rgba(0, 0, 0, 0.5);
    color: #FFFFFF;
}

/* Judul FEN History */
#fenHistoryContainer h3 {
    margin: 0 0 10px 0;
    font-size: 16px;
    color: #79D6B5; /* Warna aksen */
    border-bottom: 1px solid #484848;
    padding-bottom: 5px;
}

/* ========================================================================= */
/* FEN HISTORY TABLE                                                         */
/* Tabel riwayat FEN dengan header dan body                                  */
/* ========================================================================= */
#fenHistoryTable {
    width: 100%;
    border-collapse: collapse;
    font-size: 12px; /* Dikecilkan agar FEN muat dalam lebar 200px */
}

/* Header Tabel FEN (<thead>) */
#fenHistoryTable thead th {
    padding: 5px 0;
    border-bottom: 1px solid #484848; /* Border gelap */
    color: #C0C0C0;
    font-weight: bold;
}

/* ========================================================================= */
/* FEN HISTORY BODY                                                          */
/* Baris & sel data riwayat FEN                                              */
/* ========================================================================= */
#currentFen tr {
    /* Tidak ada gaya khusus */
}
#currentFen td {
    padding: 4px 0;
    border-bottom: 1px dotted #36393f; /* Garis pemisah halus */
    color: #E0E0E0;
    white-space: normal;
    word-break: break-all; /* Potong FEN panjang */
}
#currentFen tr td:first-child {
    width: 10%;
    font-weight: bold;
    color: #FFC069; /* Warna aksen nomor */
    text-align: center;
}

/* Tombol Clear History */
#clearFenHistoryBtn {
    width: 100%; /* Selebar panel */
    box-sizing: border-box;
}

/* ========================================================================= */
/* MOVE TABLE HEADER                                                         */
/* Header tabel untuk daftar gerakan terbaik                                 */
/* ========================================================================= */
.move-table-header {
    display: flex;
    justify-content: space-between;
    padding: 15px;
    font-size: 14px;
    font-weight: bold;
    color: #C0C0C0;
    border-bottom: 1px solid #484848;
    padding-bottom: 5px;
    margin-bottom: 5px;
}
.move-table-header .col-move { width: 40%; text-align: left; }
.move-table-header .col-eval { width: 60%; text-align: right; }

/* ========================================================================= */
/* TOP MOVE ITEM                                                             */
/* Baris item untuk menampilkan data gerakan & evaluasi                      */
/* ========================================================================= */
.top-move-item {
    display: flex;
    justify-content: space-between;
    padding: 10px;
    background-color: #2c2f33;
    border-radius: 8px;
    box-shadow: 0 4px 8px rgba(0, 0, 0, 0.5);
    color: #FFFFFF;
    margin-top: 20px;
}

/* Gerakan (Move) */
.col-move {
    font-weight: bold;
    color: #79D6B5; /* Hijau terang */
    width: 40%;
    text-align: left;
}

/* Evaluasi (Eval) */
.col-eval {
    font-weight: normal;
    width: 60%;
    text-align: right;
}

/* Warna spesifik evaluasi */
.eval-positive { color: #79D6B5; } /* Putih unggul */
.eval-negative { color: #FF6969; } /* Hitam unggul */
.eval-equal    { color: #FFC069; } /* Seimbang */
/* ========================================================================= */
/* MAIN CONTROLS CONTAINER                                                   */
/* Panel utama untuk pengaturan delay, input angka, dan judul                */
/* ========================================================================= */
#main-controls-container {
    padding: 15px;
    background-color: #2c2f33;
    border-radius: 8px;
    box-shadow: 0 4px 8px rgba(0, 0, 0, 0.5);
    color: #FFFFFF;
    margin-top: 20px;
}

/* Judul H4 */
#main-controls-container h4 {
    margin: 0 0 15px 0;
    font-size: 16px;
    text-align: center;
    color: #79D6B5;
    border-bottom: 1px solid #484848;
    padding-bottom: 8px;
}

/* ========================================================================= */
/* SETTING ROWS                                                              */
/* Baris pengaturan (Delay Min/Max) dengan label dan input angka             */
/* ========================================================================= */
.setting-row {
    display: flex;
    justify-content: space-between;
    align-items: center;
    margin-bottom: 10px;
    font-size: 14px;
}
.setting-row label {
    font-weight: normal;
    color: #C0C0C0;
}
.setting-row input[type="number"] {
    width: 60px;
    padding: 5px;
    border: 1px solid #484848;
    border-radius: 4px;
    background-color: #36393f;
    color: #FFFFFF;
    text-align: center;
    transition: border-color 0.3s;
}
.setting-row input[type="number"]:focus {
    border-color: #79D6B5;
    outline: none;
    box-shadow: 0 0 0 2px rgba(121, 214, 181, 0.3);
}

/* ========================================================================= */
/* CHESS UI OVERLAY + MENU ITEM                                              */
/* Styling tambahan untuk overlay dan menu item                              */
/* ========================================================================= */
#chess-ui-overlay, #chess-ui-overlay * {
    caret-color: transparent !important;
}
.menu-row .menu-item {
    padding: 6px 10px !important;
    font-size: 11px;
    white-space: nowrap;
}

/* ========================================================================= */
/* MOVE RANK BADGE                                                           */
/* Badge lingkaran untuk ranking langkah                                     */
/* ========================================================================= */
.move-rank-badge {
    display: inline-flex;
    justify-content: center;
    align-items: center;
    width: 25px;
    height: 25px;
    border-radius: 50%;
    background-color: #7fa650;
    color: #fff;
    font-size: 12px;
    font-weight: bold;
    margin-right: 10px;
    padding-bottom: 2px;
}
/* ========================================================================= */
/* SWITCH TOGGLE                                                             */
/* Komponen switch kecil dengan slider bulat                                 */
/* ========================================================================= */
.switch {
    position: relative;
    display: inline-block;
    width: 50px;
    height: 20px;
}
.switch input {
    opacity: 0;
    width: 0;
    height: 0;
}
.slider {
    position: absolute;
    cursor: pointer;
    top: 0;
    left: 0;
    right: 0;
    bottom: 0;
    background-color: #78909C;
    transition: .4s;
}
.slider:before {
    position: absolute;
    content: "";
    height: 14px;
    width: 14px;
    left: 3px;
    bottom: 3px;
    background-color: white;
    transition: .4s;
}
input:checked + .slider {
    background-color: #7fa650;
}
input:checked + .slider:before {
    transform: translateX(25px);
}
.slider.round {
    border-radius: 10px;
}
.slider.round:before {
    border-radius: 50%;
}

/* ========================================================================= */
/* OPENING REPERTOIRE                                                        */
/* Penyesuaian gaya untuk panel Chess.com                                    */
/* ========================================================================= */
#openingRepertoire {
    color: #333 !important;
    background-color: white !important;
    border: 1px solid #ddd !important;
}

/* ========================================================================= */
/* ASSISTANT CONTROL GROUP                                                   */
/* Container kontrol asisten dengan label kiri + tombol kanan                */
/* ========================================================================= */
/* CONTAINER DASAR */
.assistant-control-group {
    display: flex;
    justify-content: space-between;
    align-items: center;
    margin-bottom: 12px;
    padding: 10px 15px;
    border-radius: 6px;
    background-color: #7fa650; /* Latar belakang gelap modern */
    box-shadow: 0 2px 4px rgba(0, 0, 0, 0.2);
}

/* GRUP LABEL KIRI (Label + Status) */
.control-label-group {
    display: flex;
    flex-direction: column;
    flex-basis: 35%;
    align-self: flex-start;
}

.control-label {
    font-weight: 600;
    color: #f0f0f0; /* Teks putih terang */
    font-size: 14px;
}

/* STATUS TEKSTUAL */
.status-text-compact {
    font-size: 11px;
    color: #aaaaaa;
    margin-top: 3px;
    line-height: 1.2;
}

/* GRUP TOMBOL KANAN */
.toggle-button-group {
    display: flex;
    flex-basis: 60%;
    border-radius: 4px;
    overflow: hidden;
}

.analysis-color-toggle-btn {
    -ms-flex-positive: 1;

    flex-grow: 1;
    padding: 8px 0;
    cursor: pointer;
    font-size: 12px; /* Dikecilkan agar 3 tombol muat */
    font-weight: bold;
    border: none;
    transition: all 0.2s ease-in-out;
    outline: none;
    text-align: center;
}

/* STYLING TOMBOL NON-AKTIF (DEFAULT) */
.analysis-color-toggle-btn:not(.is-active) {
    background-color: #7fa650;
    color: #ccc;
    border-right: 1px solid #2c2c2c;
}

.analysis-color-toggle-btn:not(.is-active):hover {
    background-color: #7fa650;
}

/* 1. STYLING TOMBOL PUTIH AKTIF */
.white-btn.is-active {
    background-color: #7fa650;
    color: #1a1a1a;
    border-right: 1px solid #e0e0e0;
}

/* 2. STYLING TOMBOL HITAM AKTIF */
.black-btn.is-active {
    background-color: #7fa650;
    color: #f0f0f0;
    border-right: 1px solid #1a1a1a;
}

/* 3. STYLING TOMBOL MATI AKTIF */
.none-btn.is-active {
    background-color: #f44336; /* Merah untuk MATI/OFF */
    color: #ffffff;
}
/* ========================================================================= */
/* MOVE HISTORY CONTAINER                                                    */
/* Panel riwayat langkah, fixed di kanan layar                               */
/* ========================================================================= */
#moveHistoryContainer {
    width: 100%; /* Selebar panel */
    max-height: 300px;      /* Tinggi lebih lega */
    overflow-y: auto;
    background-color: #2c2927;
    border: 1px solid #484848;
    border-radius: 6px;
    padding: 12px;
}

#moveHistoryTable {
    width: 100%;
    border-collapse: collapse;
    table-layout: fixed;    /* Kolom proporsional */
    font-size: 13px;        /* Sedikit lebih besar */
}

#moveHistoryTable th,
#moveHistoryTable td {
    padding: 6px;
    text-align: center;
    color: #ccc;
}

/* Atur proporsi kolom agar lebih seimbang */
#moveHistoryTable th:nth-child(1),
#moveHistoryTable td:nth-child(1) { width: 12%; }  /* No. */
#moveHistoryTable th:nth-child(2),
#moveHistoryTable td:nth-child(2) { width: 22%; }  /* Move */
#moveHistoryTable th:nth-child(3),
#moveHistoryTable td:nth-child(3) { width: 20%; }  /* Eval */
#moveHistoryTable th:nth-child(4),
#moveHistoryTable td:nth-child(4) { width: 18%; }  /* Depth */
#moveHistoryTable th:nth-child(5),
#moveHistoryTable td:nth-child(5) { width: 28%; }  /* Report */
/* ========================================================================= */
/* PEMISAH VERTIKAL                                                          */
/* Garis vertikal sebagai separator antar elemen                             */
/* ========================================================================= */
.pemisah-vertikal {
    border-left: 2px solid black;
    height: 150px;
    margin: 0 20px;
}

/* ========================================================================= */
/* ACPL CHART WRAPPER                                                        */
/* Wrapper chart dengan scroll horizontal                                    */
/* ========================================================================= */
#acplChartContainerWrapper {
    overflow-x: auto; /* Scroll horizontal aktif */
    width: 100%;      /* Lebar tetap */
    height: ...;      /* Pastikan tinggi diatur */
}

/* ========================================================================= */
/* SETTINGS FRAME DARK                                                       */
/* Frame pengaturan dengan tema gelap                                        */
/* ========================================================================= */
.settings-frame-dark {
    background-color: #333;
    border: 1px solid #4a4a4a;
    border-radius: 6px;
    padding: 15px;
    max-width: 400px;
    font-family: Arial, sans-serif;
    color: #ddd;
    margin: 20px auto;
}

/* ========================================================================= */
/* LIST ITEM                                                                 */
/* Baris item dengan deskripsi + status                                      */
/* ========================================================================= */
.listItem {
    display: flex;
    justify-content: space-between;
    align-items: center;
    padding: 8px 0;
    border-bottom: 1px dashed #4a4a4a;
}
.listItem:last-child {
    border-bottom: none;
}
.itemDescription {
    font-weight: bold;
    color: #ddd;
    font-size: 13px;
}
.itemState {
    color: #00bcd4; /* Cyan terang */
    font-weight: bold;
}

/* ========================================================================= */
/* PIECE FILTERS (CHIPS)                                                     */
/* Filter bidak dengan chip interaktif                                       */
/* ========================================================================= */
.pieceFilters {
    display: flex;
    gap: 5px;
}
.chip {
    background-color: #555;
    border: 1px solid #666;
    border-radius: 4px;
    padding: 4px 8px;
    cursor: pointer;
    -ms-user-select: none;
    -webkit-user-select: none;
    user-select: none;
    transition: background-color 0.2s;
}
.chip span {
    color: #fff;
    font-size: 11px;
    font-weight: bold;
}
.chip input[type="checkbox"] {
    display: none;
}
/* Chip aktif (checked) */
.chip input[type="checkbox"]:checked + span {
    background-color: #28a745;
    color: white;
    padding: 4px 8px;
    border-radius: 4px;
    display: inline-block;
    margin: -4px -8px;
}

/* ========================================================================= */
/* SELECT BOX & CHECKBOX                                                     */
/* Dropdown dan checkbox custom                                              */
/* ========================================================================= */
.selectMod {
    width: 150px;
    padding: 6px 8px;
    border-radius: 4px;
    font-size: 12px;
    background-color: #555;
    color: #fff;
    border: 1px solid #666;
}
.checkboxMod {
    margin-right: 10px;
}

/* Panel container */
#humanModePanel, .setting-row {
  background-color: #2c2a28;
  border-radius: 8px;
  padding: 12px 16px;
  margin-bottom: 10px;
  border: 2px solid #444;
  box-shadow: 0 2px 6px rgba(0,0,0,0.4);
  color: #f5f5f5;
  font-family: "Segoe UI", Arial, sans-serif;
}

/* Label styling */
.setting-row label {
  font-weight: bold;
  color: #f5f5f5;
}

/* Dropdown */
#humanLevelDropdown {
  background-color: #3a3634;
  color: #fff;
  border: 1px solid #666;
  border-radius: 4px;
  padding: 4px 8px;
  margin-left: 8px;
  transition: border-color 0.3s;
}
#humanLevelDropdown:hover {
  border-color: #4caf50;
}

/* Toggle button */
.on-off-button {
  border: none;
  border-radius: 4px;
  padding: 6px 12px;
  font-weight: bold;
  cursor: pointer;
  transition: background-color 0.3s, transform 0.2s;
}
.on-off-button.on {
  background-color: #4caf50;
  color: #fff;
}
.on-off-button.off {
  background-color: #eb6150;
  color: #fff;
}
.on-off-button:hover {
  transform: scale(1.05);
}

/* Info button */
.control-btn {
  cursor: pointer;
  font-size: 16px;
  margin-left: 6px;
  transition: color 0.3s;
}
.control-btn:hover {
  color: #ffd54f;
}

/* Slider styling */
input[type="range"] {
  -webkit-appearance: none;
  width: 100%;
  height: 6px;
  border-radius: 3px;
  background: linear-gradient(to right, #4caf50, #eb6150);
  outline: none;
  margin: 0 10px;
  cursor: pointer;
}
input[type="range"]::-webkit-slider-thumb {
  -webkit-appearance: none;
  appearance: none;
  width: 14px;
  height: 14px;
  border-radius: 50%;
  background: #fff;
  border: 2px solid #333;
  cursor: pointer;
  transition: background 0.3s;
}
input[type="range"]::-webkit-slider-thumb:hover {
  background: #ffd54f;
}
input[type="range"]::-moz-range-thumb {
  width: 14px;
  height: 14px;
  border-radius: 50%;
  background: #fff;
  border: 2px solid #333;
  cursor: pointer;
}

/* Display values */
#eloRatingDisplay, #speedFactorDisplay {
  font-weight: bold;
  color: #ffd54f;
}
#pvDisplay {
    background: transparent;
    padding: 0;
    box-shadow: none;
    display: inline-block;
    flex: 1;
    text-align: left;
    color: #e5e5e5;
    font-family: 'Segoe UI', Tahoma, Arial, sans-serif;
    font-size: 14px;
    line-height: 1.5;
    word-break: break-word;
}

#pvDisplay strong {
    color: #ffffff;
    font-weight: 700;
}

@keyframes pvFadeSlideLeft {
    from { opacity: 0; transform: translateX(-10px); }
    to { opacity: 1; transform: translateX(0); }
}

.pv-update-anim {
    animation: pvFadeSlideLeft 0.4s cubic-bezier(0.25, 0.46, 0.45, 0.94);
    display: inline-block;
    width: 100%;
    will-change: transform, opacity;
}

.pv-anno {
    font-weight: 900;
    font-size: 12px;
    margin-left: 1px;
    margin-right: 6px;
    padding: 1px 3px;
    border-radius: 4px;
    display: inline-block;
    vertical-align: middle;
}

.anno-brilliant { color: #00eb9b; text-shadow: 0 0 8px rgba(0, 235, 155, 0.5); }
.anno-great { color: #95bb4a; }
.anno-inaccuracy { color: #f7d046; }
.anno-mistake { color: #ffa433; }
.anno-blunder { color: #fa3232; font-weight: bold; text-decoration: underline; }


/* ========================================================================= */
/* CONTAINER KONSOL UTAMA                                                    */
/* ========================================================================= */
#miniLogConsole {
    background: rgba(10, 10, 10, 0.95); /* Hitam transparan */
    border: 1px solid #333;
    color: #00eb9b;
    font-family: 'Consolas', 'Monaco', 'Courier New', monospace;
    font-size: 12px;
    padding: 10px;
    height: 250px;
    overflow-y: auto;
    display: flex;
    flex-direction: column;
    align-items: flex-start; /* Mengunci elemen ke kiri */
    text-align: left;        /* Mengunci teks ke kiri */
    gap: 2px;
    border-radius: 4px;
    box-shadow: inset 0 0 10px #000;
}

/* Garis Log per baris */
.log-line {
    width: 100%;
    text-align: left;
    line-height: 1.5;
    word-break: break-all;
    border-bottom: 1px solid rgba(255, 255, 255, 0.03);
    display: block;
}

/* ========================================================================= */
/* ANIMASI & ALERT                                                           */
/* ========================================================================= */

/* Animasi Flash Merah untuk Box saat Error */
@keyframes alertFlash {
    0%   { border-color: #fa3232; box-shadow: 0 0 5px rgba(250, 50, 50, 0.5); }
    50%  { border-color: #ff0000; box-shadow: 0 0 20px rgba(255, 0, 0, 0.8); }
    100% { border-color: #fa3232; box-shadow: 0 0 5px rgba(250, 50, 50, 0.5); }
}

.box-danger {
    background: rgba(40, 0, 0, 0.6) !important;
    animation: alertFlash 0.5s infinite !important;
}

/* Scrollbar Style agar terlihat modern */
#miniLogConsole::-webkit-scrollbar { width: 6px; }
#miniLogConsole::-webkit-scrollbar-thumb { background: #333; border-radius: 10px; }
/* ===========================================================================
   Container Utama Pesan Error - Mengikuti Engine History
   =========================================================================== */
#errorBoxContainer {
    margin-top: 15px;
    border: 1px solid #484848;
    border-radius: 4px;
    padding: 10px;
    max-height: 250px;
    overflow-y: auto;
    background-color: #2c2927;
    box-shadow: 0 4px 6px rgba(0,0,0,0.3);
}

/* ===========================================================================
   Tabel Error
   =========================================================================== */
#errorBoxTable {
    width: 100%;
    border-collapse: collapse;
    table-layout: fixed !important;
    font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
    font-size: 12px;
}

/* Header Tabel */
#errorBoxTable thead th {
    padding: 8px 5px;
    border-bottom: 1px solid #484848;
    color: #C0C0C0;
    font-weight: bold;
    text-align: center;
    position: sticky;
    top: 0;
    background: #2c2927;
    z-index: 10;
}

/* Body Tabel */
#errorLogContent tr {
    border-bottom: 1px solid #3d3a37;
    transition: background 0.2s;
}

#errorLogContent tr:hover {
    background: #363331;
}

#errorLogContent td {
    padding: 8px 5px;
    color: #ccc;
    vertical-align: middle;
}

/* ===========================================================================
   Pengaturan Kolom
   =========================================================================== */
.col-waktu {
    width: 70px;
    text-align: center;
    color: #888;
    font-family: monospace;
}

.col-tipe {
    width: 90px;
    text-align: center;
    font-weight: bold;
}

.col-pesan {
    word-break: break-word;
    position: relative;
    padding-right: 40px !important;
}

/* ===========================================================================
   Kategori Warna
   =========================================================================== */
.err-violation { color: #ff00ea !important; }
.err-runtime   { color: #fa3232 !important; }
.err-network   { color: #3498db !important; }
.err-general   { color: #ccc; }

/* ===========================================================================
   Tombol Salin (Copy) Modern per baris
   =========================================================================== */
.col-copy-btn {
    position: absolute;
    right: 5px;
    top: 50%;
    transform: translateY(-50%);
    background: #3d3a37;
    border: 1px solid #555;
    color: #ccc;
    cursor: pointer;
    font-size: 10px;
    padding: 2px 6px;
    border-radius: 3px;
    opacity: 0;
    transition: all 0.2s;
}

#errorLogContent tr:hover .col-copy-btn {
    opacity: 1;
}

.col-copy-btn:hover {
    background: #555;
    color: #fff;
    border-color: #777;
}

/* ===========================================================================
   Tombol Copy Semua
   =========================================================================== */
#copyAllErrorsBtn {
    margin: 5px 0;
    cursor: pointer;
    border: none;
    background: #3d3a37;
    color: #ccc;
    padding: 4px 8px;
    border-radius: 4px;
    font-size: 11px;
    transition: background 0.2s, color 0.2s;
}

#copyAllErrorsBtn:hover {
    background: #555;
    color: #fff;
}

/* ===========================================================================
   Scrollbar Dark Mode
   =========================================================================== */
#errorBoxContainer::-webkit-scrollbar {
    width: 6px;
}
#errorBoxContainer::-webkit-scrollbar-track {
    background: #2c2927;
}
#errorBoxContainer::-webkit-scrollbar-thumb {
    background: #484848;
    border-radius: 10px;
}
#errorBoxContainer::-webkit-scrollbar-thumb:hover {
    background: #666;
}

/* ===========================================================================
   Animasi
   =========================================================================== */
.fade-in {
    animation: fadeIn 0.3s ease-in;
}
@keyframes fadeIn {
    from { opacity: 0; }
    to   { opacity: 1; }
}

.shake {
    animation: shake 0.4s ease-in-out;
}
@keyframes shake {
    0%, 100% { transform: translateX(0); }
    25%      { transform: translateX(-4px); }
    75%      { transform: translateX(4px); }
}
.engine-led-item {
    color: #444; /* Warna redup saat tidak aktif */
    display: flex;
    align-items: center;
    gap: 6px;
    transition: all 0.3s ease;
    font-weight: bold;
    text-transform: uppercase;
}

.led-dot {
    width: 8px;
    height: 8px;
    border-radius: 50%;
    background: #222; /* Warna dasar dot */
    box-shadow: inset 0 0 2px #000;
    transition: all 0.3s ease;
}

/* --- STATE: READY (Hijau) --- */
.engine-led-item.active[data-state="READY"] { color: #4CAF50; }
.engine-led-item.active[data-state="READY"] .led-dot {
    background: #4CAF50;
    box-shadow: 0 0 10px #4CAF50, 0 0 3px #4CAF50;
}

/* --- STATE: RUNNING (Cyan/Turquoise) --- */
.engine-led-item.active[data-state="RUNNING"] { color: #00BCD4; }
.engine-led-item.active[data-state="RUNNING"] .led-dot {
    background: #00BCD4;
    box-shadow: 0 0 10px #00BCD4;
}

/* --- STATE: THINKING (Biru + Animasi Blink) --- */
.engine-led-item.active[data-state="THINKING"] { color: #2196F3; }
.engine-led-item.active[data-state="THINKING"] .led-dot {
    background: #2196F3;
    box-shadow: 0 0 12px #2196F3;
    animation: blink 0.8s infinite ease-in-out;
}

/* --- STATE: DELAY (Oranye) --- */
.engine-led-item.active[data-state="DELAY"] { color: #FF9800; }
.engine-led-item.active[data-state="DELAY"] .led-dot {
    background: #FF9800;
    box-shadow: 0 0 10px #FF9800;
}

/* --- STATE: WAITING (Ungu) --- */
.engine-led-item.active[data-state="WAITING"] { color: #9C27B0; }
.engine-led-item.active[data-state="WAITING"] .led-dot {
    background: #9C27B0;
    box-shadow: 0 0 10px #9C27B0;
}

/* --- STATE: IDLE (Abu-abu Terang) --- */
.engine-led-item.active[data-state="IDLE"] { color: #888; }
.engine-led-item.active[data-state="IDLE"] .led-dot {
    background: #888;
    box-shadow: 0 0 8px #888;
}

/* --- STATE: ERROR (Merah + Blink Cepat) --- */
.engine-led-item.active[data-state="ERROR"] { color: #F44336; }
.engine-led-item.active[data-state="ERROR"] .led-dot {
    background: #F44336;
    box-shadow: 0 0 12px #F44336;
    animation: blink 0.4s infinite; /* Lebih cepat untuk tanda bahaya */
}

/* Keyframe Animasi */
@keyframes blink {
    0%   { opacity: 1;   transform: scale(1); }
    50%  { opacity: 0.4; transform: scale(1.1); }
    100% { opacity: 1;   transform: scale(1); }
}


#virtualChessboard {
  position: relative;
  width: 100%;          /* penuh lebar container */
  aspect-ratio: 1;      /* selalu kotak */
  border: 2px solid #333;
  box-shadow: 0 0 10px rgba(0,0,0,0.5);
}

.virtual-square.light {
  background-color: #f0d9b5;
}
.virtual-square.dark {
  background-color: #b58863;
}


.virtual-piece {
  position: absolute;
  width: 12.5%;
  height: 12.5%;
  background-size: contain;
  background-repeat: no-repeat;
  background-position: center;
  z-index: 5;
}

line {
  stroke-dasharray: 4 2;
  animation: arrowFlow 1.2s linear infinite;
}


.arrows-svg {
        overflow: visible !important;
        display: block !important;
    }
    .arrows-svg text {
        pointer-events: none;
        font-family: Arial, sans-serif;
        filter: drop-shadow(0px 0px 2px black); /* Membuat nomor lebih kontras */
    }

    .grade {
  padding: 0.25rem 0.5rem;
  border-radius: 0.25rem;
}

 .eval-positive { color: #4caf50 !important; } /* Hijau */
.eval-negative { color: #f44336 !important; } /* Merah */
.eval-equal { color: #C0C0C0 !important; } /* Abu-abu */
.eval-mate { color: #FFD700 !important; font-weight: bold; } /* Emas */

body {
            background-color: #1a1816;
            color: #e0e0e0;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
        }

        .panel {
            background-color: #2c2927;
            border-radius: 8px;
            border: 1px solid #484848;
        }

        .eval-positive { color: #4caf50 !important; }
        .eval-negative { color: #f44336 !important; }
        .eval-equal { color: #C0C0C0 !important; }
        .eval-mate { color: #FFD700 !important; font-weight: bold; }

        .grade {
            padding: 2px 8px;
            border-radius: 4px;
            font-weight: bold;
        }
        .grade.terbaik { background-color: #2e7d32; color: white; }
        .grade.bagus { background-color: #4caf50; color: white; }
        .grade.cukup { background-color: #8bc34a; color: #1a1a1a; }
        .grade.tidak-akurat { background-color: #ff9800; color: #1a1a1a; }
        .grade.kesalahan { background-color: #f44336; color: white; }
        .grade.blunder { background-color: #b71c1c; color: white; }

        .pv-row:hover {
            background-color: #3a3634;
        }

        .top-move-item {
            transition: background-color 0.2s;
            border-radius: 4px;
        }

        ::-webkit-scrollbar {
            width: 8px;
        }
        ::-webkit-scrollbar-track {
            background: #2c2927;
        }
        ::-webkit-scrollbar-thumb {
            background: #484848;
            border-radius: 4px;
        }
        ::-webkit-scrollbar-thumb:hover {
            background: #5a5a5a;
        }

        .pulse-animation {
            animation: pulse 1.5s infinite;
        }

        @keyframes pulse {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.5; }
        }

        .move-highlight {
            background-color: rgba(127, 166, 80, 0.3);
        }
        
        /* Custom Element Simulation for the observer */
        wc-chess-board { display: block; }

        /* Log styling */
        .log-entry { margin-bottom: 2px; border-bottom: 1px solid #333; padding-bottom: 2px; }
        .log-time { color: #718096; margin-right: 8px; font-size: 0.8em; }


     `;
        document.head.appendChild(style);
        const scrollContainer = document.getElementById('panel-content-scroll');
        const defaultActiveMenuItem = document.querySelector('#chess-ui-overlay .menu-item.active');
        const defaultContentId = defaultActiveMenuItem ? defaultActiveMenuItem.getAttribute('data-content') : Object.keys(contentTemplates)[0];
        for (const contentId in contentTemplates) {
            if (contentTemplates.hasOwnProperty(contentId)) {
                const panelDiv = document.createElement('div');
                panelDiv.id = `content-${contentId}`;
                panelDiv.innerHTML = contentTemplates[contentId]();
                if (contentId !== defaultContentId) {
                    panelDiv.style.display = 'none';
                }
                scrollContainer.appendChild(panelDiv);
                setupContentListeners(contentId);
            }
        }
        setupPanelListeners();
        myFunctions.updateBoardColors();
        myFunctions.setPanelState(myVars.panelState);
    } catch (e) {
        console.error('Error in myFunctions.loadEx:', e);
    }
}
// ===============================END====================================

// ===========================================================================
// RESET EVALUATION CHART (BERSIH TOTAL)
// ===========================================================================
myFunctions.resetEvaluationChart = function() {
    const svgElement = document.getElementById('acplChartSvg');
    const chartWrapper = document.getElementById('acplChartContainerWrapper');
    if (!svgElement || !chartWrapper) return;

    // Kosongkan isi SVG
    svgElement.innerHTML = '';

    // Tambahkan kembali garis tengah
    const height = chartWrapper.clientHeight || 150;
    const wrapperWidth = chartWrapper.clientWidth || 300;
    const centerLineY = height / 2;

    const centerLine = document.createElementNS("http://www.w3.org/2000/svg", "line");
    centerLine.setAttribute('id', 'chartCenterLine');
    centerLine.setAttribute('x1', 0);
    centerLine.setAttribute('y1', centerLineY);
    centerLine.setAttribute('x2', wrapperWidth);
    centerLine.setAttribute('y2', centerLineY);
    centerLine.setAttribute('stroke', '#888');
    centerLine.setAttribute('stroke-width', '1');
    centerLine.setAttribute('stroke-dasharray', '4,2');
    svgElement.appendChild(centerLine);
};

// ===========================================================================
// UPDATE EVALUATION CHART (FINAL SAFE VERSION, MODULAR SANITASI)
// ===========================================================================
myFunctions.updateEvaluationChart = function(currentCp, moveIndex) {
    const svgElement = document.getElementById('acplChartSvg');
    const chartWrapper = document.getElementById('acplChartContainerWrapper');
    if (!svgElement || !chartWrapper) return;

    // Helper sanitasi angka
    const safeNumber = (val, fallback = 0) =>
    Number.isFinite(val) ? val : fallback;

    const safeCp = safeNumber(currentCp, 0);
    const safeIndex = safeNumber(moveIndex, -1);

    // Konfigurasi chart
    const wrapperWidth = chartWrapper.clientWidth || 300;
    const height = chartWrapper.clientHeight || 150;
    const barWidth = 14;
    const barGap = 2;
    const totalBarItemWidth = barWidth + barGap;
    const maxBars = Math.floor(wrapperWidth / totalBarItemWidth);
    const maxScaleCp = 500;
    const cpToPixel = (height / 2) / maxScaleCp;
    const centerLineY = height / 2;

    // Update garis tengah jika ada
    const line = document.getElementById('chartCenterLine');
    if (line) {
        line.setAttribute('x2', wrapperWidth);
        line.setAttribute('y2', centerLineY);
    }

    // Ambil semua bar
    let barGroups = svgElement.querySelectorAll('.bar-group');

    // Shifting jika penuh
    if (barGroups.length >= maxBars) {
        svgElement.removeChild(barGroups[0]);
        barGroups = svgElement.querySelectorAll('.bar-group');
        barGroups.forEach((group) => {
            const currentTransform = group.getAttribute('transform');
            const match = /translate\(([^,]+),/.exec(currentTransform);
            if (match) {
                const currentX = safeNumber(parseFloat(match[1]), 0);
                const newX = currentX - totalBarItemWidth;
                group.setAttribute('transform', `translate(${newX}, 0)`);
            }
        });
    }

    // Hitung Data Bar Baru
    const clampedCp = Math.min(Math.max(safeCp, -maxScaleCp), maxScaleCp);
    const barHeight = Math.abs(clampedCp) * cpToPixel;

    let rectY, fillColor;
    if (clampedCp >= 0) {
        rectY = centerLineY - barHeight;
        fillColor = '#4CAF50';
    } else {
        rectY = centerLineY;
        fillColor = '#F44336';
    }

    const newX = barGroups.length * totalBarItemWidth;

    // Buat Group Baru
    const group = document.createElementNS("http://www.w3.org/2000/svg", "g");
    group.setAttribute('class', 'bar-group');
    group.setAttribute('transform', `translate(${newX}, 0)`);

    // Rect
    const rect = document.createElementNS("http://www.w3.org/2000/svg", "rect");
    rect.setAttribute('x', 0);
    rect.setAttribute('y', rectY);
    rect.setAttribute('width', barWidth);
    rect.setAttribute('height', Math.max(barHeight, 2)); // minimal 2px
    rect.setAttribute('fill', fillColor);
    rect.setAttribute('rx', 2);

    // Tooltip
    const tooltip = document.createElementNS("http://www.w3.org/2000/svg", "title");
    const cpText = (safeCp / 100).toFixed(2);
    const sign = safeCp > 0 ? '+' : '';
    tooltip.textContent = `Langkah ${safeIndex >= 0 ? safeIndex + 1 : '?'} : ${sign}${cpText}`;
    rect.appendChild(tooltip);

    // Label Nomor Urut
    const label = document.createElementNS("http://www.w3.org/2000/svg", "text");
    label.setAttribute('x', barWidth / 2);
    label.setAttribute('y', height - 5);
    label.setAttribute('text-anchor', 'middle');
    label.setAttribute('font-size', '9');
    label.setAttribute('fill', '#999');
    label.textContent = safeIndex >= 0 ? (safeIndex + 1).toString() : '?';

    // Gabungkan
    group.appendChild(rect);
    group.appendChild(label);
    svgElement.appendChild(group);
};

// ===============================END====================================

// ===========================================================================
// CONVERT EVALUATION TO CENTIPAWNS
// Konversi string evaluasi engine (misal "1.23" atau "M3") menjadi nilai CP
// ===========================================================================
myFunctions.convertEvalToCentipawns = function(evalStr, isWhite) {
    if (!evalStr || typeof evalStr !== 'string') return 0;

    let cpValue = 0;

    // Tangani kasus "mate in N"
    if (evalStr.includes('M')) {
        const mateMoves = parseInt(evalStr.replace('M', ''), 10);
        cpValue = (mateMoves > 0) ? 50000 : -50000;
    } else {
        const parsed = parseFloat(evalStr);
        cpValue = isNaN(parsed) ? 0 : parsed * 100;
    }

    return isWhite ? cpValue : -cpValue;
};
// ===============================END====================================

// ===========================================================================
// GET MOVE GRADE (versi rekomendasi)
// Menentukan kategori kualitas langkah berdasarkan nilai CPL (centipawn loss)
// ===========================================================================
myFunctions.getMoveGrade = function(cpl) {
    if (typeof cpl !== "number" || cpl < 0) {
        return "Tidak Diketahui";
    }


    if (cpl < 20) {
        return "Terbaik";
    }
    else if (cpl < 50) {
        return "Bagus";
    }
    else if (cpl < 100) {
        return "Cukup Baik";
    }
    else if (cpl < 200) {
        return "Tidak Akurat";
    }
    else if (cpl < 400) {
        return "Kesalahan";
    }
    else {
        return "Blunder";
    }
};
// ===============================END====================================

// ===========================================================================
// CLEAR MOVE HISTORY (FINAL - TOTAL RESET + MONITOR CLEANUP)
// ===========================================================================
myFunctions.clearMoveHistory = function() {
    const log = (...args) => console.log("[RESET]", ...args);
    log("Memulai proses pembersihan total...");

    // ---------- STOP ENGINE & TIMER ----------
    try {
        if (myVars.isThinking && engine && engine.engine) {
            engine.engine.postMessage("stop");
        }
    } catch (e) { console.warn("[RESET] Gagal stop engine:", e); }
    myVars.isThinking = false;
    if (myVars.moveTimer) { clearTimeout(myVars.moveTimer); myVars.moveTimer = null; }

    // ---------- RESET COUNTERS ----------
    myVars.cplMoveCountWhite = 0;
    myVars.cplMoveCountBlack = 0;
    myVars.totalCplWhite = 0;
    myVars.totalCplBlack = 0;
    myVars.cplMoveCount = 0;
    myVars.totalCpl = 0;
    myVars.evalHistory = [];
    myVars.errorCount = 0;
    myVars.securityCount = 0;
    myVars.memoryLeakCount = 0;
    myVars.memoryHistory = [];
    myVars.memoryLeakThreshold = 0;

    // ---------- RESET STATE ----------
    myVars.previousEvaluation = 0;
    myVars.currentEvaluation = 0;
    myVars.acplWhite = "0.00";
    myVars.acplBlack = "0.00";
    myVars.acplDisplay = "0.00";
    myVars.lastMoveGrade = "N/A";
    myVars.lastPV = "";
    myVars.topMoves = [];
    myVars.bestMove = '';
    myVars.lastAnalyzedFen = null;
    myVars.isGameOver = false;
    myVars.gameEnded = false;

    // ---------- CLEAR ARRAYS ----------
    if (typeof window.engineMoveHistory !== 'undefined') window.engineMoveHistory.length = 0;
    else window.engineMoveHistory = [];
    if (typeof window.evalHistory !== 'undefined') window.evalHistory.length = 0;
    else window.evalHistory = [];
    if (typeof window.acplHistory !== 'undefined') window.acplHistory.length = 0;
    else window.acplHistory = [];
    myVars.acplHistory = [];

    // ---------- UI CLEANUP ----------
    const tableBody = document.getElementById('moveHistoryTableBody');
    if (tableBody) tableBody.innerHTML = '';
    const svgElement = document.getElementById('acplChartSvg');
    if (svgElement) svgElement.innerHTML = '';
    const barWhite = document.getElementById('acplBarWhite');
    if (barWhite) { barWhite.style.width = '0%'; barWhite.innerHTML = ''; barWhite.style.backgroundColor = 'gray'; }
    const barBlack = document.getElementById('acplBarBlack');
    if (barBlack) { barBlack.style.width = '0%'; barBlack.innerHTML = ''; barBlack.style.backgroundColor = 'gray'; }

    const acplTextEl = document.getElementById('acplTextDisplay');
    if (acplTextEl) acplTextEl.innerText = "W 0.00 / B 0.00";
    const countWhiteEl = document.getElementById('cplMoveCountWhiteDisplay');
    if (countWhiteEl) countWhiteEl.innerText = "0";
    const countBlackEl = document.getElementById('cplMoveCountBlackDisplay');
    if (countBlackEl) countBlackEl.innerText = "0";
    const acplDisplayEl = document.getElementById('acplDisplay');
    if (acplDisplayEl) { acplDisplayEl.innerHTML = "0.00"; acplDisplayEl.style.color = "white"; }

    if (typeof window.uiCache !== 'undefined') {
        if (window.uiCache.nodes) window.uiCache.nodes.textContent = "0";
        if (window.uiCache.nps) window.uiCache.nps.textContent = "0";
        if (window.uiCache.depth) window.uiCache.depth.textContent = "0";
        if (window.uiCache.pv) window.uiCache.pv.textContent = "";
        if (window.uiCache.time) window.uiCache.time.textContent = "0.0s";
    }

    const panelHeader = document.getElementById('assistantPanelHeader');
    if (panelHeader) panelHeader.style.backgroundColor = '#333';

    // ---------- ENGINE STATE READY ----------
    if (typeof myFunctions.setEngineState === 'function') {
        myFunctions.setEngineState(ENGINE_STATE.READY);
    }
    if (typeof myFunctions.updateEngineStatusText === 'function') {
        myFunctions.updateEngineStatusText('Ready');
    }

    // ---------- CLEAR HIGHLIGHTS & CHART ----------
    if (typeof myFunctions.clearHighlights === 'function') {
        myFunctions.clearHighlights();
    }
    if (typeof myFunctions.updateEvaluationChart === 'function') {
        myFunctions.resetEvaluationChart();
    }

    // =======================================================================
    // Tambahan: CLEAR MONITOR / ERROR / SECURITY / MEMORY LOGS
    // =======================================================================

    // Reset badge counters
    myVars.errorCount = 0;
    myVars.securityCount = 0;
    if (typeof updateCounterBadge === 'function') updateCounterBadge();

    // Reset monitor status lampu
    if (typeof setMonitorStatus === 'function') setMonitorStatus("ok");

    // Bersihkan error mailbox
    const errorContent = document.getElementById("errorLogContent");
    if (errorContent) errorContent.innerHTML = "<div>Menunggu pesan error...</div>";

    // Bersihkan security log
    const secContent = document.getElementById("securityLogContent");
    if (secContent) secContent.innerHTML = "<div>Menunggu pesan security...</div>";

    // Bersihkan memory leak warning
    const memContent = document.getElementById("memoryLeakContent");
    if (memContent) memContent.innerHTML = "<div>Tidak ada memory leak</div>";
    myVars.memoryHistory = [];
    myVars.memoryLeakCount = 0;

    // Bersihkan mini log console
    const miniLog = document.getElementById("miniLogConsole");
    if (miniLog) miniLog.innerHTML = "<div>Console bersih</div>";

    log("SUKSES. Semua counter 0, timer mati, history & monitor bersih.");
};


// ===========================================================================
// ADD MOVE TO HISTORY (UI Only - tanpa simpan array global)
// ===========================================================================
myFunctions.addMoveToHistory = function(move, evaluation, depth, grade, prevEvaluation) {
    const tableBody = document.getElementById('moveHistoryTableBody');
    if (!tableBody) return;

    // --- Logika Konversi Evaluasi untuk Grafik ---
    const parseEvalToCp = (evalText) => {
        if (typeof evalText !== 'string' || evalText === null) return 0;

        if (evalText.toUpperCase().startsWith('M') || evalText.toUpperCase().startsWith('#')) {
            const isPositive = evalText.includes('+') || !evalText.includes('-');
            return isPositive ? 10000 : -10000;
        }
        const cp = parseFloat(evalText) * 100;
        return isNaN(cp) ? 0 : cp;
    };

    const currentCp = parseEvalToCp(evaluation);

    // Update grafik langsung (tanpa simpan ke evalHistory)
    if (typeof myFunctions.updateEvaluationChart === 'function') {
        myFunctions.updateEvaluationChart(currentCp, move);
    }

    // Nomor langkah dihitung dari jumlah baris tabel
    const moveNumber = tableBody.children.length + 1;

    const row = document.createElement('tr');
    row.classList.add('move-history-row');

    let evalText = '';
    let evalClass = '';
    let displayEval = 0;

    if (typeof evaluation === 'string' && (evaluation.includes('M') || evaluation.includes('#'))) {
        evalText = evaluation;
        evalClass = 'eval-mate';
    } else {
        const floatEval = parseFloat(evaluation);
        displayEval = floatEval;
        if (isNaN(displayEval)) return;

        const sign = displayEval >= 0 ? '+' : '';
        evalText = `${sign}${displayEval.toFixed(2)}`;

        if (displayEval > 0.4) {
            evalClass = 'eval-positive';
        } else if (displayEval < -0.4) {
            evalClass = 'eval-negative';
        } else {
            evalClass = 'eval-equal';
        }
    }

    let gradeColor = '#C0C0C0';
    let gradeDisplay = grade || 'N/A';
    switch (gradeDisplay) {
        case 'Terbaik': gradeColor = '#7fa650'; break;
        case 'Bagus': case 'Good': gradeColor = '#4caf50'; break;
        case 'Cukup Baik': case 'Inaccuracy': gradeColor = '#aeea00'; break;
        case 'Tidak Akurat': case 'Mistake': gradeColor = '#ffc107'; break;
        case 'Kesalahan': case 'Error': gradeColor = '#ff9800'; break;
        case 'Blunder': gradeColor = '#f44336'; break;
        default: gradeColor = '#C0C0C0'; break;
    }

    row.innerHTML = `
        <td style="text-align: center;">${moveNumber}</td>
        <td style="font-weight: bold; text-align: center;">${move}</td>
        <td class="${evalClass}" style="text-align: center;">${evalText}</td>
        <td style="text-align: center;">${depth || '-'}</td>
        <td style="color: ${gradeColor}; font-weight: bold; text-align: center;">${gradeDisplay}</td>
    `;

    if (tableBody.firstChild) {
        tableBody.insertBefore(row, tableBody.firstChild);
    } else {
        tableBody.appendChild(row);
    }

    const container = document.getElementById('moveHistoryContainer');
    if (container) container.scrollTop = 0;

    while (tableBody.children.length > 70) {
        tableBody.removeChild(tableBody.lastChild);
    }
};


// ===========================================================================
// GAME END HANDLER
// Dipanggil saat game selesai
// ===========================================================================
function onGameEnd(result) {
    console.log("Game selesai:", result);

    // Reset history & ACPL
    if (typeof myFunctions.clearMoveHistory === 'function') {
        myFunctions.clearMoveHistory();
    }

    // Set engine state siap untuk game baru
    if (typeof myFunctions.setEngineState === 'function') {
        myFunctions.setEngineState(ENGINE_STATE.READY);
    }
}


// ===========================================================================
// UPDATE ACPL GRAPH
// Mengupdate tampilan bar ACPL (Average Centipawn Loss) untuk White & Black
// ===========================================================================
myFunctions.updateAcplGraph = function() {
    const barWhite = document.getElementById('acplBarWhite');
    const barBlack = document.getElementById('acplBarBlack');
    if (!barWhite || !barBlack) return;

    const MAX_ACPL_DISPLAY = 50.0;
    const acplWhiteCP = Math.abs(parseFloat(myVars.acplWhite || "0.00") * 100);
    const acplBlackCP = Math.abs(parseFloat(myVars.acplBlack || "0.00") * 100);

    const gradeWhite = myFunctions.getMoveGrade(acplWhiteCP);
    const gradeBlack = myFunctions.getMoveGrade(acplBlackCP);

    // --- Konversi grade â†’ warna ---
    const gradeToColor = (grade) => {
        switch (grade) {
            case 'Terbaik': return 'mediumspringgreen';
            case 'Bagus': return 'limegreen';
            case 'Cukup Baik': return 'yellow';
            case 'Tidak Akurat': return 'orange';
            case 'Kesalahan': return '#ff8c00';
            case 'Blunder': return 'red';
            default: return 'gray';
        }
    };

    // --- Hitung persentase bar ---
    let whitePercentage = (acplWhiteCP / MAX_ACPL_DISPLAY) * 100;
    let blackPercentage = (acplBlackCP / MAX_ACPL_DISPLAY) * 100;
    whitePercentage = Math.min(100, Math.max(0, whitePercentage));
    blackPercentage = Math.min(100, Math.max(0, blackPercentage));

    // --- Update style bar ---
    barWhite.style.width = `${whitePercentage}%`;
    barBlack.style.width = `${blackPercentage}%`;
    barWhite.style.backgroundColor = gradeToColor(gradeWhite);
    barBlack.style.backgroundColor = gradeToColor(gradeBlack);

    // --- Tambahkan label CP ---
    barWhite.innerHTML = `<span style="float: right; padding-right: 5px; font-weight: bold; font-size: 10px; color: white; text-shadow: 1px 1px 2px #000;">${acplWhiteCP.toFixed(0)} CP</span>`;
    barBlack.innerHTML = `<span style="float: right; padding-right: 5px; font-weight: bold; font-size: 10px; color: white; text-shadow: 1px 1px 2px #000;">${acplBlackCP.toFixed(0)} CP</span>`;
};
// ===============================END====================================

// ===========================================================================
// UPDATE ACPL DISPLAY (OPTIMIZED)
// Menangani tampilan saat data di-reset (kosong)
// ===========================================================================
myFunctions.updateAcplDisplay = function() {
    const acplHistoryEl = document.getElementById('acplDisplay');
    const panelHeader = document.getElementById('assistantPanelHeader');

    // Default State (Saat Reset)
    let color = 'white';
    let quality = 'Menunggu...'; // Atau 'N/A'
    let displayText = '0.00';
    let currentAcpl = 0;

    // Cek apakah ada data history
    if (myVars.acplHistory && myVars.acplHistory.length > 0) {
        const totalAcpl = myVars.acplHistory.reduce((sum, val) => sum + val, 0);
        currentAcpl = totalAcpl / myVars.acplHistory.length;
        displayText = currentAcpl.toFixed(2);

        // Logika Warna
        if (currentAcpl < 15) { color = 'mediumspringgreen'; quality = 'Brilian'; }
        else if (currentAcpl < 40) { color = 'limegreen'; quality = 'Sangat Baik'; }
        else if (currentAcpl < 60) { color = 'yellow'; quality = 'Baik'; }
        else if (currentAcpl < 85) { color = 'orange'; quality = 'Rata-rata'; }
        else { color = 'red'; quality = 'Buruk'; }
    } else {
        // Jika data kosong (setelah clear), pastikan header kembali netral
        // Jangan biarkan warna merah/hijau tertinggal
        if (panelHeader) panelHeader.style.backgroundColor = '#333'; // Warna default header (sesuaikan dgn CSS Anda)
    }

    // Terapkan ke elemen
    if (acplHistoryEl) {
        acplHistoryEl.style.color = color;
        // Jika kosong, tampilkan 0.00, jika ada data tampilkan nilai + kualitas
        acplHistoryEl.innerHTML = myVars.acplHistory.length > 0
            ? `${displayText} (${quality})`
            : `0.00`;
    }

    // Update background header jika ada data
    if (panelHeader && myVars.acplHistory.length > 0) {
        panelHeader.style.backgroundColor = color;
    }

    // Update Text Detail W/B
    const acplTextEl = document.getElementById('acplTextDisplay');
    if (acplTextEl) {
        acplTextEl.innerText = `W ${myVars.acplWhite || '0.00'} / B ${myVars.acplBlack || '0.00'}`;
    }

    const countWhiteEl = document.getElementById('cplMoveCountWhiteDisplay');
    if (countWhiteEl) countWhiteEl.innerText = myVars.cplMoveCountWhite || 0;

    const countBlackEl = document.getElementById('cplMoveCountBlackDisplay');
    if (countBlackEl) countBlackEl.innerText = myVars.cplMoveCountBlack || 0;

    // Panggil update grafik bar juga agar sinkron
    if (typeof myFunctions.updateAcplGraph === 'function') {
        myFunctions.updateAcplGraph();
    }
};
// ===============================END====================================
myFunctions.showHumanModeInfoModal = function() {
    const existingModal = document.getElementById('humanModeInfoModal');
    if (existingModal) existingModal.remove();

    // --- Konten modal ---
    const modalContent = document.createElement('div');
    modalContent.id = 'humanModeInfoModal';

    // CSS dikunci agar tidak bisa copy-paste teks (User-Select: none)
    modalContent.style = `
        position: fixed;
        z-index: 9999;
        top: 50%; left: 50%;
        transform: translate(-50%, -50%);
        background-color: #fefefe;
        padding: 25px;
        border: 1px solid #ddd;
        width: 90%; max-width: 450px;
        border-radius: 10px;
        box-shadow: 0 8px 16px rgba(0,0,0,0.3);
        font-family: 'Open Sans', sans-serif;
        color: #333;
        user-select: none;
        -webkit-user-select: none;
        -moz-user-select: none;
        -ms-user-select: none;
    `;

    // --- Judul (drag handle) ---
    const title = document.createElement('h3');
    title.textContent = "ðŸ‘¤ Virtual Chessboard";
    title.style = `
        margin-top: 0;
        border-bottom: 2px solid #ff9800;
        padding-bottom: 10px;
        color: #ff9800;
        cursor: move;
    `;
    modalContent.appendChild(title);

    // --- Isi ---
    const infoText = document.createElement('div');
    infoText.innerHTML = `
        <div id="actions-tab" class="tab-content">
            <div id="virtualChessboard"
                 style="width: 100%; aspect-ratio: 1; position: relative;
                        margin-bottom: 10px; border: 1px solid #ccc;
                        background-color: #fff;">
            </div>
            <div style="font-size: 12px; color: #666; text-align: center;">
                Move suggestions are shown here instead of on the main board
            </div>
        </div>`;
    infoText.style = 'font-size: 14px; line-height: 1.5; color: #444;';
    modalContent.appendChild(infoText);

    // --- Tombol tutup ---
    const closeBtn = document.createElement('button');
    closeBtn.textContent = 'Tutup';
    closeBtn.style = `
        display: block; width: 100%;
        padding: 12px;
        background-color: #ff9800; color: white;
        border: none; border-radius: 5px;
        margin-top: 20px; cursor: pointer;
        font-weight: bold; transition: background-color 0.2s;
    `;
    closeBtn.onclick = function() { modalContent.remove(); };
    modalContent.appendChild(closeBtn);

    // --- Logic Drag yang diperbaiki ---
    let isDragging = false;
    let startX, startY, initialLeft, initialTop;

    title.addEventListener('mousedown', function(e) {
        isDragging = true;

        // Ambil posisi awal modal saat ini
        const rect = modalContent.getBoundingClientRect();

        // Simpan posisi mouse relatif terhadap modal
        startX = e.clientX;
        startY = e.clientY;
        initialLeft = rect.left;
        initialTop = rect.top;

        // MATIKAN translate agar tidak bentrok saat koordinat diubah ke absolut
        modalContent.style.transform = "none";
        modalContent.style.left = initialLeft + "px";
        modalContent.style.top = initialTop + "px";
        modalContent.style.margin = "0"; // Reset margin jika ada
    });

    document.addEventListener('mousemove', function(e) {
        if (!isDragging) return;

        // Hitung selisih pergerakan mouse
        const dx = e.clientX - startX;
        const dy = e.clientY - startY;

        modalContent.style.left = (initialLeft + dx) + "px";
        modalContent.style.top = (initialTop + dy) + "px";
    });

    document.addEventListener('mouseup', function() {
        isDragging = false;
    });

    document.body.appendChild(modalContent);
};


// ===========================================================================
// âš™ï¸ ANALYSIS MODE INFO MODAL + PGN & FEN Loader
// ===========================================================================
myFunctions.showAnalysisModeInfoModal = function() {
    const existingModal = document.getElementById('analysisModeInfoModal');
    if (existingModal) existingModal.remove();

    // --- Overlay Modal ---
    const analysisModeInfoModal = document.createElement('div');
    analysisModeInfoModal.id = 'analysisModeInfoModal';
    analysisModeInfoModal.style = `
        position: fixed;
        z-index: 9999;
        background-color: rgba(0,0,0,0.6);
        display: flex; justify-content: center; align-items: center;
        width: 100%; height: 100%;
    `;

    // --- Konten Modal ---
    const modalContent = document.createElement('div');
    modalContent.style = `
        background-color: #fefefe;
        padding: 25px;
        max-width: 500px;
        border-radius: 10px;
        box-shadow: 0 8px 16px rgba(0,0,0,0.3);
        font-family: 'Open Sans', sans-serif;
        color: #333;
    `;

    // --- Judul ---
    const title = document.createElement('h3');
    title.textContent = "ðŸ” Analisa Mode & Auto Analysis";
    title.style = 'margin-top: 0; border-bottom: 2px solid #1a73e8; padding-bottom: 10px; color: #1a73e8;';
    modalContent.appendChild(title);

    // --- Isi Penjelasan ---
    const infoText = document.createElement('div');
    infoText.innerHTML = `
        <p>Di sini kamu bisa memahami cara kerja Analisa Mode & Auto Analysis.</p>
        <p>Kamu juga bisa langsung <b>paste PGN</b> atau <b>FEN</b> untuk dianalisa engine.</p>
    `;
    infoText.style = 'font-size: 14px; line-height: 1.5; color: #444;';
    modalContent.appendChild(infoText);

    // --- Textarea untuk PGN ---
    const pgnInput = document.createElement('textarea');
    pgnInput.id = 'pgnInputArea';
    pgnInput.rows = 6;
    pgnInput.style = `
        width: 100%; margin-top: 15px;
        font-family: monospace; font-size: 13px;
        padding: 8px; border: 1px solid #ccc; border-radius: 5px;
    `;
    pgnInput.placeholder = "Paste PGN di sini...";
    modalContent.appendChild(pgnInput);

    // --- Tombol Load PGN ---
    const loadPgnBtn = document.createElement('button');
    loadPgnBtn.textContent = 'Load PGN & Analisa';
    loadPgnBtn.style = `
        display: block; width: 100%;
        padding: 12px;
        background-color: #4CAF50; color: white;
        border: none; border-radius: 5px;
        margin-top: 10px; cursor: pointer;
        font-weight: bold;
    `;
    loadPgnBtn.onclick = function() {
        const pgnString = pgnInput.value.trim();
        if (pgnString) {
            myFunctions.loadPgnAndAnalyze(pgnString);
            analysisModeInfoModal.style.display = 'none';
        } else {
            alert("PGN kosong, silakan paste dulu.");
        }
    };
    modalContent.appendChild(loadPgnBtn);

    // --- Input FEN ---
    const fenInput = document.createElement('input');
    fenInput.id = 'fenInputField';
    fenInput.type = 'text';
    fenInput.style = `
        width: 100%; margin-top: 15px;
        font-family: monospace; font-size: 13px;
        padding: 8px; border: 1px solid #ccc; border-radius: 5px;
    `;
    fenInput.placeholder = "Masukkan FEN di sini...";
    modalContent.appendChild(fenInput);

    // --- Tombol Load FEN ---
    const loadFenBtn = document.createElement('button');
    loadFenBtn.textContent = 'Load FEN & Analisa';
    loadFenBtn.style = `
        display: block; width: 100%;
        padding: 12px;
        background-color: #FF9800; color: white;
        border: none; border-radius: 5px;
        margin-top: 10px; cursor: pointer;
        font-weight: bold;
    `;
    loadFenBtn.onclick = function() {
        const fenString = fenInput.value.trim();
        if (fenString) {
            myFunctions.loadFenAndAnalyze(fenString);
            analysisModeInfoModal.style.display = 'none';
        } else {
            alert("FEN kosong, silakan masukkan dulu.");
        }
    };
    modalContent.appendChild(loadFenBtn);

    // --- Tombol Tutup ---
    const closeBtn = document.createElement('button');
    closeBtn.textContent = 'Tutup';
    closeBtn.style = `
        display: block; width: 100%;
        padding: 12px;
        background-color: #1a73e8; color: white;
        border: none; border-radius: 5px;
        margin-top: 10px; cursor: pointer;
        font-weight: bold;
    `;
    closeBtn.onclick = function() { analysisModeInfoModal.style.display = 'none'; };
    modalContent.appendChild(closeBtn);

    analysisModeInfoModal.appendChild(modalContent);
    document.body.appendChild(analysisModeInfoModal);
};
// ===============================END====================================

// ===========================================================================================================================================
//
// ===========================================================================================================================================
myFunctions.updateOpponentMoveLabel = function(label, color = 'white') {
    let feedbackElement = document.getElementById('opponentMoveFeedback');

    if (!feedbackElement) {
        feedbackElement = document.createElement('div');
        feedbackElement.id = 'opponentMoveFeedback';
        feedbackElement.className = 'opponent-feedback';
        document.body.appendChild(feedbackElement);

        feedbackElement.style.cssText = `
            position: fixed;
            top: 10px;
            right: 10px;
            background: rgba(0,0,0,0.8);
            color: ${color};
            padding: 10px;
            border-radius: 5px;
            z-index: 10000;
            opacity: 0;
            transition: opacity 0.5s;
        `;

        myVars.feedbackTimer = null;

        feedbackElement.addEventListener('transitionend', () => {
            if (feedbackElement.style.opacity === '0') {
                feedbackElement.style.display = 'none';
                myVars.isFeedbackVisible = false;
            }
        });
    }

    feedbackElement.textContent = label;
    feedbackElement.style.color = color;
    feedbackElement.style.display = 'block';

    // Fade in
    requestAnimationFrame(() => {
        feedbackElement.style.opacity = '1';
        myVars.isFeedbackVisible = true;
    });

    // Reset timer
    clearTimeout(myVars.feedbackTimer);
    myVars.feedbackTimer = setTimeout(() => {
        feedbackElement.style.opacity = '0';
        myVars.feedbackTimer = null;
    }, 5000);
};
// ===========================================================================================================================================
// myFunctions.analyzeOpponentMove (Menganalisis kualitas langkah lawan (CPL))
// ===========================================================================================================================================
// ===========================================================================================================================================
// analyzeCurrentPosition (Mengirim command 'position' dan 'go' ke engine)
// ===========================================================================================================================================
function analyzeCurrentPosition(movetime = 2000, depth = null) {
    const fenString = myFunctions.getAccurateFen?.() || window.chess?.fen?.();
    if (!fenString) {
        console.warn("[Engine] FEN tidak tersedia untuk analisis.");
        return;
    }

    try {
        // 1. Kirim posisi
        engine.controller.send(`position fen ${fenString}`);

        // 2. Tentukan command 'go'
        let goCommand;
        if (depth && depth > 0) {
            goCommand = `go depth ${depth}`;
        } else if (movetime && movetime > 0) {
            goCommand = `go movetime ${movetime}`;
        } else {
            goCommand = `go depth 15`;
        }

        // 3. Kirim command ke engine
        engine.controller.send(goCommand);

        // 4. Update state
        myVars.isThinking = true;
        myFunctions.updateTurnStatus();

        console.log(`[Engine Run] Analisis dimulai. FEN=${fenString}, Command=${goCommand}`);
    } catch (err) {
        console.error("[Engine Run] Gagal menjalankan analisis:", err);
        myVars.isThinking = false;
    }
}

// ===============================END====================================
// ===========================================================================================================================================
// myFunctions.analyze (Memulai proses analisis posisi catur dengan engine)
// ===========================================================================================================================================
myFunctions.analyze = async function(depth = 6, targetEngineWorker = engine?.engine) {
    const finalDepth = myVars.customDepth || myVars.maxDepthForElo || depth;

    if (myVars.isThinking || !targetEngineWorker) {
        if (myVars.isThinking) console.warn("[Analyze] Engine sedang berpikir. Permintaan diabaikan.");
        if (!targetEngineWorker) console.error("[Analyze] Engine Worker tidak tersedia.");
        return null;
    }

    myFunctions.updateTurnStatus();

    const currentFen = myFunctions.getAccurateFen?.();

    if (!currentFen) {
        console.error("[Analyze] FEN posisi saat ini tidak dapat ditemukan.");

        return null;
    }


    console.log(`Menganalisa posisi: ${currentFen} (kedalaman: ${finalDepth})`);

    try {
        // Kirim posisi dan perintah ke worker
        if (myFunctions.sendUciCommand) {
            myFunctions.sendUciCommand(`position fen ${currentFen}`, targetEngineWorker);
            myFunctions.sendUciCommand(`go depth ${finalDepth}`, targetEngineWorker);
        } else {
            targetEngineWorker.postMessage(`position fen ${currentFen}`);
            targetEngineWorker.postMessage(`go depth ${finalDepth}`);
        }

        // Tunggu hasil dari runChessEngine yang sudah Promise-based
        const result = await myFunctions.runChessEngine?.(finalDepth, targetEngineWorker);

        console.log("Hasil analisis:", result);

        return result;

    } catch (err) {
        console.error("Gagal menjalankan analisis:", err);

        myFunctions.stopEngine?.(targetEngineWorker);
        return null;
    } finally {
        myFunctions.updateTurnStatus();
        myVars.topMoves = [];
    }
};
// ===========================================================================================================================================
// myFunctions.terminateEngine (Menghentikan worker engine)
// ===========================================================================================================================================
myFunctions.terminateEngine = function() {
    let enginesTerminated = 0;
    const enginesToTerminate = [
        { varName: 'analysisEngine', label: "AutoMove Engine" },
        { varName: 'deepAnalysisEngine', label: "Deep Analysis Engine" }
    ];

    const terminateSingleEngine = (engineVarName, label) => {
        if (myVars[engineVarName]) {
            try {
                // Beri sinyal 'quit' sebelum termination fisik
                myVars[engineVarName].postMessage("quit");
                myVars[engineVarName].terminate();
                myVars[engineVarName] = null;
                enginesTerminated++;
                myFunctions.log("ENGINE_CONTROL", `${label} dimatikan dan dibersihkan.`);
            } catch (err) {
                myFunctions.log("ENGINE_CONTROL", `Gagal terminate ${label}: ${err.message}`, "error");
            }
        }
    };

    enginesToTerminate.forEach(e => terminateSingleEngine(e.varName, e.label));

    // Reset status global
    myFunctions.updateTurnStatus();

    if (enginesTerminated > 0) {
        myFunctions.clearHighlights?.();
        myFunctions.log("ENGINE_CONTROL", `Total ${enginesTerminated} engine berhasil di-terminate.`);
    }
};
// ===============================END====================================
myFunctions.analyzeOpponentMove = () => {
    if (!myVars.previousEvaluation || !myVars.currentEvaluation) return;

    const prevScoreString = String(myVars.previousEvaluation.score || "");
    const currentScoreString = String(myVars.currentEvaluation.score || "");

    const prevEval = myFunctions.parseScoreToCP(prevScoreString);
    const currentEval = myFunctions.parseScoreToCP(currentScoreString);

    let cpGainEnginePerspective = currentEval - prevEval;

    if (myVars.myColor === 'black') {
        cpGainEnginePerspective *= -1;
    }

    const cpGain = cpGainEnginePerspective;

    const cpThresholds = { BLUNDER: 200, MISTAKE: 100, INACCURACY: 50 };
    let moveLabel = "";

    const mateMatch = currentScoreString.match(/M([+-]?\d+)/i);
    if (mateMatch) {
        const movesToMate = parseInt(mateMatch[1], 10) || 0;
        let weAreWinningMate = (myVars.myColor === 'white' && movesToMate > 0) || (myVars.myColor === 'black' && movesToMate < 0);

        moveLabel = weAreWinningMate
            ? `ðŸ‘‘ Lawan menuju MATI dalam ${Math.abs(movesToMate)} langkah!`
            : `â˜ ï¸ Kita menuju MATI dalam ${Math.abs(movesToMate)} langkah!`;

    } else if (cpGain >= cpThresholds.BLUNDER) {
        moveLabel = `ðŸ”¥ **BLUNDER Lawan!** (Gain +${cpGain.toFixed(0)} CP)`;
    } else if (cpGain >= cpThresholds.MISTAKE) {
        moveLabel = `âš ï¸ **MISTAKE Lawan** (Gain +${cpGain.toFixed(0)} CP)`;
    } else if (cpGain >= cpThresholds.INACCURACY) {
        moveLabel = `ðŸ¤” **Inaccuracy Lawan** (Gain +${cpGain.toFixed(0)} CP)`;
    } else if (cpGain >= -15) {
        moveLabel = `âœ… **Good Move / Neutral**`;
    } else {
        moveLabel = `ðŸ“‰ **Lawan Memperkuat Posisi**`;
    }

    if (typeof myFunctions.log === 'function') myFunctions.log("OPPONENT ANALYSIS", `Langkah Lawan: ${moveLabel}`);
    myFunctions.updateOpponentMoveLabel(moveLabel);

    myVars.previousEvaluation = null;
};
// ===============================END====================================

// ===========================================================================================================================================
// myFunctions.checkAndRunAnalysisAutoMove
// FINAL VERSION â€“ SAFE, STABLE, RACE-CONDITION FREE
// ===========================================================================================================================================

myFunctions.stopAnalysisEngineSafe = function () {
    if (myVars.analysisEngine) {
        try {
            myVars.analysisEngine.postMessage("stop");
        } catch (e) {
            console.warn("[Analysis] Engine stop failed:", e);
        }
    }
    clearTimeout(myVars.analysisDelayTimer);
    myVars.analysisDelayTimer = null;
};

// ======================================================================
// ðŸ¤– AUTO ANALYSIS + AUTO MOVE (FINAL â€“ NO LED CALLS)
// ======================================================================
myFunctions.checkAndRunAnalysisAutoMove = function () {

    // 0. HARD STOP GUARD + GAME OVER DETECTION
    const currentFEN = myVars.game?.fen?.();
    if (!currentFEN) {
        console.warn("[Analysis] Game object missing or invalid.");
        return;
    }

    // Deteksi game over via Chess.js
    if (typeof detectGameOver === 'function' && detectGameOver(currentFEN)) {
        console.log("[Analysis] Game Over terdeteksi, menghentikan engine.");
        myVars.isGameOver = true;
        myFunctions.stopAnalysisEngineSafe();
        myVars.lastAnalyzedFen = null;
        return;
    }

    if (!myVars.analysisMode) {
        myFunctions.stopAnalysisEngineSafe();
        myVars.lastAnalyzedFen = null;
        return;
    }

    // 1. VALIDASI GAME OBJECT
    const turn = currentFEN.split(' ')[1];
    const requiredTurn = myVars.autoAnalysisColor === 'white' ? 'w' :
    myVars.autoAnalysisColor === 'black' ? 'b' : null;

    // 2. ENGINE INITIALIZATION
    if (!myVars.analysisEngine) {
        myFunctions.loadAnalysisEngine?.();
        return;
    }

    // 3. GILIRAN CHECK
    if (!requiredTurn || turn !== requiredTurn) {
        myVars.lastAnalyzedFen = null;
        return;
    }

    // 4. ANTI-REPEATED ANALYSIS
    if (myVars.lastAnalyzedFen === currentFEN) {
        if (myVars.engineStatus !== ENGINE_STATUS1.THINKING) {
            // status READY bisa di-set di luar jika perlu
        }
        return;
    }

    // 5. ENGINE BUSY GUARD
    if (myVars.engineStatus === ENGINE_STATUS1.THINKING) return;

    // 6. DELAY SCHEDULER (HUMANIZING)
    const delayMs = myFunctions.getCalculatedDelay?.() || 1000;
    clearTimeout(myVars.analysisDelayTimer);
    myVars.analysisDelayTimer = setTimeout(() => {

        // 7. POST-DELAY SAFETY RE-CHECK
        const currentFenNow = myVars.game.fen();
        if (myVars.isGameOver || currentFenNow.split(' ')[1] !== requiredTurn) {
            return;
        }

        // 8. START ANALYSIS
        try {
            const depth = myVars.customDepth || 21;
            console.log("[Analysis] Engine mulai analisis...");

            myVars.analysisEngine.postMessage(`position fen ${currentFenNow}`);
            myVars.analysisEngine.postMessage(`go depth ${depth}`);

            myVars.lastAnalyzedFen = currentFenNow;
            myFunctions.startInactivityWatchdog?.();

        } catch (err) {
            console.error('[Analysis] Engine crash during postMessage:', err);
            myFunctions.safeStateReset?.('ENGINE_ERROR');
        }

    }, delayMs);
};

// ===========================================================================================================================================
// ðŸ“‹ Copy PGN ke Clipboard
// ===========================================================================================================================================
myFunctions.copyPgnToClipboard = function () {
    if (!myVars.game || typeof myVars.game.pgn !== 'function') return;

    const pgnText = myVars.game.pgn();

    navigator.clipboard.writeText(pgnText)
        .then(() => {
        console.log("[PGN] PGN berhasil disalin ke clipboard");
    })
        .catch(err => {
        console.error("[PGN] Gagal menyalin PGN:", err);
    });
};
// =============================== END ========================================


// ===========================================================================================================================================
// ðŸ“¥ Load PGN dan Analisa
// ===========================================================================================================================================
myFunctions.loadPgnAndAnalyze = function (pgnString) {
    if (!myVars.game || !pgnString) return;

    // Stop engine sebelum load
    myFunctions.stopAnalysisEngineSafe?.();

    myFunctions.setEngineState(ENGINE_STATE.READY);
    myVars.lastAnalyzedFen = null;

    const success = myVars.game.load_pgn(pgnString, { sloppy: true });

    if (success) {
        console.log("[LOAD] PGN berhasil dimuat");
        myFunctions.startAnalysisForCurrentPosition?.();
    } else {
        console.error("[LOAD] Gagal memuat PGN");
    }
};
// =============================== END ========================================


// ===========================================================================================================================================
// ðŸ“¥ Load FEN dan Analisa
// ===========================================================================================================================================
myFunctions.loadFenAndAnalyze = function (fenString) {
    if (!myVars.game || !fenString) return;

    myFunctions.stopAnalysisEngineSafe?.();
    myFunctions.setEngineState(ENGINE_STATE.READY);
    myVars.lastAnalyzedFen = null;

    const success = myVars.game.load(fenString);

    if (success) {
        console.log(`[LOAD] FEN berhasil dimuat: ${fenString}`);
        myFunctions.startAnalysisForCurrentPosition?.();
    } else {
        console.error("[LOAD] Gagal memuat FEN");
    }
};
// =============================== END ========================================


// ===========================================================================================================================================
// ðŸ”Ž Analisa Variasi (cek legalitas langkah SAN tanpa merusak state)
// ===========================================================================================================================================
myFunctions.analyzeVariation = function (moveSan) {
    if (!myVars.game || !moveSan) return false;

    const move = myVars.game.move(moveSan, { sloppy: true });
    if (!move) {
        console.warn(`[VAR] Langkah ilegal: ${moveSan}`);
        return false;
    }

    // rollback immediately
    myVars.game.undo();
    return true;
};
// =============================== END ========================================


// ===========================================================================================================================================
// âš™ï¸ Start Analysis For Current Position
// Menjalankan engine analisa pada posisi FEN saat ini
// ===========================================================================================================================================
myFunctions.startAnalysisForCurrentPosition = function (depth = 15) {
    if (!myVars.game) return;

    const currentFen = myVars.game.fen();
    if (!currentFen) {
        console.warn("[Analysis] FEN kosong, tidak bisa analisa.");
        return;
    }

    // Stop engine lama dulu
    myFunctions.stopAnalysisEngineSafe?.();

    // Reset state
    myVars.lastAnalyzedFen = null;
    myFunctions.setEngineState(ENGINE_STATE.READY);

    // Kirim posisi ke engine analisa
    try {
        myVars.analysisEngine.postMessage(`position fen ${currentFen}`);
        myVars.analysisEngine.postMessage(`go depth ${depth}`);
        console.log(`[Analysis] Analisa dimulai pada FEN: ${currentFen}`);
    } catch (err) {
        console.error("[Analysis] Gagal memulai analisa:", err);
    }
};
// =============================== END ========================================

// ===========================================================================
// âš™ï¸ RESET ANALYSIS STATES
// Reset semua flag analisis, highlight, dan status engine ke kondisi awal
// ===========================================================================
myFunctions.resetAnalysisStates = function() {
    if (myVars.analysisEngine) {
        myVars.analysisEngine.postMessage('stop');
        myVars.analysisEngine.postMessage('ucinewgame');
        console.log("[Analysis] Mesin analisis dihentikan dan permainan baru dimulai.");
    }

    myFunctions.clearHighlights();
    isAnalysisThinking = false;
    myVars.lastAnalyzedFen = null;
    myVars.highlightedMove = null;

    const evaluationFillAnalysisElement = document.getElementById('evaluationFillAnalysis');
    if (evaluationFillAnalysisElement) {
        evaluationFillAnalysisElement.style.width = '50%';
        evaluationFillAnalysisElement.style.backgroundColor = '#cccccc';
    }

    console.log("[Analysis State] Semua flag analisis, highlight, dan engine telah di-reset.");
};
// ===============================END====================================

// ===========================================================================
// âš™ï¸ MOVE PIECE ANALYSIS API
// Mengeksekusi langkah engine (bestmove) ke papan jika legal
// ===========================================================================
myFunctions.movePieceAnalysisAPI = function(bestmove) {
    const from = bestmove.substring(0, 2);
    const to = bestmove.substring(2, 4);
    const promotion = bestmove.length === 5 ? bestmove.substring(4) : null;

    // --- Bersihkan highlight sebelumnya ---
    myFunctions.clearHighlights();

    // --- Cari langkah legal yang cocok ---
    const legalMoves = board.game.getLegalMoves();
    for (const legalMove of legalMoves) {
        const isBaseMoveMatch = legalMove.from === from && legalMove.to === to;
        const isPromotionMatch = !promotion ? !legalMove.promotion : legalMove.promotion === promotion;

        if (isBaseMoveMatch && isPromotionMatch) {
            board.game.move({
                from: legalMove.from,
                to: legalMove.to,
                promotion: legalMove.promotion,
                animate: false,
                userGenerated: true
            });
            console.log(`[Analysis API] Langkah dieksekusi: ${legalMove.san}`);
            return;
        }
    }

    // --- Jika tidak ditemukan langkah legal ---
    console.warn(`[Analysis API] Gagal mengeksekusi gerakan ${bestmove}. Bukan gerakan legal.`);
};
// ===============================END====================================

// ===========================================================================
// âš™ï¸ TOGGLE AUTO ANALYSIS COLOR
// Mengatur warna auto analysis (Putih/Hitam/None) dan update status UI
// ===========================================================================
myFunctions.toggleAutoAnalysisColor = function(color) {
    const current = myVars.autoAnalysisColor;
    const newColor = (current === color && color !== 'none') ? 'none' : color;

    // --- Simpan state baru ---
    myVars.autoAnalysisColor = newColor;
    GM_setValue('autoAnalysisColor', newColor);

    // --- Flag status ---
    const isWhite = newColor === 'white';
    const isBlack = newColor === 'black';
    const isNone = newColor === 'none';

    // --- Update tombol UI ---
    $('#toggleAnalysisWhite')
        .toggleClass('is-active', isWhite)
        .find('.icon-check').html(isWhite ? 'â™– ' : '');
    $('#toggleAnalysisBlack')
        .toggleClass('is-active', isBlack)
        .find('.icon-check').html(isBlack ? 'â™Ÿï¸' : '');
    $('#toggleAnalysisNone').toggleClass('is-active', isNone);

    // --- Update teks status ---
    const statusMap = {
        white: '<span style="color: #64dd17; font-weight: 500;">Aktif (Engine Bermain Sebagai Putih)</span>',
        black: '<span style="color: #64dd17; font-weight: 500;">Aktif (Engine Bermain Sebagai Hitam)</span>',
        none: '<span style="color: #f44336; font-weight: 500;">Mati</span>'
    };
    $('#analysisStatusText').html('Status: ' + statusMap[newColor]);

    // --- Load/reset engine sesuai pilihan ---
    if (!isNone) {
        myFunctions.loadAnalysisEngine();
    } else {
        myFunctions.resetAnalysisStates();
    }
};
// ===============================END====================================
// ================== LOAD ANALYSIS ENGINE ==================
myFunctions.loadAnalysisEngine = function() {
    console.log("[Analysis] Loading analysis engine...");

    // --- Bersihkan engine lama ---
    if (myVars.analysisEngine) {
        myVars.analysisEngine.terminate();
        myVars.analysisEngine = null;
    }
    if (analysisObjectURL) {
        URL.revokeObjectURL(analysisObjectURL);
        analysisObjectURL = null;
    }

    // --- Inisialisasi engine baru ---
    try {
        analysisObjectURL = URL.createObjectURL(new Blob([GM_getResourceText('stockfish.js')], {
            type: 'application/javascript'
        }));
        myVars.analysisEngine = new Worker(analysisObjectURL);

        myVars.analysisEngine.onmessage = e => parserAnalysis(e);
        myVars.analysisEngine.onerror = e => console.error("[Analysis] Error:", e);

        myVars.analysisEngine.postMessage('uci');
        myVars.analysisEngine.postMessage('setoption name UCI_LimitStrength value true');

        const defaultElo = myVars.analysisElo || 1350;
        myVars.analysisEngine.postMessage(`setoption name UCI_Elo value ${defaultElo}`);
        myVars.analysisEngine.postMessage('setoption name MultiPV value 5');

        console.log("[Analysis] Engine loaded successfully.");
    } catch (error) {
        console.error("[Analysis] Engine load failed:", error);
    }
};

// ================== PARSER ANALYSIS ==================
function parserAnalysis(e) {
    let lastValue;

    // --- Parsing info depth + PV ---
    if (e.data.includes('info depth') && e.data.includes('pv')) {
        try {
            const parts = e.data.split(' ');
            const multipvIndex = parts.indexOf('multipv');
            const scoreIndex = parts.indexOf('score');
            const pvIndex = parts.indexOf('pv');

            if (multipvIndex !== -1 && scoreIndex !== -1 && pvIndex !== -1) {
                const pvString = parts.slice(pvIndex + 1).join(' ');
                const pvMoves = pvString.split(' ').filter(m => m.length > 1);
                myVars.currentPvMoves = pvMoves;

                const moveNumber = parseInt(parts[multipvIndex + 1]);
                const scoreType = parts[scoreIndex + 1];
                let scoreValue = parseInt(parts[scoreIndex + 2]);

                if (!isNaN(scoreValue)) {
                    if (moveNumber === 1) {
                        const bestMove = pvMoves[0];
                        const evalObject = {
                            move: bestMove,
                            scoreType: scoreType,
                            scoreValue: scoreValue,
                        };
                        myVars.topMoves[0] = evalObject;

                        // Update UI
                        const topMove1El = document.getElementById('topMove1');
                        const topMoveEval1El = document.getElementById('topMoveEval1');

                        if (topMove1El && topMoveEval1El) {
                            topMove1El.innerText = myVars.topMoves[0].move;
                            topMoveEval1El.innerText = myVars.topMoves[0].scoreType === 'cp'
                                ? (myVars.topMoves[0].scoreValue >= 0 ? '+' : '') + (myVars.topMoves[0].scoreValue / 100).toFixed(2)
                            : (myVars.topMoves[0].scoreValue > 0 ? 'M+' : 'M-') + Math.abs(myVars.topMoves[0].scoreValue);
                        }

                        myVars.lastEvalText1 = topMoveEval1El ? topMoveEval1El.innerText : '';
                        lastValue = myVars.topMoves[0].scoreValue;

                        let newEvalCp = lastValue;
                        if (myVars.topMoves[0].scoreType === 'mate') {
                            newEvalCp = (lastValue > 0) ? 50000 : -50000;
                        }
                        myVars.currentEvaluation = newEvalCp;
                    }

                    // Update visual eval bar
                    const maxEval = 5000;
                    let fillPercentage = 50;

                    if (scoreType === 'cp') {
                        scoreValue = Math.max(-maxEval, Math.min(scoreValue, maxEval));
                        fillPercentage = 50 + (scoreValue / maxEval) * 50;
                    } else if (scoreType === 'mate') {
                        fillPercentage = scoreValue > 0 ? 100 : 0;
                    }

                    fillPercentage = Math.max(0, Math.min(fillPercentage, 100));

                    const evaluationFillAnalysisElement = document.getElementById('evaluationFillAnalysis');
                    if (evaluationFillAnalysisElement) {
                        evaluationFillAnalysisElement.style.width = `${fillPercentage}%`;
                        evaluationFillAnalysisElement.classList.toggle('positive', scoreValue >= 0);
                        evaluationFillAnalysisElement.classList.toggle('negative', scoreValue < 0);
                    }

                    // ðŸ”¥ Gambar panah PV multi dengan angka
                    if (myVars.highlightEnabled && myVars.currentPvMoves.length > 0 && moveNumber === 1) {
                        const analyzedFEN = myVars.fenForPvDrawing || board.game.getFEN();
                        console.log("[Parser] Memanggil drawPvArrows dengan:", myVars.currentPvMoves);
                        if (myFunctions.drawPvArrows) {
                            myFunctions.drawPvArrows(myVars.currentPvMoves, analyzedFEN);
                        }
                    }
                }
            }
        } catch (error) {
            console.error("[Analysis] Error parsing evaluation info:", error, "Data:", e.data);
        }
    }

    // --- Parsing bestmove ---
    if (e.data.includes('bestmove')) {
        const parts = e.data.split(' ');
        const bestMove = parts[1];

        const bestMoveData = e.data;
        const currentLastEvalText = myVars.lastEvalText1;
        const finalEvalCp = myVars.currentEvaluation;
        let currentLastMoveGrade = null;

        // CPL calculation
        if (myVars.previousEvaluation !== undefined && myVars.previousEvaluation !== null) {
            const currentFEN = board.game.getFEN();
            const turnToMove = currentFEN.split(' ')[1];
            const playerWhoJustMoved = (turnToMove === 'w') ? 'b' : 'w';
            const playerWhoJustMovedIsWhite = (playerWhoJustMoved === 'w');

            const previousEvalCpNormalized = myFunctions.convertEvalToCentipawns(myVars.previousEvaluation, playerWhoJustMovedIsWhite);
            const currentEvalCpNormalized = myFunctions.convertEvalToCentipawns(finalEvalCp, playerWhoJustMovedIsWhite);

            const cplForMove = Math.max(0, previousEvalCpNormalized - currentEvalCpNormalized);

            currentLastMoveGrade = myFunctions.getMoveGrade(cplForMove);
            myVars.lastMoveGrade = currentLastMoveGrade;

            if (Math.abs(myVars.previousEvaluation) < 50000 && Math.abs(finalEvalCp) < 50000) {
                if (playerWhoJustMoved === 'b') {
                    myVars.totalCplBlack += cplForMove;
                    myVars.cplMoveCountBlack++;
                } else {
                    myVars.totalCplWhite += cplForMove;
                    myVars.cplMoveCountWhite++;
                }

                myVars.totalCpl = myVars.totalCplWhite + myVars.totalCplBlack;
                myVars.cplMoveCount = myVars.cplMoveCountWhite + myVars.cplMoveCountBlack;
                myVars.acplWhite = (myVars.cplMoveCountWhite > 0) ? (myVars.totalCplWhite / myVars.cplMoveCountWhite / 100).toFixed(2) : "0.00";
                myVars.acplBlack = (myVars.cplMoveCountBlack > 0) ? (myVars.totalCplBlack / myVars.cplMoveCountBlack / 100).toFixed(2) : "0.00";
                myVars.acplDisplay = (myVars.cplMoveCount > 0) ? (myVars.totalCpl / myVars.cplMoveCount / 100).toFixed(2) : "0.00";
            } else {
                if (playerWhoJustMoved === 'b') {
                    myVars.cplMoveCountBlack++;
                } else {
                    myVars.cplMoveCountWhite++;
                }
            }

            myFunctions.updateAcplDisplay();
            if (myFunctions.updateAcplGraph) {
                myFunctions.updateAcplGraph();
            }
        }

        myVars.previousEvaluation = finalEvalCp;
        myVars.fenForPvDrawing = null;

        isAnalysisThinking = false;
        myFunctions.updateTurnStatus();

        if (myFunctions.updateAnalysisThinkingStatus) {
            myFunctions.updateAnalysisThinkingStatus();
        }

        // Auto move analysis
        if (myVars.analysisMode && myVars.autoAnalysisColor !== 'none' && board && board.game) {
            const currentFEN = board.game.getFEN();
            const turn = currentFEN.split(' ')[1];
            const requiredTurn = myVars.autoAnalysisColor === 'white' ? 'w' : 'b';

            if (turn === requiredTurn) {
                const executionDelayMs = myFunctions.getCalculatedDelay();
                console.log(`[AutoMove Analisis] Langkah terbaik ditemukan: ${bestMove}. Menunggu ${executionDelayMs.toFixed(0)}ms untuk eksekusi.`);

                isAnalysisThinking = true;
                myFunctions.updateTurnStatus();
                if (myFunctions.updateAnalysisThinkingStatus) {
                    myFunctions.updateAnalysisThinkingStatus();
                }

                setTimeout(() => {
                    if (board && board.game && board.game.getFEN() === currentFEN) {
                        myFunctions.movePieceAnalysisAPI(bestMove);

                        if (myFunctions.addMoveToHistory) {
                            myFunctions.addMoveToHistory(bestMoveData, currentLastEvalText, finalEvalCp, currentLastMoveGrade);
                        }
                    }

                    isAnalysisThinking = false;
                    if (myFunctions.updateAnalysisThinkingStatus) {
                        myFunctions.updateAnalysisThinkingStatus();
                    }
                    myVars.lastAnalyzedFen = null;
                }, executionDelayMs);

                return;
            }
        }

        if (myFunctions.addMoveToHistory) {
            myFunctions.addMoveToHistory(e.data, currentLastEvalText, finalEvalCp, currentLastMoveGrade);
        }

        // Highlight best move
        if (bestMove && myVars.highlightEnabled) {
            if (myVars.highlightedMove !== bestMove) {
                myFunctions.clearHighlights();
                myFunctions.highlightMove(bestMove);
                myVars.highlightedMove = bestMove;
                console.log("[Analysis] Highlight move:", bestMove);
            }
        }
    }
}

// ================== RUN ANALYSIS MODE ==================
myFunctions.runAnalysisMode = function(depth = 5) {
    const currentFen = board.game.getFEN();
    const currentElo = myVars.analysisElo || 1350;

    if (isAnalysisThinking) return;
    if (currentFen === myVars.lastAnalyzedFen) return;

    if (!myVars.analysisEngine) {
        console.log("[Analysis] Memuat engine...");
        myFunctions.loadAnalysisEngine();
        setTimeout(() => myFunctions.runAnalysisMode(depth), 500);
        return;
    }

    // --- Stop analisis lama ---
    myVars.analysisEngine.postMessage('stop');

    // --- Update state ---
    myVars.lastAnalyzedFen = currentFen;
    myVars.fenForPvDrawing = currentFen;

    myVars.analysisEngine.postMessage('setoption name UCI_LimitStrength value true');
    myVars.analysisEngine.postMessage(`setoption name UCI_Elo value ${currentElo}`);

    // --- Mulai analisis ---
    isAnalysisThinking = true;
    myFunctions.updateTurnStatus();
    if (myFunctions.updateAnalysisThinkingStatus) {
        myFunctions.updateAnalysisThinkingStatus();
    }

    // --- Kirim posisi & mulai analisis ---
    myVars.analysisEngine.postMessage(`position fen ${currentFen}`);
    myVars.analysisEngine.postMessage(`go depth ${depth}`);
    console.log(`[Analysis] Analisis dimulai untuk FEN: ${currentFen} dengan depth: ${depth}`);
};
// ================== END ==================

// ================== SVG ARROW LAYER ==================
// Memastikan namespace objek tersedia


// ================== 1. KOORDINAT CONVERTER ==================
// Mengubah 'e2' menjadi '52' (format Chess.com) atau tetap 'e2'
myFunctions.algebraicToSquareId = function(alg) {
    if (!alg || alg.length < 2) return "";
    const files = ['a', 'b', 'c', 'd', 'e', 'f', 'g', 'h'];
    const f = files.indexOf(alg[0].toLowerCase()) + 1;
    const r = alg[1];
    return `${f}${r}`; // Mengembalikan format angka seperti "52"
};

// ================== 2. ENSURE SVG LAYER ==================
myFunctions.ensureArrowLayer = function() {
    // Cari board (mendukung berbagai platform)
    const board = document.querySelector('.board') ||
          document.querySelector('wc-chess-board') ||
          document.querySelector('chess-board') ||
          document.getElementById('board-single');

    if (!board) return null;

    let svg = board.querySelector('svg.arrows-svg');
    if (!svg) {
        svg = document.createElementNS('http://www.w3.org/2000/svg', 'svg');
        svg.setAttribute('class', 'arrows-svg');
        // Z-index tinggi agar di atas kepingan catur, pointer-events none agar tidak ganggu klik
        svg.setAttribute('style', 'position:absolute;top:0;left:0;width:100%;height:100%;pointer-events:none;z-index:1000;');
        board.appendChild(svg);
    }

    if (!svg.querySelector('defs')) {
        svg.appendChild(document.createElementNS('http://www.w3.org/2000/svg', 'defs'));
    }
    return svg;
};

// ================== 3. ENSURE MARKER (KEPALA PANAH) ==================
myFunctions.ensureArrowMarker = function(svg, color) {
    const markerId = `arrowhead-${color.replace('#','')}`;
    if (!svg.querySelector(`#${markerId}`)) {
        const defs = svg.querySelector('defs');
        const marker = document.createElementNS('http://www.w3.org/2000/svg', 'marker');
        marker.setAttribute('id', markerId);
        marker.setAttribute('markerWidth', '4');
        marker.setAttribute('markerHeight', '4');
        marker.setAttribute('refX', '2');
        marker.setAttribute('refY', '2');
        marker.setAttribute('orient', 'auto');

        const polygon = document.createElementNS('http://www.w3.org/2000/svg', 'polygon');
        polygon.setAttribute('points', '0 0, 4 2, 0 4, 1 2');
        polygon.setAttribute('fill', color);
        marker.appendChild(polygon);
        defs.appendChild(marker);
    }
    return markerId;
};

// ================== HYBRID PV ARROW SYSTEM (12.5% GRID) ==================

myFunctions.drawPvArrows = function(pvMoves, currentFen) {
    // 1. Bersihkan panah lama dengan class khusus
    document.querySelectorAll(".pv-highlight").forEach(el => el.remove());

    if (!myVars.highlightEnabled || !pvMoves || pvMoves.length === 0) return;

    const board = document.querySelector('chess-board') || document.querySelector('wc-chess-board');
    if (!board) return;

    // 2. Cek apakah papan dibalik (flipped)
    const isFlipped = board.classList.contains('flipped');

    // 3. Siapkan simulasi game
    const game = new Chess(currentFen);
    const movesToDraw = pvMoves.slice(0, 10);

    movesToDraw.forEach((rawMove, i) => {
        const uci = myFunctions.normalizeToUci(game, rawMove);
        if (!uci) return;

        const from = uci.substring(0, 2);
        const to = uci.substring(2, 4);

        // 4. Hitung Warna Gradasi (Hijau -> Kuning -> Merah)
        // Semakin besar i, semakin merah warnanya
        const red = Math.min(255, i * 60);
        const green = Math.max(0, 255 - (i * 40));
        const color = `rgb(${red}, ${green}, 0)`;

        // 5. Gambar Panah menggunakan koordinat persentase
        myFunctions.drawHybridArrow(board, from, to, color, isFlipped, i + 1);

        // Update state game untuk langkah PV berikutnya
        game.move(rawMove);
    });
};

myFunctions.drawHybridArrow = function(board, from, to, color, isFlipped, order) {
    const getPos = (square) => {
        const file = square.charCodeAt(0) - 97;
        const rank = parseInt(square[1]) - 1;
        const x = isFlipped ? (7 - file) : file;
        const y = isFlipped ? rank : (7 - rank);

        return {
            x: x * 12.5 + 6.25,
            y: y * 12.5 + 6.25
        };
    };

    let start = getPos(from);
    let end = getPos(to);

    // Hitung jarak untuk pemendekan ujung
    const dx = end.x - start.x;
    const dy = end.y - start.y;
    const length = Math.sqrt(dx * dx + dy * dy);

    // Nilai shorten diperkecil sedikit agar pas dengan kepala panah yang lebih kecil
    const shortenBy = 2.8;

    if (length > shortenBy) {
        const ratio = (length - shortenBy) / length;
        end.x = start.x + dx * ratio;
        end.y = start.y + dy * ratio;
    }

    const svg = document.createElementNS("http://www.w3.org/2000/svg", "svg");
    svg.setAttribute("class", "pv-highlight");
    svg.setAttribute("style", `position:absolute; top:0; left:0; width:100%; height:100%; pointer-events:none; z-index:1000; overflow:visible;`);

    // --- KEPALA PANAH LEBIH KECIL (Dikecilkan ke 4x4) ---
    const markerId = `head-${color.replace(/\s|,|\(|\)/g, "")}`;
    let defs = document.createElementNS("http://www.w3.org/2000/svg", "defs");
    defs.innerHTML = `
        <marker id="${markerId}" markerWidth="4.5" markerHeight="4.5" refX="2.25" refY="2.25" orient="auto">
            <polygon points="0 0, 4.5 2.25, 0 4.5, 1 2.25" fill="${color}" />
        </marker>`;
    svg.appendChild(defs);

    // --- BATANG PANAH LEBIH KURUS (Stroke Width 7) ---
    const line = document.createElementNS("http://www.w3.org/2000/svg", "line");
    line.setAttribute("x1", `${start.x}%`);
    line.setAttribute("y1", `${start.y}%`);
    line.setAttribute("x2", `${end.x}%`);
    line.setAttribute("y2", `${end.y}%`);
    line.setAttribute("stroke", color);
    line.setAttribute("stroke-width", "7"); // Dari 10 diturunkan ke 7 agar lebih ramping
    line.setAttribute("stroke-linecap", "round");
    line.setAttribute("opacity", "0.85");
    line.setAttribute("marker-end", `url(#${markerId})`);
    svg.appendChild(line);

    // --- NOMOR URUT (Disesuaikan sedikit lebih kecil) ---
    if (order !== undefined) {
        const midX = (start.x + end.x) / 2;
        const midY = (start.y + end.y) / 2;
        const text = document.createElementNS("http://www.w3.org/2000/svg", "text");
        text.setAttribute("x", `${midX}%`);
        text.setAttribute("y", `${midY}%`);
        text.setAttribute("fill", "white");
        text.setAttribute("stroke", "black");
        text.setAttribute("stroke-width", "0.6");
        text.setAttribute("font-size", "17px"); // Sedikit lebih kecil agar serasi dengan panah kurus
        text.setAttribute("font-weight", "bold");
        text.setAttribute("text-anchor", "middle");
        text.setAttribute("dominant-baseline", "middle");
        text.setAttribute("paint-order", "stroke");
        text.textContent = order;
        svg.appendChild(text);
    }

    board.appendChild(svg);
};

// ================== CLEAR ARROWS ==================
myFunctions.clearArrows = function() {
    const svg = document.querySelector('svg.arrows-svg');
    if (!svg) return;
    svg.querySelectorAll('path[id^="pv-arrow-"], text[id^="pv-arrow-"]').forEach(el => el.remove());
};

// ================== CLEAR HIGHLIGHTS ==================
myFunctions.clearHighlights = function() {
    // Hapus highlight kotak
    document.querySelectorAll('.highlight.analysis').forEach(el => el.remove());
    myVars.analysisHighlights = [];

    // Hapus layer arrows highlight
    const svgHighlight = document.querySelector('svg.highlight-arrows-svg');
    if (svgHighlight) {
        svgHighlight.querySelectorAll('path[id^="highlight-arrow-"], text[id^="highlight-arrow-"]').forEach(el => el.remove());
    }

    // Hapus layer arrows PV
    const svgPV = document.querySelector('svg.pv-arrows-svg');
    if (svgPV) {
        svgPV.querySelectorAll('path[id^="pv-arrow-"], text[id^="pv-arrow-"]').forEach(el => el.remove());
    }
};

// ================== DRAW PV ARROWS ==================
// ===============================END====================================

/// ======================================================================
//
// ======================================================================
myFunctions.getFullMoveUci = function(tempGame, move) {
    if (!tempGame || !move) return null;
    try {
        const r = tempGame.move(move, { sloppy: true });
        if (!r) return null;
        return (r.from || '') + (r.to || '') + (r.promotion || '');
    } catch (e) {
        return null;
    }
};
// ===============================END====================================
// Normalize move to UCI. If already UCI (e2e4 or with promotion), return as-is.
// Otherwise try converting SAN -> UCI via chess.js.
myFunctions.normalizeToUci = function(tempGame, move) {
    if (!move) return null;
    const uciPattern = /^[a-h][1-8][a-h][1-8][qrbn]?$/i;
    if (uciPattern.test(move)) return move.toLowerCase();
    // fallback: attempt SAN -> UCI through chess.js
    try {
        const r = tempGame.move(move, { sloppy: true });
        if (!r) return null;
        return (r.from || '') + (r.to || '') + (r.promotion || '');
    } catch {
        return null;
    }
};

// ===========================================================================
// âš™ï¸ HIGHLIGHT MOVE
// Menyorot langkah tertentu di papan dengan warna sesuai giliran
// ===========================================================================
myFunctions.highlightMove = function(move) {
    myFunctions.clearHighlights();

    if (!myVars.analysisMode) return;

    // move biasanya berformat uci: "e2e4"
    const from = move.substring(0, 2); // "e2"
    const to = move.substring(2, 4); // "e4"

    const boardNode = document.querySelector('chess-board') || document.querySelector('wc-chess-board');
    if (!boardNode) return;

    // Cek apakah papan sedang di-flip
    const isFlipped = boardNode.classList.contains('flipped');

    // Tentukan warna berdasarkan giliran (opsional)
    const highlightColor = (boardNode.game?.getTurn() === 'w') ? "#00FF00" : "#FFD700";

    // 1. Buat highlight kotak (visual kotak di sekeliling pion)
    // Kita tetap pakai koordinat angka untuk class CSS square agar highlight kotak muncul
    const fromSquare = myFunctions.algebraicToSquareId(from);
    const toSquare = myFunctions.algebraicToSquareId(to);

    const highlightFrom = myFunctions.createHighlight(fromSquare, highlightColor, 'analysis');
    const highlightTo = myFunctions.createHighlight(toSquare, highlightColor, 'analysis');

    // 2. Panggil fungsi Hybrid yang baru (INI PERBAIKANNYA)
    // Kita arahkan ke drawHybridArrow, bukan drawArrow
    myFunctions.drawHybridArrow(boardNode, from, to, highlightColor, isFlipped, "!");
    myFunctions.drawArrow = myFunctions.drawHybridArrow;

    myVars.analysisHighlights.push(highlightFrom, highlightTo);
};
// ===============================END====================================

// ===============================END====================================

// ===========================================================================
// âš™ï¸ CREATE HIGHLIGHT
// Membuat elemen highlight (div) di kotak papan dengan warna tertentu
// ===========================================================================
myFunctions.createHighlight = function(squareName, color, className) {
    const boardNode = document.querySelector('chess-board') || document.querySelector('wc-chess-board');
    const highlight = document.createElement('div');
    highlight.className = `highlight square-${squareName} ${className}`;
    highlight.style.border = `5px solid ${color}`;
    highlight.style.backgroundColor = 'transparent';
    highlight.style.opacity = '1';
    boardNode.appendChild(highlight);
    return highlight;
};
// ===============================END====================================

myFunctions.updateAnalysisThinkingStatus = function() {
    const led = document.getElementById('engine-led');
    const statusText = document.getElementById('engine-status-text');

    if (isAnalysisThinking) {
        if (led) {
            led.style.background = "#ff9800"; // Warna Oranye saat mikir
            led.style.boxShadow = "0 0 8px #ff9800";
        }
        if (statusText) statusText.innerText = "Thinking...";
    } else {
        if (led) {
            led.style.background = "#4caf50"; // Kembali Hijau saat siap
            led.style.boxShadow = "none";
        }
        if (statusText) statusText.innerText = "Analysis ready";
    }
};

// ======================================================================
// ðŸ”„ MASTER LOOP (FINAL: INTEGRATED ON/OFF AUTO-SYNC + ELO VALIDATION)
// Loop utama sinkronisasi UI, engine, dan status
// ======================================================================
const masterLoop = setInterval(() => {
    // Example Watchdog (run this elsewhere)
    setInterval(() => {
        if (myVars.isThinking && (Date.now() - myVars.lastMoveTime > 15000)) {
            console.warn("Engine stuck? Resetting state.");
            myVars.isThinking = false;
            engine.engine.postMessage("stop");
        }
    }, 5000);

    // -------------------------------------------------------------------
    // ðŸ–¼ï¸ LOAD UI PANEL
    // -------------------------------------------------------------------
    if (!document.getElementById('chess-ui-overlay')) {
        myFunctions.loadEx();
        return;
    }
    myFunctions.spinner();

    // -------------------------------------------------------------------
    // ðŸ“Š UPDATE DEPTH & FEN
    // -------------------------------------------------------------------
    let currentFen = null;

    if (board && board.game) {
        currentFen = board.game.getFEN();
    }

    if (myVars.panelState !== 'minimized') {
        const currentDepthEl = document.getElementById('depthValue');
        if (currentDepthEl) currentDepthEl.innerText = myVars.customDepth;

        const currentFenEl = document.getElementById('currentFen');
        if (currentFenEl && currentFen) {
            currentFenEl.innerText = currentFen;
        }
    }

    // -------------------------------------------------------------------
    // ðŸŽ¯ SINKRONISASI ELO LAWAN (DENGAN SAKLAR ON/OFF)
    // -------------------------------------------------------------------
    if (myVars.autoSyncElo) {
        const opponentRatingRaw = extractOpponentRating();
        const opponentRating = parseInt(opponentRatingRaw, 10);

        if (!isNaN(opponentRating) && opponentRating >= 100 && opponentRating <= 3190) {
            const now = Date.now();
            const ratingChanged = opponentRating !== myVars.opponentRating;
            const logExpired = !myVars.lastLogTime || (now - myVars.lastLogTime > 10000);

            if (ratingChanged || logExpired) {
                myVars.opponentRating = opponentRating;
                myVars.lastLogTime = now;
                myVars.eloRating = opponentRating;

                // Update Teks ELO Lawan di pojok UI
                myFunctions.updateOpponentEloUI(opponentRating);

                // Adaptasi depth otomatis (berdasarkan ELO)
                if (myVars.adaptToRating && typeof myFunctions.calculateDepthFromElo === 'function') {
                    const newDepth = myFunctions.calculateDepthFromElo(opponentRating);
                    myFunctions.updateDepthUI(newDepth);
                }

                // --- SINKRONISASI SLIDER & INPUT ---
                const eloSlider = document.getElementById('elo-rating-slider');
                const eloValueDisplay = document.getElementById('eloValueDisplay');
                const eloInput = document.getElementById('eloManualInput');

                if (eloSlider) {
                    eloSlider.value = opponentRating;
                    eloSlider.dispatchEvent(new Event('input', { bubbles: true }));
                }
                if (eloValueDisplay) eloValueDisplay.textContent = opponentRating;
                if (eloInput) eloInput.value = opponentRating;

                // Terapkan ELO ke engine (limit strength)
                if (typeof myFunctions.setEngineStrength === 'function') {
                    myFunctions.setEngineStrength(opponentRating);
                } else if (typeof myFunctions.setEngineElo === 'function') {
                    myFunctions.setEngineElo(opponentRating);
                }

                GM_setValue('eloRating', opponentRating);
                console.log(`[Auto-Sync] ELO Lawan Terdeteksi: ${opponentRating}`);
            }
        } else {
            console.warn("[Auto-Sync] Invalid opponent rating:", opponentRatingRaw);
        }
    } else {
        // Jika OFF, hanya update tampilan rating lawan tanpa mengubah slider/engine
        const opponentRatingRaw = extractOpponentRating();
        const opponentRating = parseInt(opponentRatingRaw, 10);
        if (!isNaN(opponentRating)) {
            myFunctions.updateOpponentEloUI(opponentRating);
        } else {
            myFunctions.updateOpponentEloUI('-');
        }
    }

    // -------------------------------------------------------------------
    // ðŸ”‘ DETEKSI GILIRAN & UPDATE STATUS
    // -------------------------------------------------------------------
    if (board && board.game && typeof myFunctions.updateTurnStatus === 'function') {
        const playingAs = board.game.getPlayingAs();
        const currentTurnChar = board.game.getTurn();

        if (playingAs && currentTurnChar) {
            if (currentTurnChar === playingAs) {
                myVars.currentTurn = 'me';
                myTurn = true;
            } else {
                myVars.currentTurn = 'opponent';
                myTurn = false;
            }
            myFunctions.updateTurnStatus();
        }
    }

    // -------------------------------------------------------------------
    // ðŸ” AUTO MATCH
    // -------------------------------------------------------------------
    if (myVars.autoMatchEnabled && !myVars.gameEnded) {
        const gameOverModal = document.querySelector('.game-over-modal-content');
        if (gameOverModal) {
            myVars.gameEnded = true;
            myFunctions.autoMatch();
        }
    }

    // -------------------------------------------------------------------
    // â™Ÿï¸ ENGINE LOADING
    // -------------------------------------------------------------------
    if (!engine.engine) {
        myFunctions.loadChessEngine();
    }

    // -------------------------------------------------------------------
    // ðŸ” ANALYSIS MODE
    // -------------------------------------------------------------------
    if (myVars.analysisMode && currentFen) {
        myFunctions.runAnalysisMode(myVars.customDepth || 21);
    }

    // -------------------------------------------------------------------
    // ðŸ¤– AUTO RUN
    // -------------------------------------------------------------------
    if (myVars.autoRun && canGo && !myVars.isThinking && myTurn && !myVars.gameEnded) {
        canGo = false;
        const currentDelay = myFunctions.getCalculatedDelay();
        scheduleAutoRun(currentDelay);
    }

}, 500); // interval 500ms
}
// ===============================END====================================

// ===========================================================================
// ðŸŒ VARIABEL GLOBAL & DEFINISI AWAL
// ===========================================================================

// Status engine
var isThinking = false; // Apakah engine sedang berpikir
var canGo = true; // Flag apakah engine boleh jalan
var myTurn = false; // Apakah giliran kita
var isAnalysisThinking = false; // Mode analisis aktif atau tidak

// Board & interaksi
var board; // Objek papan catur (misalnya Chessboard.js)
var lastValue; // Nilai evaluasi terakhir
var firstClickSquare = null; // Square pertama yang diklik (untuk mode 2 klik)
var isTwoClickModeActive = true; // Apakah mode 2 klik aktif

// Namespace fungsi utilitas (pastikan global)
var myFunctions = window.myFunctions || {};
var myVars = window.myVars || {};

// Histori permainan
var engineMoveHistory = []; // Riwayat langkah engine
var acplHistory = []; // Average Centipawn Loss history
var evalHistory = []; // Riwayat evaluasi engine

// ===========================================================================
// DEFINISI FUNGSI HELPER (Termasuk safeInitMyVar)
// ===========================================================================
function safeInitMyVar(key, defaultValue) {
    if (typeof myVars === 'object' && typeof myVars[key] === 'undefined') {
        myVars[key] = defaultValue;
    }
}
// ===========================================================================
// INISIALISASI VARIABEL DENGAN HELPER (Panggil di sini)
// ===========================================================================

// Panggil setelah myVars dibuat dan safeInitMyVar didefinisikan:
safeInitMyVar('topMoves', []);
safeInitMyVar('totalCplWhite', 0);
safeInitMyVar('cplMoveCountWhite', 0);
safeInitMyVar('totalCplBlack', 0);
safeInitMyVar('cplMoveCountBlack', 0);
safeInitMyVar('previousEvaluation', 0);
safeInitMyVar('currentEvaluation', 0);
safeInitMyVar('lastMoveGrade', 'N/A');
safeInitMyVar('_autoRunLock', false); // Variabel lock baru

// ===========================================================================
// ðŸš€ INIT (FIXED & SAFE)
// ===========================================================================
window.addEventListener("load", () => {
    main();

    // =======================
    // UI Overlay
    // =======================
    if (typeof myFunctions.loadEx === "function") {
        myFunctions.loadEx();
        console.log("[INIT] Panel UI dimuat.");
    }

    // =======================
    // ACPL Init
    // =======================
    setTimeout(() => {
        if (typeof myFunctions.updateAcplDisplay === "function") {
            myFunctions.updateAcplDisplay();
        }
    }, 500);

    // =======================
    // UI Tambahan
    // =======================
    if (typeof myFunctions.setupClockSyncUI === "function") {
        myFunctions.setupClockSyncUI();
    }

    // =======================
    // Game Over Check
    // =======================
    if (typeof myFunctions.checkAndHandleGameOver === "function") {
        myVars.gameOverCheckInterval = setInterval(myFunctions.checkAndHandleGameOver, 5000);
    }

    // =======================
    // Engine Selector
    // =======================
    if (typeof myFunctions.createEngineSelectorUI === "function") {
        myFunctions.createEngineSelectorUI();
    }
    if (typeof setupEngineSelector === "function") {
        setupEngineSelector();
    }

    // =======================
    // Health & LED Monitor
    // =======================
    if (typeof myFunctions.healthMonitor === "function") {
        setInterval(myFunctions.healthMonitor, 5000);
    }
    if (typeof myFunctions.updateEngineLeds === "function") {
        setInterval(myFunctions.updateEngineLeds, 1000);
    }

    // =======================
    // Clear History Button
    // =======================
    const clearBtn = document.getElementById('clearHistoryBtn');
    if (clearBtn && typeof myFunctions.clearMoveHistory === "function") {
        clearBtn.addEventListener('click', myFunctions.clearMoveHistory);
    }

    // Pastikan panah digambar ulang setiap kali board berubah
    const boardObserver = new MutationObserver(() => {
        // Jika engine sedang jalan, panggil fungsi draw lagi
        if (myVars.lastPvMoves && myVars.lastFen) {
            myFunctions.drawPvArrows(myVars.lastPvMoves, myVars.lastFen);
        }
    });

    const targetBoard = document.querySelector('chess-board') || document.querySelector('wc-chess-board');
    if (targetBoard) {
        boardObserver.observe(targetBoard, { attributes: true, childList: true, subtree: false });
    }

    // Interval pengecekan posisi awal (New Game)
    setInterval(() => {
        try {
            const boardElement = document.querySelector('chess-board') || document.querySelector('wc-chess-board');
            if (!boardElement || !boardElement.game) return;

            const fen = boardElement.game.getFEN?.() || "";

            // Deteksi posisi awal (New Game)
            const isStartingPos = fen.startsWith("rnbqkbnr/pppppppp");
            if (isStartingPos && myVars.isGameOver) {
                console.log("[System] Detected new game start â†’ Resetting...");
                if (typeof myFunctions.resetForNewGame === "function") {
                    myFunctions.resetForNewGame();

                }
            }
        } catch (e) {
            console.debug("[System] DOM transition error ignored:", e);
        }
    }, 1000); // cek tiap 1 detik


    // =======================
    // Script Health Check
    // =======================
    if (!myVars.healthCheckInterval && typeof myFunctions.checkScriptHealth === "function") {
        myVars.healthCheckInterval = setInterval(myFunctions.checkScriptHealth, 5000);
        console.log('[INIT] Health Check Interval aktif.');
    }
});
})();
