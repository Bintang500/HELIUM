// ==UserScript==
// @name         Chess Helper Pro - Best Move Analyzer with PV Arrows123
// @namespace    http://tampermonkey.net/
// @version      4.0
// @description  Advanced chess analysis with Stockfish API - PV arrows with move numbers, modern UI panel
// @author       Chess Helper Pro
// @match        https://www.chess.com/*
// @match        https://lichess.org/*
// @grant        GM_getValue
// @grant        GM_setValue
// @grant        GM_xmlhttpRequest
// @grant        GM_addStyle
// @connect      stockfish.online
// @connect      chess-api.com
// @run-at       document-end
// ==/UserScript==

(async function () {
    'use strict';

    // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
    // SINGLE INSTANCE GUARD
    // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
    if (window.__GABIBOT_PRO_RUNNING__) {
        console.log('GabiBot Pro: Already running, skipping init.');
        return;
    }
    window.__GABIBOT_PRO_RUNNING__ = true;

    // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
    // CONSTANTS
    // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê

    const VERSION = '2.0.0';
    const SCRIPT_NAME = 'GabiBot Pro';
    const STORAGE_KEY = 'GabiBot_Pro_Settings'; // SATU key saja!

    // API Configuration
    const API_URL = 'https://stockfish.online/api/s/v2.php';
    const CHESS_API_WS = 'wss://chess-api.com/v1';
    const MULTIPV = 3;
    const ANALYZE_TIMEOUT_MS = 8000;

    // Timing Constants
    const AUTO_MOVE_BASE = 800;
    const AUTO_MOVE_STEP = 100;
    const RANDOM_JITTER_MIN = 50;
    const RANDOM_JITTER_MAX = 200;
    const GAME_CACHE_TTL = 500;
    const TICK_MIN_INTERVAL = 150;
    const MAX_AUTO_MATCH_ATTEMPTS = 5;
    const AUTO_MATCH_COOLDOWN = 3000; // 3 seconds between attempts

    // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
    // UTILITY FUNCTIONS
    // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê

    function debounce(fn, wait = 150) {
        let timeout = null;
        return function(...args) {
            clearTimeout(timeout);
            timeout = setTimeout(() => fn.apply(this, args), wait);
        };
    }

    function throttle(fn, limit = 100, { leading = true, trailing = true } = {}) {
        let inThrottle = false;
        let lastArgs = null;
        let timeoutId = null;

        const throttled = function(...args) {
            if (!inThrottle && leading) {
                fn.apply(this, args);
                inThrottle = true;
                timeoutId = setTimeout(() => {
                    inThrottle = false;
                    if (trailing && lastArgs) {
                        fn.apply(this, lastArgs);
                        lastArgs = null;
                    }
                }, limit);
            } else {
                lastArgs = args;
            }
        };

        throttled.cancel = () => {
            clearTimeout(timeoutId);
            inThrottle = false;
            lastArgs = null;
        };

        return throttled;
    }

    const sleep = (ms) => new Promise(resolve => setTimeout(resolve, ms));

    const qs = (sel, root = document) => root.querySelector(sel);
    const qsa = (sel, root = document) => Array.from(root.querySelectorAll(sel));

    const randomInt = (min, max) => Math.floor(Math.random() * (max - min + 1)) + min;

    const clamp = (value, min, max) => Math.max(min, Math.min(max, value));

    // Deep clone dengan structuredClone (lebih aman)
    function deepClone(obj) {
        try {
            return structuredClone(obj);
        } catch (e) {
            // fallback jika structuredClone tidak tersedia
            if (obj === null || typeof obj !== 'object') return obj;
            if (Array.isArray(obj)) return obj.map(deepClone);

            const cloned = {};
            for (const key in obj) {
                if (Object.prototype.hasOwnProperty.call(obj, key)) {
                    cloned[key] = deepClone(obj[key]);
                }
            }
            return cloned;
        }
    }

    // Tunggu elemen muncul di DOM dengan observer yang aman
    async function waitForElement(selector, timeout = 15000) {
        return new Promise((resolve, reject) => {
            try {
                const existing = qs(selector);
                if (existing) return resolve(existing);

                let timeoutId;
                const observer = new MutationObserver(() => {
                    try {
                        const el = qs(selector);
                        if (el) {
                            clearTimeout(timeoutId);
                            observer.disconnect(); // langsung berhenti
                            resolve(el);
                        }
                    } catch (err) {
                        console.error("Error in MutationObserver:", err);
                    }
                });

                observer.observe(document.body, { childList: true, subtree: true });

                timeoutId = setTimeout(() => {
                    observer.disconnect();
                    reject(new Error(`Element "${selector}" not found within ${timeout}ms`));
                }, timeout);
            } catch (error) {
                reject(error);
            }
        });
    }

    // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
    // LOGGER - Centralized Logging
    // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê

    const LogLevel = { ERROR: 0, WARN: 1, INFO: 2, DEBUG: 3 };

    const Logger = {
        _getLevel() {
            // fallback ke INFO kalau BotState belum ada
            try {
                return LogLevel[BotState?.logLevel?.toUpperCase()] ?? LogLevel.INFO;
            } catch {
                return LogLevel.INFO;
            }
        },

        _format(level, ...args) {
            const timestamp = new Date().toLocaleTimeString();
            return [`[${SCRIPT_NAME}][${timestamp}][${level}]`, ...args];
        },

        error(...args) {
            if (this._getLevel() >= LogLevel.ERROR) {
                console.error(...this._format('ERROR', ...args));
            }
        },

        warn(...args) {
            if (this._getLevel() >= LogLevel.WARN) {
                console.warn(...this._format('WARN', ...args));
            }
        },

        info(...args) {
            if (this._getLevel() >= LogLevel.INFO) {
                console.log(...this._format('INFO', ...args));
            }
        },

        debug(...args) {
            if (this._getLevel() >= LogLevel.DEBUG) {
                console.log(...this._format('DEBUG', ...args));
            }
        },

        // Quick log without level check
        log(...args) {
            console.log(`${SCRIPT_NAME}:`, ...args);
        }
    };

    // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
    // BOT STATE - Configuration
    // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê

    const BotState = {
        // ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
        // MAIN TOGGLES
        // ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
        hackEnabled: true,
        autoMove: false,
        analysisMode: false,

        // ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
        // ENGINE SETTINGS
        // ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
        botPower: 12,
        eloRating: 2000,
        multiPV: 3,

        // ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
        // SPEED SETTINGS
        // ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
        updateSpeed: 8,
        autoMoveSpeed: 5,
        randomDelay: true,
        useSecondDelay: false,
        minDelay: 0.1,
        maxDelay: 5.0,
        minDelayTwo: 0.1,
        maxDelayTwo: 1.0,

        // ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
        // DISPLAY SETTINGS
        // ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
        highlightEnabled: false,
        showPVArrows: false,
        pvArrowCount: 3,
        arrowWidth: 4,
        pvArrowWidth: 3,
        highlightColor1: '#7fa650',
        highlightColor2: '#4287f5',
        pvArrowColor: 'rgba(255, 170, 0, 0.6)',

        // ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
        // PREMOVE SETTINGS
        // ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
        premoveEnabled: false,
        premoveMode: 'safe',
        premovePieces: { q: true, r: true, b: true, n: true, k: false, p: true },
        premoveChance: 85,
        premoveSafetyThreshold: 50,

        // ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
        // AUTO FEATURES
        // ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
        autoRematch: false,
        autoMatchEnabled: false,
        autoMatchDelay: 5000,
        autoMatchRatingFilter: false,
        autoMatchMinRating: 800,
        autoMatchMaxRating: 2000,
        autoMatchDeclineRematch: true,
        autoMatchAllowRematch: true,

        // ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
        // PANEL STATE (UI)
        // ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
        panelState: 'maximized',
        panelTop: null,
        panelLeft: null,
        panelWidth: 380,
        panelHeight: 450,
        panelOpacity: 1.0,
        panelTheme: 'dark',

        // ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
        // DEBUG & LOGGING
        // ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
        debugMode: false,
        logLevel: 'info',
        showPerformanceStats: false,

        // ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
        // RUNTIME DATA (Not Persisted)
        // ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
        currentEvaluation: '-',
        bestMove: '-',
        principalVariation: '-',
        pvMoves: [],
        topMoves: [],
        statusInfo: 'Ready',
        currentFen: '-',
        lastEval: null,
        lastAnalysisTime: 0,

        STOCKFISH_API: 'https://stockfish.online/api/s/v2.php',
        CHESS_API_WS: 'wss://chess-api.com/v1',

        // Engine Settings
        DEPTH: 15, // Kedalaman analisis (1-15 untuk SF Online)
        MAX_THINKING_TIME: 100, // Max thinking time dalam ms

        // Mode Settings
        USE_STOCKFISH_ONLINE: true, // Gunakan Stockfish Online API (recommended)
        USE_WEBSOCKET: false, // Gunakan Chess-API WebSocket

        // Features
        AUTO_ANALYZE: true, // Auto analisis saat posisi berubah
        AUTO_ANALYZE_DELAY: 800, // Delay sebelum auto analyze (ms)
        SHOW_ARROWS: true, // Tampilkan arrow untuk best move
        HIGHLIGHT_SQUARES: true, // Highlight kotak from/to

        // Hotkeys
        HOTKEY_ANALYZE: ' ', // Spasi untuk analisis
        HOTKEY_TOGGLE: 'h', // H untuk hide/show panel

        // Reconnect Settings (WebSocket)
        RECONNECT_INTERVAL: 3000,
        MAX_RECONNECT_INTERVAL: 60000,

        // ===================================================================
        // --- CLOCK SYNC SETTINGS ---
        // ===================================================================
        clockSyncEnabled: GM_getValue('clockSyncEnabled', false),

        // Clock Time Data
        lastOpponentTime: null,
        lastPlayerTime: null,

        // Delay Configuration
        clockSyncMinDelay: GM_getValue('clockSyncMinDelay', 1.5),
        clockSyncMaxDelay: GM_getValue('clockSyncMaxDelay', 5.0),

        // Game Time Information
        incrementSeconds: GM_getValue('incrementSeconds', 0),
        moveNumber: GM_getValue('moveNumber', 0),

        // Time Pressure Settings
        clockSyncTimePressure: GM_getValue('clockSyncTimePressure', true),
        clockSyncTimePressureThreshold: GM_getValue('clockSyncTimePressureThreshold', 20),
        clockSyncTimePressureActive: false,

        // Player Information
        myColor: GM_getValue('myColor', 'white'),

        // Advanced Settings (optional)
        clockSyncExactMatch: GM_getValue('clockSyncExactMatch', false),
        clockSyncCalculationTime: GM_getValue('clockSyncCalculationTime', 0.2),

        // Request Settings
        TIMEOUT: 10000 // Timeout untuk HTTP request
    };

    // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
    // BOT STATE DEFAULTS - Deep Clone!
    // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê

    const BotStateDefaults = (() => {
        try {
            return structuredClone(BotState);
        } catch {
            // fallback clone
            return JSON.parse(JSON.stringify(BotState));
        }
    })();

    // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
    // RUNTIME KEYS (Not saved to localStorage)
    // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê

    const RUNTIME_KEYS = Object.freeze([
        'currentEvaluation', 'bestMove', 'principalVariation',
        'pvMoves', 'topMoves', 'statusInfo', 'currentFen',
        'lastEval', 'lastAnalysisTime'
    ]);

    // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
    // BOT STATE CONSTRAINTS
    // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê

    const BotStateConstraints = Object.freeze({
        // Engine
        botPower: { min: 1, max: 20, type: 'number' },
        eloRating: { min: 100, max: 3500, type: 'number' },
        multiPV: { min: 1, max: 5, type: 'number' },

        // Speed
        updateSpeed: { min: 1, max: 10, type: 'number' },
        autoMoveSpeed: { min: 1, max: 10, type: 'number' },
        minDelay: { min: 0, max: 30, type: 'number' },
        maxDelay: { min: 0.1, max: 60, type: 'number' },
        minDelayTwo: { min: 0, max: 10, type: 'number' },
        maxDelayTwo: { min: 0.1, max: 30, type: 'number' },

        // Clock Sync
        clockSyncMinDelay: { min: 0.1, max: 30, type: 'number' },
        clockSyncMaxDelay: { min: 0.1, max: 30, type: 'number' },
        clockSyncTimePressureThreshold: { min: 5, max: 60, type: 'number' },
        clockSyncCalculationTime: { min: 0.1, max: 5, type: 'number' },
        incrementSeconds: { min: 0, max: 600, type: 'number' },
        moveNumber: { min: 0, max: 200, type: 'number' },

        // Display
        pvArrowCount: { min: 1, max: 10, type: 'number' },
        arrowWidth: { min: 1, max: 10, type: 'number' },
        pvArrowWidth: { min: 1, max: 10, type: 'number' },

        // Premove
        premoveChance: { min: 0, max: 100, type: 'number' },
        premoveSafetyThreshold: { min: 0, max: 100, type: 'number' },

        // Auto Match
        autoMatchDelay: { min: 1000, max: 60000, type: 'number' },
        autoMatchMinRating: { min: 0, max: 3500, type: 'number' },
        autoMatchMaxRating: { min: 0, max: 4000, type: 'number' },

        // Panel
        panelWidth: { min: 200, max: 800, type: 'number' },
        panelHeight: { min: 200, max: 1000, type: 'number' },
        panelOpacity: { min: 0.3, max: 1.0, type: 'number' },

        // Enums
        premoveMode: {
            type: 'enum',
            values: ['off', 'every', 'capture', 'filter', 'safe', 'winning']
        },
        panelState: {
            type: 'enum',
            values: ['maximized', 'minimized', 'collapsed']
        },
        panelTheme: {
            type: 'enum',
            values: ['dark', 'light', 'auto']
        },
        logLevel: {
            type: 'enum',
            values: ['error', 'warn', 'info', 'debug']
        },
        myColor: {
            type: 'enum',
            values: ['white', 'black']
        }
    });

    // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
    // SafeStorage Wrapper (aman jika localStorage tidak tersedia)
    // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
    const SafeStorage = {
        _memory: {},
        getItem(key) {
            try {
                return localStorage.getItem(key);
            } catch {
                return this._memory[key] || null;
            }
        },
        setItem(key, value) {
            try {
                localStorage.setItem(key, value);
            } catch {
                this._memory[key] = value;
            }
        },
        removeItem(key) {
            try {
                localStorage.removeItem(key);
            } catch {
                delete this._memory[key];
            }
        }
    };

    // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
    // BOT STATE UTILITIES - UNIFIED (Satu sistem saja!)
    // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê

    const BotStateUtils = {
        _saveTimeout: null,
        _initialized: false,

        // Validate a value against constraints
        validate(key, value) {
            const constraint = BotStateConstraints[key];
            if (!constraint) return value;

            switch (constraint.type) {
                case 'number': {
                    const num = parseFloat(value);
                    if (isNaN(num)) return BotStateDefaults[key];
                    let clamped = clamp(num, constraint.min, constraint.max);

                    // Validasi khusus delay agar min ‚â§ max
                    if (key === 'minDelay' && clamped > BotState.maxDelay) clamped = BotState.maxDelay;
                    if (key === 'maxDelay' && clamped < BotState.minDelay) clamped = BotState.minDelay;
                    if (key === 'minDelayTwo' && clamped > BotState.maxDelayTwo) clamped = BotState.maxDelayTwo;
                    if (key === 'maxDelayTwo' && clamped < BotState.minDelayTwo) clamped = BotState.minDelayTwo;

                    return clamped;
                }
                case 'enum': {
                    return constraint.values.includes(value)
                        ? value
                    : BotStateDefaults[key];
                }
                case 'boolean': {
                    return Boolean(value);
                }
                default:
                    return value;
            }
        },

        // Set a value with validation
        set(key, value) {
            if (!(key in BotState)) {
                Logger.warn(`Unknown BotState key: "${key}"`);
                return false;
            }

            const oldValue = BotState[key];
            const newValue = this.validate(key, value);

            if (oldValue === newValue) return true; // No change

            BotState[key] = newValue;

            if (!RUNTIME_KEYS.includes(key)) {
                this.scheduleSave();
            }

            Logger.debug(`BotState.${key}: ${oldValue} ‚Üí ${newValue}`);
            return true;
        },

        // Get a value
        get(key) {
            return BotState[key];
        },

        // Check if key should be persisted
        isPersistedKey(key) {
            return !RUNTIME_KEYS.includes(key);
        },

        // Reset to defaults
        reset(keys = null) {
            if (keys === null) {
                Object.keys(BotStateDefaults).forEach(key => {
                    if (this.isPersistedKey(key)) {
                        BotState[key] = structuredClone(BotStateDefaults[key]);
                    }
                });
            } else if (Array.isArray(keys)) {
                keys.forEach(key => {
                    if (key in BotStateDefaults) {
                        BotState[key] = structuredClone(BotStateDefaults[key]);
                    }
                });
            }
            this.save();
            Logger.info('Settings reset to defaults');
        },

        // Scheduled save (debounced)
        scheduleSave() {
            if (this._saveTimeout) clearTimeout(this._saveTimeout);
            this._saveTimeout = setTimeout(() => this.save(), 300);
        },

        // Save to SafeStorage
        save() {
            try {
                const toSave = {};
                Object.keys(BotState).forEach(key => {
                    if (this.isPersistedKey(key)) {
                        toSave[key] = BotState[key];
                    }
                });

                SafeStorage.setItem(STORAGE_KEY, JSON.stringify(toSave));
                Logger.debug('Settings saved');
                return true;
            } catch (error) {
                Logger.error('Failed to save settings:', error);
                return false;
            }
        },

        // Load from SafeStorage
        load() {
            try {
                this._migrateOldSettings();

                const saved = SafeStorage.getItem(STORAGE_KEY);
                if (!saved) {
                    Logger.info('No saved settings found, using defaults');
                    return false;
                }

                const parsed = JSON.parse(saved);
                let loadedCount = 0;

                Object.keys(parsed).forEach(key => {
                    if (key in BotState && this.isPersistedKey(key)) {
                        BotState[key] = this.validate(key, parsed[key]);
                        loadedCount++;
                    }
                });

                Logger.info(`Loaded ${loadedCount} settings`);
                this._initialized = true;
                return true;
            } catch (error) {
                Logger.error('Failed to load settings:', error);
                return false;
            }
        },

        // Migrate from old storage keys
        _migrateOldSettings() {
            const oldKeys = ['gabibot_pro_settings', 'GabiBot_Settings'];

            for (const oldKey of oldKeys) {
                if (oldKey === STORAGE_KEY) continue;

                try {
                    const oldData = SafeStorage.getItem(oldKey);
                    if (oldData) {
                        Logger.info(`Migrating settings from "${oldKey}"`);
                        const parsed = JSON.parse(oldData);

                        Object.keys(parsed).forEach(key => {
                            if (key in BotState && this.isPersistedKey(key)) {
                                BotState[key] = this.validate(key, parsed[key]);
                            }
                        });

                        SafeStorage.removeItem(oldKey);
                        this.save();
                        Logger.info(`Migration complete, removed "${oldKey}"`);
                    }
                } catch (e) {
                    Logger.warn(`Failed to migrate from "${oldKey}":`, e);
                }
            }
        },

        // Export as JSON string
        export() {
            const toExport = {};
            Object.keys(BotState).forEach(key => {
                if (this.isPersistedKey(key)) {
                    toExport[key] = BotState[key];
                }
            });
            return JSON.stringify(toExport, null, 2);
        },

        // Import from JSON string
        import(jsonString) {
            try {
                const parsed = JSON.parse(jsonString);
                let importedCount = 0;

                Object.keys(parsed).forEach(key => {
                    if (this.set(key, parsed[key])) {
                        importedCount++;
                    }
                });

                Logger.info(`Imported ${importedCount} settings`);
                return true;
            } catch (error) {
                Logger.error('Failed to import settings:', error);
                return false;
            }
        },

        // Get summary for display
        getSummary() {
            return {
                version: VERSION,
                enabled: BotState.hackEnabled,
                engine: {
                    depth: BotState.botPower,
                    elo: BotState.eloRating
                },
                timing: {
                    delay: BotState.useSecondDelay
                    ? `${BotState.minDelayTwo}-${BotState.maxDelayTwo}s`
                    : `${BotState.minDelay}-${BotState.maxDelay}s`
            },
                premove: {
                    enabled: BotState.premoveEnabled,
                    mode: BotState.premoveMode
                }
            };
        }
    };

    // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
    // TYPE-SAFE GETTERS
    // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê

    function isBotEnabled() {
        return Boolean(BotState.hackEnabled);
    }

    function isAutoMoveEnabled() {
        return Boolean(BotState.autoMove) && isBotEnabled();
    }

    function isPremoveEnabled() {
        return Boolean(BotState.premoveEnabled) && isBotEnabled();
    }

    function isAutoMatchEnabled() {
        return Boolean(BotState.autoMatchEnabled) && isBotEnabled();
    }

    function isDebugMode() {
        return Boolean(BotState.debugMode);
    }

    function getDepth() {
        return BotStateUtils.validate('botPower', BotState.botPower);
    }

    // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
    // DEPTH & DELAY HELPERS
    // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
    function getRandomDepth() {
        const minDepth = 5;
        const maxDepth = Math.max(BotState.botPower || 12, minDepth);
        return Math.floor(Math.random() * (maxDepth - minDepth + 1)) + minDepth;
    }

    // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
    // GLOBAL VARIABLES - Complete
    // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê

    // Cache
    const PositionCache = {};

    // UI References
    let ui = null;
    let boardCtx = null;

    // Observers & Timers
    let domObserver = null;
    let tickTimer = null;
    let gameEndInterval = null;
    let gameStartInterval = null;
    let clockInterval = null;
    let autoMatchInterval = null;

    // State Flags
    let autoStartTriggered = false;
    let isTickRunning = false;
    let autoMatchInProgress = false;
    let autoMatchAttempts = 0;

    // Analysis
    let analysisQueue = Promise.resolve();
    let currentAnalysisId = 0;

    // FEN Tracking
    let lastFenProcessedMain = '';
    let lastFenProcessedPremove = '';
    let lastFenSeen = '';

    // PV & Move Data
    let lastPVData = [];
    let pendingMoveTimeoutId = null;

    // Premove Tracking
    let lastPremoveFen = '';
    let lastPremoveUci = '';

    // Game Cache
    let cachedGame = null;
    let cachedGameTimestamp = 0;

    // Board Orientation
    let cachedBoardFlipped = false;
    let cachedFlipTimestamp = 0;

    // Managed Timeouts
    let pendingTimeouts = [];

    let ws = null;

    // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
    // MANAGED TIMEOUT HELPERS
    // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê

    function managedTimeout(callback, delay, label = '') {
        const timeoutId = setTimeout(() => {
            // Hapus dari daftar timeout aktif
            pendingTimeouts = pendingTimeouts.filter(t => t.id !== timeoutId);
            try {
                callback();
            } catch (error) {
                Logger.error(`Error in timeout [${label}]:`, error);
            }
        }, delay);

        pendingTimeouts.push({ id: timeoutId, label, created: Date.now(), delay });
        Logger.debug(`Managed timeout created [${label}] with delay ${delay}ms`);
        return timeoutId;
    }

    function clearManagedTimeout(timeoutId) {
        clearTimeout(timeoutId);
        pendingTimeouts = pendingTimeouts.filter(t => t.id !== timeoutId);
        Logger.debug(`Managed timeout cleared: ${timeoutId}`);
    }

    function clearAllManagedTimeouts() {
        pendingTimeouts.forEach(t => clearTimeout(t.id));
        Logger.info(`Cleared ${pendingTimeouts.length} managed timeouts`);
        pendingTimeouts = [];
    }

    // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
    // DELAY HELPERS - Improved
    // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê

    // ===========================================================================================================================================
    // parseTimeString (Mengkonversi string waktu catur (M:SS.ms, H:M:SS) menjadi detik)
    // ===========================================================================================================================================
    function parseTimeString(timeString) {
        if (!timeString || typeof timeString !== 'string') return null;

        // Bersihkan string, hanya sisakan angka, titik, dan titik dua
        const cleanTime = timeString.replace(/[^\d:.]/g, '');

        // Mencoba mencocokkan format H:M:S, M:S, atau S
        const parts = cleanTime.split(':').map(p => parseFloat(p) || 0);

        let totalSeconds = 0;

        if (parts.length === 3) {
            // Format H:M:S.ms
            const [hours, minutes, seconds] = parts;
            totalSeconds = hours * 3600 + minutes * 60 + seconds;
        } else if (parts.length === 2) {
            // Format M:S.ms
            const [minutes, seconds] = parts;
            totalSeconds = minutes * 60 + seconds;
        } else if (parts.length === 1) {
            // Format S.ms (hanya detik)
            totalSeconds = parts[0];
        }

        return totalSeconds > 0 ? totalSeconds : (totalSeconds === 0 ? 0 : null);
    }
    // ===============================END====================================

    // ===========================================================================================================================================
    // getClockTimes (Mengambil waktu jam catur kedua pemain dalam detik)
    // ===========================================================================================================================================
    function getClockTimes() {
        try {
            const clockSelectors = [
                '.clock-time-monospace[role="timer"]',
                '.clock-time-monospace',
                '.clock-component .clock-time-monospace',
                '#board-layout-player-top .clock-time-monospace',
                '#board-layout-player-bottom .clock-time-monospace'
            ];

            let allClockElements = [];
            for (const selector of clockSelectors) {
                const elements = document.querySelectorAll(selector);
                if (elements.length > 0) {
                    allClockElements = Array.from(elements);
                    break;
                }
            }

            if (allClockElements.length === 0) {
                return { opponentTime: null, playerTime: null, found: false };
            }

            let opponentTime = null;
            let playerTime = null;

            if (allClockElements.length >= 2) {
                const opponentTimeText = allClockElements[0].textContent || allClockElements[0].innerText;
                const playerTimeText = allClockElements[1].textContent || allClockElements[1].innerText;

                opponentTime = parseTimeString(opponentTimeText);
                playerTime = parseTimeString(playerTimeText);
            } else if (allClockElements.length === 1) {
                const timeText = allClockElements[0].textContent || allClockElements[0].innerText;
                const parentElement = allClockElements[0].closest('.player-component, [class*="player"], [class*="top"], [class*="bottom"]');

                if (parentElement) {
                    const parentClass = parentElement.className.toLowerCase();
                    const myColor = BotState.myColor || 'white';

                    if (parentClass.includes('top') || parentClass.includes('opponent') ||
                        (myColor === 'black' && parentClass.includes('white')) ||
                        (myColor === 'white' && parentClass.includes('black'))) {
                        opponentTime = parseTimeString(timeText);
                    } else if (parentClass.includes('bottom') || parentClass.includes('player') ||
                               (myColor === 'white' && parentClass.includes('white')) ||
                               (myColor === 'black' && parentClass.includes('black'))) {
                        playerTime = parseTimeString(timeText);
                    }
                }
            }

            const result = {
                opponentTime: opponentTime,
                playerTime: playerTime,
                found: opponentTime !== null || playerTime !== null
            };

            return result;

        } catch (error) {
            Logger.error('Clock Sync: Detection error:', error);
            return { opponentTime: null, playerTime: null, found: false };
        }
    }
    // ===============================END====================================

    // ===========================================================================================================================================
    // calculateDynamicMoveTime (Menghitung waktu langkah dinamis berdasarkan sisa waktu)
    // ===========================================================================================================================================
    function calculateDynamicMoveTime(myTimeMs, incrementMs, moveNumber) {
        const minThinkTime = 100; // Minimum delay, 100ms
        const maxThinkTime = 5000; // Maximum delay, 5 detik
        const estimatedTotalMoves = 60; // Asumsi total 60 langkah per pemain

        // Waktu yang harus dipertahankan per langkah
        const remainingMoves = Math.max(1, estimatedTotalMoves - moveNumber);
        const timeForAverageMove = (myTimeMs / remainingMoves);

        // Gunakan 1/20 dari sisa waktu ditambah sedikit inkremen
        let calculatedTime = (myTimeMs / 20) + (incrementMs / 2);

        // Batasi waktu berpikir agar tidak terlalu cepat atau terlalu lambat
        let finalDelay = Math.min(calculatedTime, timeForAverageMove, maxThinkTime);
        finalDelay = Math.max(finalDelay, minThinkTime);

        // Tambahkan sedikit variasi acak (humanisasi)
        const jitter = Math.random() * 200 - 100; // Jitter antara -100ms hingga +100ms
        finalDelay = Math.max(minThinkTime, finalDelay + jitter);

        Logger.debug(`[Clock Sync] Calculated Think Time: ${finalDelay.toFixed(0)}ms (Your Time: ${(myTimeMs/1000).toFixed(1)}s)`);

        return finalDelay;
    }
    // ===============================END====================================

    // ===========================================================================================================================================
    // calculateClockSyncDelay (Menghitung penundaan langkah berdasarkan waktu jam pemain)
    // ===========================================================================================================================================
    function calculateClockSyncDelay() {
        if (!BotState.clockSyncEnabled) {
            return 0;
        }

        const clockData = getClockTimes();

        // Periksa apakah data jam pemain dan waktu inkremen tersedia
        if (clockData.found && clockData.playerTime !== null &&
            BotState.incrementSeconds !== undefined && BotState.moveNumber !== undefined) {

            // Konversi waktu ke milidetik untuk fungsi Dinamis
            const myTimeMs = clockData.playerTime * 1000;
            const incrementMs = BotState.incrementSeconds * 1000;
            const moveNum = BotState.moveNumber;

            // Gunakan Kalkulasi Dinamis
            return calculateDynamicMoveTime(myTimeMs, incrementMs, moveNum);

        } else {
            // Fallback: Gunakan delay min/max yang dikonfigurasi
            const minDelaySec = BotState.clockSyncMinDelay || 1.5;
            const maxDelaySec = BotState.clockSyncMaxDelay || 5.0;

            const randomDelay = (Math.random() * (maxDelaySec - minDelaySec) + minDelaySec) * 1000;

            // Jika waktu pemain sangat sedikit (‚â§20 detik), gunakan delay minimal
            if (clockData.playerTime !== null && clockData.playerTime <= 20) {
                Logger.debug('[Clock Sync] Low time detected, using minimal delay');
                return 300;
            }

            Logger.debug(`[Clock Sync] Fallback delay: ${randomDelay.toFixed(0)}ms`);
            return randomDelay;
        }
    }
    // ===============================END====================================

    // ===========================================================================================================================================
    // getCalculatedDelay (Mendapatkan penundaan langkah, menggunakan clock sync jika diaktifkan)
    // ===========================================================================================================================================
    function getCalculatedDelay() {
        if (BotState.clockSyncEnabled) {
            // Gunakan Clock Sync Delay
            const clockDelay = calculateClockSyncDelay();
            if (clockDelay > 0) {
                Logger.debug(`[Delay] Using Clock Sync: ${clockDelay.toFixed(0)}ms`);
                return clockDelay;
            }
        }

        // Logika Delay Standar (Jika Clock Sync dimatikan atau gagal)
        let minD = BotState.useSecondDelay ? BotState.minDelayTwo : BotState.minDelay;
        let maxD = BotState.useSecondDelay ? BotState.maxDelayTwo : BotState.maxDelay;

        minD = parseFloat(minD) || 1.5;
        maxD = parseFloat(maxD) || 5.0;

        const currentDelay = (Math.random() * (maxD - minD) + minD) * 1000;
        Logger.debug(`[Delay] Using Standard: ${currentDelay.toFixed(0)}ms`);
        return currentDelay;
    }
    // ===============================END====================================

    // ===========================================================================================================================================
    // getQuickDelay (Delay cepat untuk aksi UI)
    // ===========================================================================================================================================
    function getQuickDelay() {
        const delay = randomInt(50, 150);
        Logger.debug(`Quick delay: ${delay}ms`);
        return delay;
    }
    // ===============================END====================================

    // ===========================================================================================================================================
    // getMediumDelay (Delay medium untuk aksi UI)
    // ===========================================================================================================================================
    function getMediumDelay() {
        const delay = randomInt(200, 500);
        Logger.debug(`Medium delay: ${delay}ms`);
        return delay;
    }
    // ===============================END====================================

    // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
    // STATE RESET & CLEANUP
    // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê

    function resetRuntimeState() {
        // Reset runtime data in BotState
        BotState.currentEvaluation = '-';
        BotState.bestMove = '-';
        BotState.principalVariation = '-';
        BotState.pvMoves = [];
        BotState.topMoves = [];
        BotState.statusInfo = 'Ready';
        BotState.currentFen = '-';
        BotState.lastEval = null;
        BotState.lastAnalysisTime = 0;

        // Reset tracking variables
        lastFenProcessedMain = '';
        lastFenProcessedPremove = '';
        lastFenSeen = '';
        lastPVData = [];
        lastPremoveFen = '';
        lastPremoveUci = '';

        // Reset flags
        isTickRunning = false;
        autoMatchInProgress = false;
        autoMatchAttempts = 0;
        autoStartTriggered = false;

        // Reset analysis
        currentAnalysisId++;

        // Reset cache
        cachedGame = null;
        cachedGameTimestamp = 0;
        cachedBoardFlipped = false;
        cachedFlipTimestamp = 0;

        Logger.info('Runtime state reset');
    }

    function cleanup() {
        Logger.info('Cleaning up...');

        // Clear all intervals
        if (tickTimer) { clearInterval(tickTimer); tickTimer = null; }
        if (gameEndInterval) { clearInterval(gameEndInterval); gameEndInterval = null; }
        if (gameStartInterval) { clearInterval(gameStartInterval); gameStartInterval = null; }
        if (clockInterval) { clearInterval(clockInterval); clockInterval = null; }
        if (autoMatchInterval) { clearInterval(autoMatchInterval); autoMatchInterval = null; }

        // Clear pending move
        if (pendingMoveTimeoutId) { clearTimeout(pendingMoveTimeoutId); pendingMoveTimeoutId = null; }

        // Clear managed timeouts
        clearAllManagedTimeouts();

        // Disconnect observer
        if (domObserver) { domObserver.disconnect(); domObserver = null; }

        // Reset state
        resetRuntimeState();

        Logger.info('Cleanup complete');
    }

    // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
    // PANEL HTML TEMPLATES
    // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
    const contentTemplates = {
        'engine-settings': () => `
        <div class="panel-content-inner">
            <h4 class="section-title">‚öôÔ∏è Engine Settings</h4>

            <div class="info-row">
                <span>Depth: <strong id="depthValue">${BotState.botPower}</strong></span>
                <span>Elo: <strong id="eloValueDisplay">${BotState.eloRating}</strong></span>
            </div>

            <div class="setting-row">
                <label>Set Elo:</label>
                <input type="range" id="elo-rating-slider" min="1350" max="3000" step="50" value="${BotState.eloRating}" class="range-slider">
            </div>

            <div class="setting-row">
                <label>Set Depth:</label>
                <input type="range" id="custom-depth-slider" min="1" max="20" step="1" value="${BotState.botPower}" class="range-slider">
            </div>

            <div class="divider"></div>

            <div class="setting-row toggle-row" data-active="${BotState.hackEnabled ? 1 : 0}">
                <label>ü§ñ Enable Bot:</label>
                <!-- Panel Promosi -->
               <div id="promotion-panel">
                <select id="promotion-select">
                <option value="q">Queen ‚ôï</option>
                <option value="r">Rook ‚ôñ</option>
                <option value="b">Bishop ‚ôó</option>
                <option value="n">Knight ‚ôò</option>
                </select>
                </div>
                <button type="button" id="toggleHack" class="on-off-button ${BotState.hackEnabled ? 'on' : 'off'}">
                    ${BotState.hackEnabled ? 'ON' : 'OFF'}
                </button>
            </div>

            <div class="setting-row toggle-row" data-active="${BotState.autoMove ? 1 : 0}">
                <label>üéØ Auto Move:</label>
                <button type="button" id="toggleAutoMove" class="on-off-button ${BotState.autoMove ? 'on' : 'off'}">
                    ${BotState.autoMove ? 'ON' : 'OFF'}
                </button>
            </div>

            <div class="divider"></div>

            <div class="setting-row toggle-row" data-active="${BotState.autoMatchEnabled ? 1 : 0}">
                <label>üîÑ Auto New Game:</label>
                <button type="button" id="toggleAutoMatch" class="on-off-button ${BotState.autoMatchEnabled ? 'on' : 'off'}">
                    ${BotState.autoMatchEnabled ? 'ON' : 'OFF'}
                </button>
            </div>

            <div class="divider"></div>

            <div class="setting-group">
                <h5>‚è±Ô∏è Clock Sync Settings</h5>

                <div class="setting-row toggle-row" data-active="${BotState.clockSyncEnabled ? 1 : 0}">
                    <label>üïê Enable Clock Sync:</label>
                    <button type="button" id="toggleClockSync" class="on-off-button ${BotState.clockSyncEnabled ? 'on' : 'off'}">
                        ${BotState.clockSyncEnabled ? 'ON' : 'OFF'}
                    </button>
                </div>

                <div class="setting-row">
                    <label>Min Delay (s):</label>
                    <input type="number" id="minDelayValue" min="0.1" max="30" step="0.1"
                           value="${BotState.clockSyncMinDelay || 1.5}"
                           ${BotState.clockSyncEnabled ? '' : 'disabled'}
                           class="number-input">
                </div>

                <div class="setting-row">
                    <label>Max Delay (s):</label>
                    <input type="number" id="maxDelayValue" min="0.1" max="30" step="0.1"
                           value="${BotState.clockSyncMaxDelay || 5.0}"
                           ${BotState.clockSyncEnabled ? '' : 'disabled'}
                           class="number-input">
                </div>
            </div>
        </div>
    `,

        'main-control': () => `
        <div class="panel-content-inner">
            <h4 class="section-title">‚è±Ô∏è Delay & Speed Control</h4>

            <div class="setting-row toggle-row" data-active="${BotState.useSecondDelay ? 1 : 0}">
                <label>‚ö° Delay Mode:</label>
                <button type="button" id="toggleSecondDelay" class="on-off-button ${BotState.useSecondDelay ? 'on' : 'off'}">
                    ${BotState.useSecondDelay ? 'FAST' : 'NORMAL'}
                </button>
            </div>
            <div class="status-text">
                ${BotState.useSecondDelay ? '‚ö° Fast Mode Active (Bullet/Blitz)' : 'üê¢ Normal Mode Active (Rapid/Classical)'}
            </div>

            <div class="divider"></div>

            <h5 class="subsection-title">üê¢ Normal Mode Delay</h5>
            <div class="setting-row">
                <label>Min Delay (s):</label>
                <input type="number" id="timeDelayMin" min="0.1" step="0.1" value="${BotState.minDelay}" class="number-input">
            </div>
            <div class="setting-row">
                <label>Max Delay (s):</label>
                <input type="number" id="timeDelayMax" min="0.1" step="0.1" value="${BotState.maxDelay}" class="number-input">
            </div>

            <div class="divider"></div>

            <h5 class="subsection-title">‚ö° Fast Mode Delay</h5>
            <div class="setting-row">
                <label>Min Delay (s):</label>
                <input type="number" id="timeDelayMinTwo" min="0.05" step="0.05" value="${BotState.minDelayTwo}" class="number-input">
            </div>
            <div class="setting-row">
                <label>Max Delay (s):</label>
                <input type="number" id="timeDelayMaxTwo" min="0.05" step="0.05" value="${BotState.maxDelayTwo}" class="number-input">
            </div>

            <div class="divider"></div>

            <div class="setting-row">
                <label>Update Speed:</label>
                <input type="range" id="updateSpeedSlider" min="1" max="10" step="1" value="${BotState.updateSpeed}" class="range-slider">
                <span id="updateSpeedValue">${BotState.updateSpeed}</span>
            </div>
        </div>
    `,

        'display-setting': () => `
        <div class="panel-content-inner">
            <h4 class="section-title">üñ•Ô∏è Display Settings</h4>

            <div class="setting-row toggle-row" data-active="${BotState.highlightEnabled ? 1 : 0}">
                <label>‚ú® Highlight Moves:</label>
                <button type="button" id="toggleHighlight" class="on-off-button ${BotState.highlightEnabled ? 'on' : 'off'}">
                    ${BotState.highlightEnabled ? 'ON' : 'OFF'}
                </button>
            </div>

            <div class="setting-row toggle-row" data-active="${BotState.showPVArrows ? 1 : 0}">
                <label>üìç Show PV Arrows:</label>
                <button type="button" id="togglePVArrows" class="on-off-button ${BotState.showPVArrows ? 'on' : 'off'}">
                    ${BotState.showPVArrows ? 'ON' : 'OFF'}
                </button>
            </div>

            <div class="setting-row">
                <label>PV Arrow Count:</label>
                <input type="range" id="pvArrowCountSlider" min="1" max="10" step="1" value="${BotState.pvArrowCount}" class="range-slider">
                <span id="pvArrowCountValue">${BotState.pvArrowCount}</span>
            </div>

            <div class="divider"></div>

            <div class="setting-group">
                <h5>üåà Arrow Colors Preview</h5>
                <div style="display: flex; gap: 8px; justify-content: center; flex-wrap: wrap;">
                    ${PV_ARROW_COLORS.map((c, i) => `
                        <div style="display: flex; flex-direction: column; align-items: center; gap: 4px;">
                            <div style="width: 24px; height: 24px; border-radius: 50%; background: ${c.badge}; display: flex; align-items: center; justify-content: center; color: #fff; font-size: 11px; font-weight: bold;">${i + 1}</div>
                            <span style="font-size: 9px; color: #888;">Move ${i + 1}</span>
                        </div>
                    `).join('')}
                </div>
            </div>
        </div>
    `,

        'premove': () => `
        <div class="panel-content-inner">
            <h4 class="section-title">‚è© Premove System</h4>

            <div class="setting-row toggle-row" data-active="${BotState.premoveEnabled ? 1 : 0}">
                <label>üéØ Enable Premove:</label>
                <button type="button" id="togglePremove" class="on-off-button ${BotState.premoveEnabled ? 'on' : 'off'}">
                    ${BotState.premoveEnabled ? 'ON' : 'OFF'}
                </button>
            </div>

            <div class="setting-row select-row">
                <label>Premove Mode:</label>
                <select id="premoveModeSelect" class="select-input">
                    <option value="every" ${BotState.premoveMode === 'every' ? 'selected' : ''}>Every Move</option>
                    <option value="capture" ${BotState.premoveMode === 'capture' ? 'selected' : ''}>Captures Only</option>
                    <option value="filter" ${BotState.premoveMode === 'filter' ? 'selected' : ''}>By Piece Filter</option>
                </select>
            </div>

            <div id="pieceFiltersRow" class="setting-row piece-filters" style="display: ${BotState.premoveMode === 'filter' ? 'flex' : 'none'}">
                <label class="chip"><input type="checkbox" data-piece="q" ${BotState.premovePieces.q ? 'checked' : ''}><span>Q</span></label>
                <label class="chip"><input type="checkbox" data-piece="r" ${BotState.premovePieces.r ? 'checked' : ''}><span>R</span></label>
                <label class="chip"><input type="checkbox" data-piece="b" ${BotState.premovePieces.b ? 'checked' : ''}><span>B</span></label>
                <label class="chip"><input type="checkbox" data-piece="n" ${BotState.premovePieces.n ? 'checked' : ''}><span>N</span></label>
                <label class="chip"><input type="checkbox" data-piece="k" ${BotState.premovePieces.k ? 'checked' : ''}><span>K</span></label>
                <label class="chip"><input type="checkbox" data-piece="p" ${BotState.premovePieces.p ? 'checked' : ''}><span>P</span></label>
            </div>

            <div class="setting-group">
                <h5>üìä Premove Stats</h5>
                <div class="setting-row">
                    <span class="setting-label">Current Chance</span>
                    <span class="setting-value" id="premoveChanceDisplay">0%</span>
                </div>
            </div>

            <div class="divider"></div>

            <div class="disclaimer-box">
                <strong>‚ö†Ô∏è Premove Safety</strong>
                <p>Premoves are checked for king safety and bad trades before execution.</p>
            </div>
        </div>
    `,

        'top-move': () => `
        <div class="panel-content-inner">
            <h4 class="section-title">üìä Top Moves Analysis</h4>

            <div class="panel-content">
                <div class="status" id="helper-status">
                    üéØ Ready to analyze position...
                </div>

                <div class="best-move-container">
                    <div class="best-move-label">Best Move</div>
                    <div class="best-move" id="best-move">‚Äî</div>
                </div>

                <div class="eval-bar">
                    <div class="eval-fill" id="eval-bar-fill" style="width: 50%"></div>
                </div>

                <div class="info-grid">
                    <div class="info-box">
                        <div class="info-label">Evaluation</div>
                        <div class="info-value" id="eval-score">‚Äî</div>
                    </div>
                    <div class="info-box">
                        <div class="info-label">Depth</div>
                        <div class="info-value" id="depth-info">‚Äî</div>
                    </div>
                </div>

                <div class="continuation">
                    <div class="continuation-label">üìã Continuation</div>
                    <div class="continuation-moves" id="continuation">‚Äî</div>
                </div>

                <button class="btn btn-analyze" id="analyze-btn">
                    üîç Analyze Position
                    <span style="font-size: 11px; opacity: 0.7;">(Space)</span>
                </button>

                <div class="btn-row">
                    <button class="btn btn-secondary" id="copy-fen-btn" title="Copy FEN">
                        üìã FEN
                    </button>
                    <button class="btn btn-secondary ${BotState.AUTO_ANALYZE ? 'active' : ''}" id="auto-btn" title="Toggle Auto Analyze">
                        üîÑ Auto
                    </button>
                    <button class="btn btn-secondary ${BotState.SHOW_ARROWS ? 'active' : ''}" id="arrow-btn" title="Toggle Arrows">
                        ‚û°Ô∏è Arrow
                    </button>
                </div>

                <div class="settings-row">
                    <span>API: ${BotState.USE_STOCKFISH_ONLINE ? 'Stockfish Online' : 'Chess-API WS'}</span>
                    <span style="color: #60a5fa;">Depth: ${BotState.DEPTH}</span>
                </div>
            </div>
            <div class="divider"></div>
            <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 10px; margin-bottom: 15px;">
                <div class="info-card">
                    <div class="info-card-title">EVALUATION</div>
                    <div class="info-card-value" id="infoEval">${BotState.currentEvaluation}</div>
                </div>
                <div class="info-card">
                    <div class="info-card-title">BEST MOVE</div>
                    <div class="info-card-value" id="infoBestMove">${BotState.bestMove}</div>
                </div>
            </div>

            <div class="setting-group">
                <h5>üìã Principal Variation</h5>
                <div class="pv-display" id="pvDisplay">${BotState.principalVariation || 'Waiting for analysis...'}</div>
            </div>

            <div class="setting-group">
                <h5>üì° Status</h5>
                <div class="setting-row">
                    <span class="setting-label">Current Status</span>
                    <span class="setting-value" id="infoStatus" style="color: #4CAF50;">${BotState.statusInfo}</span>
                </div>
            </div>
        </div>
    `,

        'setting': () => `
        <div class="panel-content-inner">
            <h4 class="section-title">üõ†Ô∏è Settings & Info</h4>

            <div class="action-buttons">
                <button type="button" id="reloadEngineBtn" class="action-btn">üîÑ Reload Engine</button>
                <button type="button" id="clearAllBtn" class="action-btn">üóëÔ∏è Clear Cache</button>
            </div>

            <div class="divider"></div>

            <div class="info-section">
                <h5>Keyboard Shortcuts</h5>
                <ul class="shortcut-list">
                    <li><kbd>Ctrl</kbd> + <kbd>B</kbd> - Toggle Panel</li>
                    <li><kbd>Esc</kbd> - Minimize/Maximize</li>
                </ul>
            </div>

            <div class="divider"></div>

            <div class="disclaimer-box warning">
                <strong>‚ö†Ô∏è Important Warning!</strong>
                <p>Using this tool may violate platform rules and result in account bans. Use responsibly and at your own risk. The developer is not responsible for any consequences.</p>
            </div>

            <div class="credits">
                <span>GabiBot Pro v4.0</span>
            </div>
        </div>
    `
    };

    // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
    // PANEL STYLES
    // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
    const panelStyles = `
    /* Main Panel Container */
    #chess-ui-overlay {
        position: fixed;
        background: linear-gradient(135deg, #1a1a2e 0%, #16213e 100%);
        border: 1px solid rgba(255, 255, 255, 0.1);
        box-shadow: 0 8px 32px rgba(0, 0, 0, 0.5);
        z-index: 999999;
        font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, sans-serif;
        border-radius: 12px;
        color: #fff;
        user-select: none;
        backdrop-filter: blur(10px);
        transition: all 0.3s ease;
    }

    #chess-ui-overlay.closed { display: none !important; }
    #chess-ui-overlay.minimized .menu-row,
    #chess-ui-overlay.minimized .content-row { display: none; }
    #chess-ui-overlay.grabbing { cursor: grabbing !important; opacity: 0.95; }

    #chess-ui-overlay table {
        width: 100%;
        border-collapse: collapse;
        border-radius: 12px;
        overflow: hidden;
    }

    #chess-ui-overlay td {
        border: none;
        padding: 0;
        text-align: center;
        vertical-align: top;
    }

    /* Header */
    .header-row td {
        background: rgba(255, 255, 255, 0.05);
        border-bottom: 1px solid rgba(255, 255, 255, 0.1);
    }

    .header {
        padding: 12px 15px;
        cursor: grab;
        text-align: left !important;
    }

    .header-title {
        display: flex;
        align-items: center;
        gap: 10px;
    }

    .header-title .logo {
        font-size: 18px;
        font-weight: 700;
        background: linear-gradient(45deg, #7fa650, #4caf50);
        -webkit-background-clip: text;
        -webkit-text-fill-color: transparent;
        background-clip: text;
    }

    .status-leds {
        display: flex;
        gap: 6px;
    }

    .status-led {
        width: 10px;
        height: 10px;
        border-radius: 50%;
        background: #444;
        box-shadow: 0 0 3px #222;
        transition: all 0.3s;
    }

    .status-led.active {
        background: #4CAF50;
        box-shadow: 0 0 8px #4CAF50;
    }

    .status-led.my-turn {
        background: #2196F3;
        box-shadow: 0 0 8px #2196F3;
    }

    .status-led.opp-turn {
        background: #FF9800;
        box-shadow: 0 0 8px #FF9800;
    }

    .digital-clock {
        font-family: 'Courier New', monospace;
        font-size: 12px;
        font-weight: bold;
        color: #7fa650;
        background: rgba(0,0,0,0.3);
        padding: 3px 8px;
        border-radius: 4px;
        margin-left: 10px;
    }

    .header-hint {
        font-size: 10px;
        color: rgba(255, 255, 255, 0.5);
        margin-top: 4px;
    }

    .window-controls {
        text-align: right !important;
        padding: 0 !important;
        white-space: nowrap;
    }

    .control-btn {
        display: inline-block;
        padding: 12px 10px;
        cursor: pointer;
        font-size: 14px;
        transition: background 0.2s;
    }

    .control-btn:hover {
        background: rgba(255, 255, 255, 0.1);
    }

    #close-btn:hover {
        background: rgba(235, 97, 80, 0.3);
    }

    /* Menu Row */
    .menu-row td {
        background: rgba(0, 0, 0, 0.2);
    }

    .menu-item {
        padding: 10px 8px !important;
        font-size: 11px;
        font-weight: 600;
        cursor: pointer;
        transition: all 0.3s ease;
        color: rgba(255, 255, 255, 0.7);
        border-bottom: 2px solid transparent;
    }

    .menu-item:hover {
        background: rgba(255, 255, 255, 0.05);
        color: #fff;
    }

    .menu-item.active {
        background: rgba(127, 166, 80, 0.2);
        color: #7fa650;
        border-bottom-color: #7fa650;
    }

    /* Content Area */
    .content-area {
        height: 280px;
        background: rgba(0, 0, 0, 0.1);
    }

    .content-scroll-container {
        width: 100%;
        height: 100%;
        overflow-y: auto;
        overflow-x: hidden;
    }

    .content-scroll-container::-webkit-scrollbar {
        width: 6px;
    }

    .content-scroll-container::-webkit-scrollbar-track {
        background: rgba(255, 255, 255, 0.05);
    }

    .content-scroll-container::-webkit-scrollbar-thumb {
        background: rgba(255, 255, 255, 0.2);
        border-radius: 3px;
    }

    .panel-content-inner {
        padding: 15px;
        text-align: left;
    }

    .section-title {
        margin: 0 0 15px 0;
        font-size: 14px;
        color: #7fa650;
        text-align: center;
        padding-bottom: 10px;
        border-bottom: 1px solid rgba(255, 255, 255, 0.1);
    }

    .subsection-title {
        margin: 10px 0;
        font-size: 12px;
        color: rgba(255, 255, 255, 0.8);
        text-align: center;
    }

    .divider {
        height: 1px;
        background: linear-gradient(90deg, transparent, rgba(255,255,255,0.1), transparent);
        margin: 15px 0;
    }

    /* Setting Rows */
    .setting-row {
        display: flex;
        justify-content: space-between;
        align-items: center;
        padding: 10px 12px;
        background: rgba(255, 255, 255, 0.05);
        border-radius: 8px;
        margin-bottom: 8px;
        transition: all 0.2s ease;
    }

    .setting-row:hover {
        background: rgba(255, 255, 255, 0.08);
    }

    .toggle-row[data-active="1"] {
        border-left: 3px solid #4caf50;
    }

    .toggle-row[data-active="0"] {
        border-left: 3px solid #eb6150;
    }

    .setting-row label {
        font-size: 12px;
        color: rgba(255, 255, 255, 0.85);
        font-weight: 500;
    }

    .info-row {
        display: flex;
        justify-content: space-around;
        padding: 12px;
        background: rgba(127, 166, 80, 0.1);
        border-radius: 8px;
        margin-bottom: 12px;
        font-size: 13px;
    }

    .info-row strong {
        color: #7fa650;
    }

    .status-text {
        text-align: center;
        font-size: 11px;
        color: rgba(255, 255, 255, 0.6);
        margin-top: -5px;
        margin-bottom: 10px;
    }

    /* Buttons */
    .on-off-button {
        padding: 6px 16px;
        border: none;
        cursor: pointer;
        border-radius: 6px;
        font-weight: 600;
        font-size: 11px;
        color: white;
        transition: all 0.2s ease;
    }

    .on-off-button.on {
        background: linear-gradient(135deg, #4caf50, #7fa650);
    }

    .on-off-button.off {
        background: linear-gradient(135deg, #c0392b, #eb6150);
    }

    .on-off-button:hover {
        transform: scale(1.05);
    }

    .action-btn {
        padding: 10px 20px;
        background: linear-gradient(135deg, #4287f5, #5c9ce6);
        border: none;
        border-radius: 8px;
        color: white;
        font-weight: 600;
        cursor: pointer;
        transition: all 0.2s ease;
        margin: 5px;
    }

    .action-btn:hover {
        transform: translateY(-2px);
        box-shadow: 0 4px 12px rgba(66, 135, 245, 0.4);
    }

    .action-buttons {
        display: flex;
        justify-content: center;
        flex-wrap: wrap;
        gap: 10px;
    }

    /* Inputs */
    .range-slider {
        -webkit-appearance: none;
        flex: 1;
        height: 4px;
        border-radius: 2px;
        background: rgba(255, 255, 255, 0.2);
        outline: none;
        margin: 0 10px;
    }

    .range-slider::-webkit-slider-thumb {
        -webkit-appearance: none;
        width: 16px;
        height: 16px;
        border-radius: 50%;
        background: #7fa650;
        cursor: pointer;
        transition: transform 0.2s;
    }

    .range-slider::-webkit-slider-thumb:hover {
        transform: scale(1.2);
    }

    .number-input {
        width: 70px;
        padding: 6px 10px;
        border: 1px solid rgba(255, 255, 255, 0.2);
        border-radius: 6px;
        background: rgba(255, 255, 255, 0.1);
        color: #fff;
        text-align: center;
        font-size: 12px;
    }

    .number-input:focus {
        outline: none;
        border-color: #7fa650;
    }

    .select-input {
        padding: 8px 12px;
        border: 1px solid rgba(255, 255, 255, 0.2);
        border-radius: 6px;
        background: rgba(255, 255, 255, 0.1);
        color: #fff;
        font-size: 12px;
        cursor: pointer;
    }

    .select-input option {
        background: #1a1a2e;
        color: #fff;
    }

    /* Piece Filters */
    .piece-filters {
        display: flex;
        flex-wrap: wrap;
        gap: 8px;
        justify-content: center;
    }

    .chip {
        display: inline-flex;
        align-items: center;
        gap: 4px;
        padding: 6px 12px;
        background: rgba(255, 255, 255, 0.1);
        border: 1px solid rgba(255, 255, 255, 0.2);
        border-radius: 20px;
        cursor: pointer;
        font-size: 12px;
        transition: all 0.2s;
    }

    .chip:hover {
        background: rgba(255, 255, 255, 0.15);
    }

    .chip input {
        appearance: none;
        width: 14px;
        height: 14px;
        border-radius: 3px;
        border: 2px solid rgba(255, 255, 255, 0.4);
        background: transparent;
        cursor: pointer;
    }

    .chip input:checked {
        background: #7fa650;
        border-color: #7fa650;
    }

    /* Info Cards */
    .info-card {
        background: linear-gradient(135deg, rgba(127,166,80,0.1), rgba(127,166,80,0.05));
        border: 1px solid rgba(127,166,80,0.3);
        border-radius: 8px;
        padding: 12px;
        margin-bottom: 10px;
    }

    .info-card-title {
        font-size: 11px;
        color: #888;
        margin-bottom: 5px;
    }

    .info-card-value {
        font-size: 16px;
        font-weight: bold;
        color: #7fa650;
    }

    /* Setting Groups */
    .setting-group {
        margin-bottom: 15px;
        background: rgba(255,255,255,0.03);
        border-radius: 8px;
        padding: 12px;
        border: 1px solid rgba(255,255,255,0.05);
    }

    .setting-group h5 {
        margin: 0 0 12px 0;
        color: #7fa650;
        font-size: 13px;
        border-bottom: 1px solid rgba(255,255,255,0.1);
        padding-bottom: 8px;
    }

    .setting-label {
        color: #ccc;
        font-size: 12px;
        font-weight: 500;
    }

    .setting-value {
        color: #7fa650;
        font-size: 12px;
        font-weight: bold;
        min-width: 40px;
        text-align: right;
    }

    /* PV Display */
    .pv-display {
        background: rgba(0,0,0,0.3);
        border-radius: 6px;
        padding: 10px;
        font-family: 'Courier New', monospace;
        font-size: 11px;
        color: #aaa;
        max-height: 80px;
        overflow-y: auto;
        word-wrap: break-word;
    }

    /* Analysis Panel Styles */
    .panel-content {
        background: #1e293b;
        color: #f1f5f9;
        padding: 20px;
        border-radius: 12px;
        box-shadow: 0 8px 20px rgba(0,0,0,0.25);
        font-family: 'Inter', sans-serif;
    }

    .status {
        font-size: 16px;
        font-weight: 600;
        color: #38bdf8;
        margin-bottom: 15px;
    }

    .best-move-container {
        background: #0f172a;
        padding: 12px;
        border-radius: 10px;
        margin-bottom: 15px;
        display: flex;
        justify-content: space-between;
        align-items: center;
    }

    .best-move-label {
        font-weight: 500;
        color: #94a3b8;
    }

    .best-move {
        font-size: 18px;
        font-weight: bold;
        color: #facc15;
    }

    .eval-bar {
        background: #334155;
        border-radius: 8px;
        height: 12px;
        margin: 15px 0;
        overflow: hidden;
    }

    .eval-fill {
        background: linear-gradient(90deg, #22c55e, #3b82f6);
        height: 100%;
        transition: width 0.4s ease;
    }
     /* Evaluation Bar */
        .evaluation-section {
        padding: 10px;
        background-color: #383838;
    }
    .evaluation-bars-wrapper {
        display: flex;
        gap: 10px;
    }
    .evaluation-bar-container {
        position: relative;
        width: 50%;
        height: 20px;
        background-color: #e0e0e0;
        border-radius: 5px;
        overflow: hidden;
        margin-bottom: 0;
    }
    #evaluationFillAutoRun {
        width: 50%;
        height: 100%;
        background-color: #7fa650;
        transition: width 0.2s ease-in-out;
    }
    #evaluationFillAnalysis {
        width: 50%;
        height: 100%;
        background-color: #4287f5;
        transition: width 0.2s ease-in-out;
    }

    .info-grid {
        display: flex;
        gap: 15px;
        margin-bottom: 15px;
    }

    .info-box {
        flex: 1;
        background: #0f172a;
        padding: 10px;
        border-radius: 8px;
        text-align: center;
    }

    .info-label {
        font-size: 13px;
        color: #94a3b8;
    }

    .info-value {
        font-size: 16px;
        font-weight: bold;
        color: #f1f5f9;
    }

    .continuation {
        background: #0f172a;
        padding: 12px;
        border-radius: 8px;
        margin-bottom: 15px;
    }

    .continuation-label {
        font-weight: 500;
        margin-bottom: 8px;
        color: #38bdf8;
    }

    .continuation-moves {
        font-size: 14px;
        color: #f1f5f9;
    }

    .btn {
        background: #3b82f6;
        color: #fff;
        border: none;
        padding: 10px 14px;
        border-radius: 8px;
        cursor: pointer;
        font-size: 14px;
        transition: background 0.3s ease;
        width: 100%;
        margin-bottom: 10px;
    }

    .btn:hover {
        background: #2563eb;
    }

    .btn-secondary {
        background: #334155;
        color: #f1f5f9;
        margin-right: 8px;
        width: auto;
        display: inline-block;
    }

    .btn-secondary.active {
        background: #22c55e;
        color: #fff;
    }

    .btn-row {
        margin-top: 15px;
        display: flex;
        gap: 8px;
    }

    .settings-row {
        margin-top: 20px;
        font-size: 13px;
        display: flex;
        justify-content: space-between;
        color: #94a3b8;
    }

    /* Disclaimer */
    .disclaimer-box {
        padding: 12px;
        background: rgba(127, 166, 80, 0.1);
        border: 1px solid rgba(127, 166, 80, 0.3);
        border-radius: 8px;
        font-size: 11px;
        line-height: 1.5;
    }

    .disclaimer-box.warning {
        background: rgba(235, 97, 80, 0.1);
        border-color: rgba(235, 97, 80, 0.3);
    }

    .disclaimer-box strong {
        color: #ffc107;
    }

    .disclaimer-box p {
        margin: 8px 0 0 0;
        color: rgba(255, 255, 255, 0.7);
    }

    /* Shortcuts */
    .info-section h5 {
        color: #7fa650;
        font-size: 13px;
        margin-bottom: 10px;
    }

    .shortcut-list {
        list-style: none;
        padding: 0;
        margin: 10px 0;
    }

    .shortcut-list li {
        padding: 8px 0;
        font-size: 12px;
        color: rgba(255, 255, 255, 0.7);
        border-bottom: 1px solid rgba(255, 255, 255, 0.05);
    }

    .shortcut-list kbd {
        background: rgba(255, 255, 255, 0.1);
        padding: 3px 8px;
        border-radius: 4px;
        font-family: monospace;
        font-size: 11px;
        margin-right: 4px;
    }

    .credits {
        text-align: center;
        font-size: 10px;
        color: rgba(255, 255, 255, 0.4);
        margin-top: 15px;
    }

    /* Arrow Canvas */
    #arrowCanvas {
        position: absolute !important;
        top: 0 !important;
        left: 0 !important;
        width: 100% !important;
        height: 100% !important;
        pointer-events: none !important;
        z-index: 1000 !important;
    }

    .pv-arrow-group line {
        filter: drop-shadow(0 0 2px rgba(0,0,0,0.5));
    }

     /* Highlight Squares */
        .chess-helper-highlight {
            background: rgba(74, 222, 128, 0.5) !important;
            box-shadow: inset 0 0 0 3px #22c55e !important;
        }

        .chess-helper-from {
            background: rgba(59, 130, 246, 0.5) !important;
            box-shadow: inset 0 0 0 3px #3b82f6 !important;
        }

        .chess-helper-to {
            background: rgba(34, 197, 94, 0.6) !important;
            box-shadow: inset 0 0 0 3px #22c55e !important;
        }

        /* Arrow Overlay */
        .chess-helper-arrow {
            position: absolute;
            pointer-events: none;
            z-index: 9999;
        }

        .chess-helper-arrow line {
            stroke: #22c55e;
            stroke-width: 8;
            stroke-linecap: round;
            opacity: 0.8;
        }

        .chess-helper-arrow polygon {
            fill: #22c55e;
            opacity: 0.8;
        }
         /* Evaluation Bar Styles */
    .eval-bar {
        background: linear-gradient(90deg, #1e293b 0%, #334155 100%);
        border-radius: 8px;
        height: 16px;
        margin: 15px 0;
        overflow: hidden;
        position: relative;
        border: 2px solid #475569;
        transition: border-color 0.3s ease;
    }

    .eval-fill {
        height: 100%;
        transition: width 0.4s ease, background 0.4s ease, box-shadow 0.3s ease;
        border-radius: 6px;
        position: relative;
    }

    .eval-fill::after {
        content: '';
        position: absolute;
        top: 0;
        left: 0;
        right: 0;
        bottom: 0;
        background: linear-gradient(180deg, rgba(255,255,255,0.1) 0%, transparent 50%);
        border-radius: 6px;
    }

    #eval-bar-label {
        position: absolute;
        top: 50%;
        left: 50%;
        transform: translate(-50%, -50%);
        font-size: 10px;
        font-weight: bold;
        text-shadow: 0 1px 2px rgba(0,0,0,0.5);
        z-index: 10;
    }

    /* Eval Score Colors */
    .info-value.winning { color: #22c55e !important; }
    .info-value.positive { color: #4ade80 !important; }
    .info-value.equal { color: #fbbf24 !important; }
    .info-value.negative { color: #f87171 !important; }
    .info-value.losing { color: #ef4444 !important; }
    .info-value.mate {
        color: #a855f7 !important;
        font-weight: bold;
        text-shadow: 0 0 8px rgba(168, 85, 247, 0.5);
    }

    /* PV Arrow Styles */
    .chess-helper-pv-arrows {
        position: absolute !important;
        top: 0 !important;
        left: 0 !important;
        pointer-events: none !important;
        z-index: 100 !important;
    }

    .pv-arrow-group {
        transition: opacity 0.2s ease;
    }

    .pv-arrow-group line {
        filter: drop-shadow(0 2px 4px rgba(0,0,0,0.3));
    }

    .pv-arrow-group polygon {
        filter: drop-shadow(0 1px 2px rgba(0,0,0,0.3));
    }

    /* Highlight Squares */
    .chess-helper-from {
        background: rgba(34, 197, 94, 0.5) !important;
        box-shadow: inset 0 0 0 3px rgba(34, 197, 94, 0.8) !important;
    }

    .chess-helper-to {
        background: rgba(239, 68, 68, 0.5) !important;
        box-shadow: inset 0 0 0 3px rgba(239, 68, 68, 0.8) !important;
    }
`;
    async function buildUI() {
        // Add styles
        const styleEl = document.createElement('style');
        styleEl.textContent = panelStyles;
        document.head.appendChild(styleEl);

        // Create panel
        const panel = document.createElement('div');
        panel.id = 'chess-ui-overlay';
        panel.style.width = `${BotState.panelWidth}px`;

        if (BotState.panelTop !== null && BotState.panelLeft !== null) {
            panel.style.top = `${BotState.panelTop}px`;
            panel.style.left = `${BotState.panelLeft}px`;
        } else {
            panel.style.top = '20px';
            panel.style.right = '20px';
        }

        panel.innerHTML = `
            <table>
                <tr class="header-row">
                    <td colspan="3" class="header draggable-handle">
                        <div class="header-title">
                            <span class="logo">‚ôü Bintang 500</span>
                            <div class="status-leds">
                                <div id="engine-status-led" class="status-led" title="Main Status"></div>
                                <div id="turn-indicator-opp" class="status-led" title="Engine Status"></div>
                                <div id="turn-indicator-my" class="status-led" title="Analysis Status"></div>
                            </div>
                        </div>
                        <div class="header-hint">[Ctrl+B to toggle | ESC to minimize]</div>
                    </td>
                    <td colspan="3" class="header window-controls">
                        <span class="control-btn" id="minimize-btn" title="Minimize">üîº</span>
                        <span class="control-btn" id="maximize-btn" title="Maximize">üîΩ</span>
                        <span class="control-btn" id="close-btn" title="Close">‚ùå</span>
                    </td>
                </tr>
                <tr class="menu-row">
                    <td class="menu-item active" data-content="engine-settings">‚öôÔ∏è MAIN</td>
                    <td class="menu-item" data-content="main-control">‚è±Ô∏è DELAY</td>
                    <td class="menu-item" data-content="display-setting">üñ•Ô∏è DISPLAY</td>
                    <td class="menu-item" data-content="premove">‚è© PREMOVE</td>
                    <td class="menu-item" data-content="top-move">üìä MOVES</td>
                    <td class="menu-item" data-content="setting">üõ†Ô∏è INFO</td>
                </tr>
                <tr class="content-row">
                    <td colspan="6" class="content-area">
                        <div class="content-scroll-container" id="panel-content-scroll"></div>
                    </td>
                </tr>
                <tr class="evaluation-row">
                    <td colspan="6" class="evaluation-section">
                        <div class="evaluation-bars-wrapper">
                            <div class="evaluation-bar-container auto-run-bar-container">
                                <div id="evaluationFillAutoRun"></div>
                            </div>
                            <div class="evaluation-bar-container analysis-bar-container">
                                <div id="eval-bar-fill"></div>
                            </div>
                        </div>
                    </td>
                </tr>
            </table>
        `;

        document.body.appendChild(panel);
        // Initialize with default content
        document.getElementById('panel-content-scroll').innerHTML = contentTemplates['engine-settings']();

        // Setup panel
        setupPanelListeners(panel);
        setupContentListeners('engine-settings');
        setPanelState(BotState.panelState);

        ui = {
            panel,
            updateStatusLeds,
            updateTopMoves,
            BotStateUtils,
            updateDisplay,
            updateDisplay() {
                updateUIDisplay();
            }
        };
        // Update loop for UI
        setInterval(() => {
            if (BotState.hackEnabled) {
                updateUIDisplay();
            }
        }, 500);
    }

    function setPanelState(state) {
        const panel = document.getElementById('chess-ui-overlay');
        if (!panel) return;

        panel.classList.remove('closed', 'minimized', 'maximized');

        if (state === 'closed') {
            panel.classList.add('closed');
        } else if (state === 'minimized') {
            panel.classList.add('minimized');
        } else {
            panel.classList.add('maximized');
        }

        BotState.panelState = state;
        BotStateUtils.save();
    }

    function setupPanelListeners(panel) {
        // Menu item clicks
        qsa('.menu-item', panel).forEach(item => {
            item.addEventListener('click', function() {
                qsa('.menu-item', panel).forEach(el => el.classList.remove('active'));
                this.classList.add('active');
                const contentId = this.getAttribute('data-content');
                document.getElementById('panel-content-scroll').innerHTML = contentTemplates[contentId]();
                setupContentListeners(contentId);
            });
        });

        // Window controls
        qs('#minimize-btn', panel).addEventListener('click', () => setPanelState('minimized'));
        qs('#maximize-btn', panel).addEventListener('click', () => setPanelState('maximized'));
        qs('#close-btn', panel).addEventListener('click', () => setPanelState('closed'));

        // Dragging
        makePanelDraggable(panel);

        // Keyboard shortcuts
        document.addEventListener('keydown', (e) => {
            if (e.key === 'b' && e.ctrlKey) {
                e.preventDefault();
                if (BotState.panelState === 'closed') {
                    setPanelState('maximized');
                } else {
                    setPanelState('closed');
                }
            }
            if (e.key === 'Escape') {
                if (BotState.panelState === 'maximized') {
                    setPanelState('minimized');
                } else if (BotState.panelState === 'minimized') {
                    setPanelState('maximized');
                }
            }
        });
    }

    function setupContentListeners(contentId) {
        const container = document.getElementById('panel-content-scroll');
        if (!container) return;

        // Common toggle button handler
        const setupToggle = (id, stateKey, onText = 'ON', offText = 'OFF') => {
            const btn = qs(`#${id}`, container);
            if (!btn) return;

            btn.addEventListener('click', () => {
                BotState[stateKey] = BotState[stateKey] ? 0 : 1;
                btn.textContent = BotState[stateKey] ? onText : offText;
                btn.className = `on-off-button ${BotState[stateKey] ? 'on' : 'off'}`;
                btn.closest('.toggle-row')?.setAttribute('data-active', BotState[stateKey]);
                BotStateUtils.save();

                // Special handling for hackEnabled
                if (stateKey === 'hackEnabled') {
                    if (BotState.hackEnabled) {
                        startTickLoop();
                        updateStatusLeds('active', '', '');
                    } else {
                        stopTickLoop();
                        clearArrows();
                        updateStatusLeds('', '', '');
                    }
                }
            });
        };

        if (contentId === 'engine-settings') {
            // Sliders
            const eloSlider = qs('#elo-rating-slider', container);
            const depthSlider = qs('#custom-depth-slider', container);

            if (eloSlider) {
                eloSlider.addEventListener('input', (e) => {
                    BotState.eloRating = parseInt(e.target.value);
                    qs('#eloValueDisplay', container).textContent = BotState.eloRating;
                    BotStateUtils.save();
                });
            }

            if (depthSlider) {
                depthSlider.addEventListener('input', (e) => {
                    BotState.botPower = parseInt(e.target.value);
                    qs('#depthValue', container).textContent = BotState.botPower;
                    BotStateUtils.save();
                });
            }

            // Clock Sync Toggle
            const toggleClockSync = qs('#toggleClockSync', container);
            const minDelayInput = qs('#minDelayValue', container);
            const maxDelayInput = qs('#maxDelayValue', container);

            if (toggleClockSync) {
                toggleClockSync.addEventListener('click', () => {
                    BotState.clockSyncEnabled = !BotState.clockSyncEnabled;
                    toggleClockSync.textContent = BotState.clockSyncEnabled ? 'ON' : 'OFF';
                    toggleClockSync.className = `on-off-button ${BotState.clockSyncEnabled ? 'on' : 'off'}`;

                    // Update parent row active state
                    const parentRow = toggleClockSync.closest('.toggle-row');
                    if (parentRow) {
                        parentRow.setAttribute('data-active', BotState.clockSyncEnabled ? '1' : '0');
                    }

                    // Enable/Disable inputs
                    if (minDelayInput) minDelayInput.disabled = !BotState.clockSyncEnabled;
                    if (maxDelayInput) maxDelayInput.disabled = !BotState.clockSyncEnabled;

                    BotStateUtils.save();
                    console.log('Clock Sync:', BotState.clockSyncEnabled ? 'Enabled' : 'Disabled');
                });
            }

            // Min Delay Input
            if (minDelayInput) {
                minDelayInput.addEventListener('input', (e) => {
                    const value = parseFloat(e.target.value);
                    if (!isNaN(value) && value >= 0.1 && value <= 30) {
                        BotState.clockSyncMinDelay = value;

                        // Ensure min is not greater than max
                        if (maxDelayInput && value > parseFloat(maxDelayInput.value)) {
                            BotState.clockSyncMaxDelay = value;
                            maxDelayInput.value = value;
                        }

                        BotStateUtils.save();
                        console.log('Clock Sync Min Delay:', value);
                    }
                });
            }

            // Max Delay Input
            if (maxDelayInput) {
                maxDelayInput.addEventListener('input', (e) => {
                    const value = parseFloat(e.target.value);
                    if (!isNaN(value) && value >= 0.1 && value <= 30) {
                        BotState.clockSyncMaxDelay = value;

                        // Ensure max is not less than min
                        if (minDelayInput && value < parseFloat(minDelayInput.value)) {
                            BotState.clockSyncMinDelay = value;
                            minDelayInput.value = value;
                        }

                        BotStateUtils.save();
                        console.log('Clock Sync Max Delay:', value);
                    }
                });
            }

            // Regular Toggles
            setupToggle('toggleHack', 'hackEnabled');
            setupToggle('toggleAutoMove', 'autoMove');
            setupToggle('toggleAutoRun', 'autoRun');
            setupToggle('toggleAutoMatch', 'autoMatchEnabled');
        }

        if (contentId === 'main-control') {
            // Delay mode toggle
            const delayBtn = qs('#toggleSecondDelay', container);
            if (delayBtn) {
                delayBtn.addEventListener('click', () => {
                    BotState.useSecondDelay = !BotState.useSecondDelay;
                    delayBtn.textContent = BotState.useSecondDelay ? 'FAST' : 'NORMAL';
                    delayBtn.className = `on-off-button ${BotState.useSecondDelay ? 'on' : 'off'}`;
                    delayBtn.closest('.toggle-row')?.setAttribute('data-active', BotState.useSecondDelay ? 1 : 0);

                    const statusEl = container.querySelector('.status-text');
                    if (statusEl) {
                        statusEl.textContent = BotState.useSecondDelay
                            ? '‚ö° Fast Mode Active (Bullet/Blitz)'
                        : 'üê¢ Normal Mode Active (Rapid/Classical)';
                    }
                    BotStateUtils.save();
                });
            }

            // Delay inputs
            const inputs = {
                'timeDelayMin': 'minDelay',
                'timeDelayMax': 'maxDelay',
                'timeDelayMinTwo': 'minDelayTwo',
                'timeDelayMaxTwo': 'maxDelayTwo'
            };

            Object.entries(inputs).forEach(([id, key]) => {
                const input = qs(`#${id}`, container);
                if (input) {
                    input.addEventListener('change', (e) => {
                        BotState[key] = parseFloat(e.target.value) || 0.1;
                        BotStateUtils.save();
                    });
                }
            });

            // Update speed slider
            const updateSpeedSlider = qs('#updateSpeedSlider', container);
            if (updateSpeedSlider) {
                updateSpeedSlider.addEventListener('input', (e) => {
                    BotState.updateSpeed = parseInt(e.target.value);
                    qs('#updateSpeedValue', container).textContent = BotState.updateSpeed;
                    if (BotState.hackEnabled) startTickLoop();
                    BotStateUtils.save();
                });
            }
        }

        if (contentId === 'display-setting') {
            const setupDisplayToggle = (id, stateKey) => {
                const btn = qs(`#${id}`, container);
                if (!btn) return;
                btn.addEventListener('click', () => {
                    BotState[stateKey] = BotState[stateKey] ? 0 : 1;
                    btn.textContent = BotState[stateKey] ? 'ON' : 'OFF';
                    btn.className = `on-off-button ${BotState[stateKey] ? 'on' : 'off'}`;
                    btn.closest('.toggle-row')?.setAttribute('data-active', BotState[stateKey]);

                    // PERBAIKAN: Handle toggle dengan benar
                    if (stateKey === 'showPVArrows') {
                        if (!BotState[stateKey]) {
                            clearPVArrows(); // Hanya hapus PV arrows
                        } else if (lastPVData && lastPVData.length > 0) {
                            drawPVArrows(lastPVData); // Gambar ulang PV
                        }
                    } else if (stateKey === 'highlightEnabled') {
                        if (!BotState[stateKey]) {
                            clearBestMoveArrow(); // Hanya hapus best move arrow
                        }
                    }

                    BotStateUtils.save();
                });
            };

            setupDisplayToggle('toggleHighlight', 'highlightEnabled');
            setupDisplayToggle('togglePVArrows', 'showPVArrows');

            // PV arrow count slider
            const pvSlider = qs('#pvArrowCountSlider', container);
            if (pvSlider) {
                pvSlider.addEventListener('input', (e) => {
                    BotState.pvArrowCount = parseInt(e.target.value);
                    qs('#pvArrowCountValue', container).textContent = BotState.pvArrowCount;

                    // PERBAIKAN: Langsung redraw saat slider digeser
                    if (BotState.showPVArrows && lastPVData && lastPVData.length > 0) {
                        drawPVArrows(lastPVData);
                    }
                    BotStateUtils.save();
                });
            }

            // Color inputs & Presets (Sudah benar, tambahkan drawPVArrows di akhir)
            const colorUpdateHandler = () => {
                if (BotState.showPVArrows && typeof lastPVData !== 'undefined') {
                    drawPVArrows(lastPVData);
                }
                BotStateUtils.save();
            };

            const color1 = qs('#highlight-color1', container);
            if (color1) {
                color1.addEventListener('input', (e) => {
                    BotState.highlightColor1 = e.target.value;
                    colorUpdateHandler();
                });
            }

            qsa('.preset-btn', container).forEach(btn => {
                btn.addEventListener('click', (e) => {
                    const color = e.target.dataset.color;
                    const target = e.target.closest('.color-presets').dataset.target;
                    if (target === 'highlight-color1') {
                        BotState.highlightColor1 = color;
                        qs('#highlight-color1', container).value = color;
                    } else {
                        BotState.highlightColor2 = color;
                        qs('#highlight-color2', container).value = color;
                    }
                    colorUpdateHandler();
                });
            });
        }

        if (contentId === 'premove') {
            setupToggle('togglePremove', 'premoveEnabled');

            // Premove mode select
            const modeSelect = qs('#premoveModeSelect', container);
            if (modeSelect) {
                modeSelect.addEventListener('change', (e) => {
                    BotState.premoveMode = e.target.value;
                    const filtersRow = qs('#pieceFiltersRow', container);
                    if (filtersRow) {
                        filtersRow.style.display = BotState.premoveMode === 'filter' ? 'flex' : 'none';
                    }
                    BotStateUtils.save();
                });
            }

            // Piece filters
            qsa('.chip input', container).forEach(chk => {
                chk.addEventListener('change', () => {
                    const piece = chk.dataset.piece;
                    BotState.premovePieces[piece] = chk.checked ? 1 : 0;
                    BotStateUtils.save();
                });
            });
        }

        if (contentId === 'top-move') {
            // Analyze button
            document.getElementById('analyze-btn').addEventListener('click', () => {
                if (!isAnalyzing) analyzePosition();
            });

            // Copy FEN button
            document.getElementById('copy-fen-btn').addEventListener('click', () => {
                const fen = getFENanalyze();
                if (fen) {
                    navigator.clipboard.writeText(fen).then(() => {
                        updateStatus('üìã FEN disalin ke clipboard!');
                        setTimeout(() => updateStatus('üéØ Siap menganalisis...'), 2000);
                    });
                }
            });

            // Auto analyze toggle
            document.getElementById('auto-btn').addEventListener('click', (e) => {
                BotState.AUTO_ANALYZE = !BotState.AUTO_ANALYZE;
                e.target.classList.toggle('active', BotState.AUTO_ANALYZE);
                updateStatus(BotState.AUTO_ANALYZE ? 'üîÑ Auto-analyze ON' : '‚è∏Ô∏è Auto-analyze OFF');
            });

            // Arrow toggle
            document.getElementById('arrow-btn').addEventListener('click', (e) => {
                BotState.SHOW_ARROWS = !BotState.SHOW_ARROWS;
                e.target.classList.toggle('active', BotState.SHOW_ARROWS);
                if (!BotState.SHOW_ARROWS) removeArrowAnalyze();
            });
        }


        if (contentId === 'setting') {

            // ========== Clear Button ==========
            document.getElementById("clearLogBtn").addEventListener("click", () => {
                const box = document.getElementById("miniLogConsole");
                if (box) {
                    box.innerHTML = `<div style="color:#444;">[SYSTEM] Log cleared...</div>`;
                }
            });

            const reloadBtn = qs('#reloadEngineBtn', container);
            if (reloadBtn) {
                reloadBtn.addEventListener('click', () => {
                    Object.keys(PositionCache).forEach(key => delete PositionCache[key]);
                    lastFenProcessedMain = '';
                    lastFenProcessedPremove = '';
                    BotState.statusInfo = 'Engine reloaded';
                    updateDisplay();
                    if (BotState.hackEnabled) tick();
                });
            }

            // Tombol Clear All (cache + settings)
            const clearAllBtn = qs('#clearAllBtn', container);
            if (clearAllBtn) {
                clearAllBtn.addEventListener('click', () => {
                    try {
                        // 1. Hapus semua cache posisi
                        Object.keys(PositionCache).forEach(key => delete PositionCache[key]);

                        // 2. Hapus settings tersimpan di localStorage
                        localStorage.removeItem(STORAGE_KEY);

                        // 3. Reset BotState ke default
                        BotStateUtils.reset();

                        // 4. Update status info & UI
                        BotState.statusInfo = 'All settings & cache cleared';
                        updateDisplay();

                        Logger.info('User cleared all settings and cache');
                    } catch (error) {
                        Logger.error('Failed to clear all settings/cache:', error);
                    }
                });
            }
        }
    }

    // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
    // DISPLAY UPDATES
    // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
    // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
    // DISPLAY UPDATES (Final Clean-up)
    // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
    function updateDisplay() {
        const statusText = qs('#autoRunStatusText');
        if (statusText) statusText.textContent = BotState.statusInfo;

        const analysisText = qs('#analysisStatusText');
        if (analysisText) {
            analysisText.textContent = (BotState.currentEvaluation !== undefined &&
                                        BotState.currentEvaluation !== null &&
                                        BotState.currentEvaluation !== '')
                ? BotState.currentEvaluation
            : '-';
        }

        // üîë Hanya panggil evaluasi bar unified
        updateEvaluationBarUnified();

        const evalEl = qs('[name="currentEvaluation"] .itemState');
        if (evalEl) {
            evalEl.textContent = (BotState.currentEvaluation !== undefined &&
                                  BotState.currentEvaluation !== null &&
                                  BotState.currentEvaluation !== '')
                ? BotState.currentEvaluation
            : '-';

            evalEl.classList.remove('positive', 'negative', 'neutral', 'mate');
            const evalStr = BotState.currentEvaluation;
            if (evalStr && evalStr !== '-') {
                if (evalStr.includes('M')) {
                    evalEl.classList.add('mate');
                } else {
                    const evalNum = parseFloat(evalStr);
                    if (!isNaN(evalNum)) {
                        if (evalNum > 0.3) evalEl.classList.add('positive');
                        else if (evalNum < -0.3) evalEl.classList.add('negative');
                        else evalEl.classList.add('neutral');
                    }
                }
            }
        }

        const bestMoveEl = qs('[name="bestMove"] .itemState');
        if (bestMoveEl) {
            bestMoveEl.textContent = BotState.bestMove || '-';
        }

        const pvEl = qs('[name="pvDisplay"] .itemState');
        if (pvEl) {
            pvEl.textContent = BotState.principalVariation || '-';
        }

        const statusEl = qs('[name="statusInfo"] .itemState');
        if (statusEl) {
            statusEl.textContent = BotState.statusInfo || 'Ready';
            statusEl.classList.remove('ready', 'analyzing', 'waiting', 'error');
            const status = BotState.statusInfo.toLowerCase();
            if (status.includes('ready') || status.includes('‚úì')) statusEl.classList.add('ready');
            else if (status.includes('analyz') || status.includes('üîÑ')) statusEl.classList.add('analyzing');
            else if (status.includes('wait') || status.includes('‚è≥')) statusEl.classList.add('waiting');
            else if (status.includes('error') || status.includes('‚ùå')) statusEl.classList.add('error');
        }
    }

    function updateUIDisplay() {
        const playingAs = pa();

        updateEvaluationBarUnified();
        // Update turn indicators
        const game = getGame();
        const myTurnLed = qs('#turn-indicator-my');
        const oppTurnLed = qs('#turn-indicator-opp');
        const engineLed = qs('#engine-status-led');

        if (myTurnLed && oppTurnLed) {
            const isMyTurn = isPlayersTurn(game);
            myTurnLed.classList.toggle('my-turn', isMyTurn);
            oppTurnLed.classList.toggle('opp-turn', !isMyTurn && game);
        }
        if (engineLed) {
            engineLed.classList.toggle('active', BotState.hackEnabled);
        }

        // Update info tab jika terlihat
        const infoEval = qs('#infoEval');
        const infoBestMove = qs('#infoBestMove');
        const pvDisplay = qs('#pvDisplay');
        const infoStatus = qs('#infoStatus');
        const premoveChanceDisplay = qs('#premoveChanceDisplay');

        if (infoEval) infoEval.textContent = BotState.currentEvaluation || '-';
        if (infoBestMove) infoBestMove.textContent = BotState.bestMove || '-';
        if (pvDisplay) pvDisplay.textContent = BotState.principalVariation || 'Waiting...';
        if (infoStatus) infoStatus.textContent = BotState.statusInfo || 'Ready';
        if (premoveChanceDisplay) {
            const ourColor = getPlayerColor(game);
            const chance = getEvalBasedPremoveChance(BotState.currentEvaluation, ourColor);
            premoveChanceDisplay.textContent = `${Math.round(chance)}%`;
        }
    }

    function updateStatusLeds(main, engine, analysis) {
        const ledMain = qs('#led-main');
        const ledEngine = qs('#led-engine');
        const ledAnalysis = qs('#led-analysis');

        if (ledMain) {
            ledMain.classList.remove('active', 'analyzing', 'error');
            if (main) ledMain.classList.add(main);
        }

        if (ledEngine) {
            ledEngine.classList.remove('active', 'analyzing', 'error');
            if (engine) ledEngine.classList.add(engine);
        }

        if (ledAnalysis) {
            ledAnalysis.classList.remove('active', 'analyzing', 'error');
            if (analysis) ledAnalysis.classList.add(analysis);
        }
    }

    function updateTopMoves() {
        for (let i = 1; i <= 3; i++) {
            const moveEl = qs(`#topMove${i}`);
            const evalEl = qs(`#topMoveEval${i}`);

            if (moveEl && evalEl) {
                const move = BotState.topMoves[i - 1];
                if (move) {
                    moveEl.textContent = move.uci || '...';
                    const evalDisplay = scoreToDisplay(move.score);
                    evalEl.textContent = evalDisplay;

                    // Set eval color class
                    evalEl.classList.remove('eval-positive', 'eval-negative', 'eval-equal');
                    if (move.score?.cp > 50) evalEl.classList.add('eval-positive');
                    else if (move.score?.cp < -50) evalEl.classList.add('eval-negative');
                    else evalEl.classList.add('eval-equal');
                } else {
                    moveEl.textContent = '...';
                    evalEl.textContent = '-';
                }
            }
        }

        // Update FEN display
        const fenDisplay = qs('#currentFenDisplay');
        if (fenDisplay) {
            fenDisplay.textContent = BotState.currentFen || '-';
        }

        // Update PV display
        const pvDisplay = qs('#pvDisplayText');
        if (pvDisplay) {
            pvDisplay.textContent = BotState.principalVariation || '-';
        }
    }

    function updateClockOverlay() {
        const now = new Date();

        // Format waktu menjadi HH:MM:SS
        let hours = now.getHours().toString().padStart(2, '0');
        let minutes = now.getMinutes().toString().padStart(2, '0');
        let seconds = now.getSeconds().toString().padStart(2, '0');

        const timeString = `${hours}:${minutes}:${seconds}`;

        // Temukan elemen jam yang baru ditambahkan
        const clockElement = document.getElementById('digital-clock');

        // Periksa apakah elemen sudah ada di DOM sebelum memperbarui
        if (clockElement) {
            clockElement.textContent = timeString;
        }
    }

    // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
    // EVALUATION BAR UPDATE
    // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
    function updateEvaluationBarUnified() {
        const autoRunFill = qs('#evaluationFillAutoRun');
        const analysisFill = qs('#eval-bar-fill');
        const scoreText = qs('#evaluation-score-text'); // optional label

        if (!autoRunFill || !analysisFill) return;

        const evaluation = BotState.currentEvaluation;
        let score = 0;
        let displayText = '0.00';

        if (typeof evaluation === 'string') {
            if (evaluation === '-' || evaluation === 'Error') {
                autoRunFill.style.width = '50%';
                analysisFill.style.width = '50%';
                displayText = '-';
            } else if (evaluation.includes('M')) {
                const m = parseInt(evaluation.replace('M', '').replace('+', ''), 10);
                score = m > 0 ? 10 : -10;
                displayText = evaluation;
            } else {
                score = parseFloat(evaluation);
                displayText = isNaN(score) ? '-' : (score >= 0 ? `+${score.toFixed(2)}` : score.toFixed(2));
            }
        } else {
            score = parseFloat(evaluation);
            displayText = isNaN(score) ? '-' : (score >= 0 ? `+${score.toFixed(2)}` : score.toFixed(2));
        }

        const maxScore = 5;
        const clampedScore = Math.max(-maxScore, Math.min(maxScore, score));
        const percentage = 50 + (clampedScore / maxScore) * 50;

        autoRunFill.style.width = `${percentage}%`;
        analysisFill.style.width = `${percentage}%`;

        if (scoreText) scoreText.textContent = displayText;

        const panel = qs('.evaluation-bar-panel');
        if (panel) {
            if (score < -2) {
                panel.style.borderColor = 'rgba(244, 67, 54, 0.6)';
            } else if (score > 2) {
                panel.style.borderColor = 'rgba(76, 175, 80, 0.6)';
            } else {
                panel.style.borderColor = 'rgba(255, 255, 255, 0.15)';
            }
        }
    }

    // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
    // BOARD ATTACHMENT
    // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
    function attachToBoard(boardEl) {
        cachedGame = null;
        cachedGameTimestamp = 0;
        detachFromBoard();

        if (!boardEl) {
            console.warn('GabiBot Pro: No board element to attach.');
            return;
        }

        if (getComputedStyle(boardEl).position === 'static') {
            boardEl.style.position = 'relative';
        }

        // --- PERBAIKAN: Gunakan viewBox 0 0 100 100 untuk koordinat persentase ---
        const drawingBoard = document.createElementNS("http://www.w3.org/2000/svg", "svg");
        drawingBoard.id = 'arrowCanvas';
        drawingBoard.setAttribute('viewBox', '0 0 100 100'); // <-- PERBAIKAN: Pakai 100x100
        drawingBoard.setAttribute('preserveAspectRatio', 'none');
        drawingBoard.style.cssText = `
        position: absolute;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        pointer-events: none;
        z-index: 1000;
        overflow: visible;
    `;

        // Create evaluation bar
        const evalBarWrap = document.createElement('div');
        evalBarWrap.id = 'evaluationBarWrap';

        const whiteBar = document.createElement('div');
        whiteBar.id = 'evaluationBarWhite';
        whiteBar.style.height = '50%';

        const blackBar = document.createElement('div');
        blackBar.id = 'evaluationBarBlack';
        blackBar.style.height = '50%';

        const scoreDisplay = document.createElement('div');
        scoreDisplay.id = 'evalScoreDisplay';
        scoreDisplay.textContent = '0.00';

        evalBarWrap.appendChild(whiteBar);
        evalBarWrap.appendChild(blackBar);
        evalBarWrap.appendChild(scoreDisplay);

        boardEl.appendChild(evalBarWrap);
        boardEl.appendChild(drawingBoard);

        // --- PERBAIKAN: Tidak perlu update viewBox saat resize karena pakai persentase ---
        const ro = new ResizeObserver(() => {
            // Hanya perlu redraw arrows jika ada
            if (lastPVData && lastPVData.length > 0 && BotState.showPVArrows) {
                drawPVArrows(lastPVData);
            }
        });
        ro.observe(boardEl);

        const cancelPendingOnUserAction = () => {
            if (pendingMoveTimeoutId) {
                clearTimeout(pendingMoveTimeoutId);
                pendingMoveTimeoutId = null;
            }
        };

        boardEl.addEventListener('mousedown', cancelPendingOnUserAction, true);
        boardEl.addEventListener('touchstart', cancelPendingOnUserAction, { passive: true, capture: true });

        boardCtx = {
            boardEl,
            drawingBoard,
            ctx: null,
            evalBarWrap,
            resizeObserver: ro,
            detachListeners() {
                try { boardEl.removeEventListener('mousedown', cancelPendingOnUserAction, true); } catch {}
                try { boardEl.removeEventListener('touchstart', cancelPendingOnUserAction, { passive: true, capture: true }); } catch {}
                try { ro.disconnect(); } catch {}
                try { drawingBoard.remove(); } catch {}
                try { evalBarWrap.remove(); } catch {}
            }
        };

        console.log('GabiBot Pro: ‚úÖ Board attached with SVG canvas');
        updateDisplay();
        if (BotState.hackEnabled) startTickLoop();
    }

    function detachFromBoard() {
        if (!boardCtx) return;
        try { boardCtx.detachListeners(); } catch {}
        boardCtx = null;
    }

    function startDomBoardWatcher() {
        if (domObserver) try { domObserver.disconnect(); } catch {}

        domObserver = new MutationObserver(debounce(() => {
            const newBoard = qs('chess-board') || qs('.board') || qs('[class*="board"]');
            if (!newBoard) return;
            if (!boardCtx || boardCtx.boardEl !== newBoard) {
                console.log('GabiBot Pro: Board changed, re-attaching.');
                attachToBoard(newBoard);
            }
        }, 200));

        domObserver.observe(document.body, { childList: true, subtree: true });
    }

    // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
    // GAME HELPERS
    // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
    const getBoard = () => boardCtx?.boardEl || qs('chess-board') || qs('.board');

    const getGame = () => {
        const now = Date.now();
        if (cachedGame && (now - cachedGameTimestamp) < GAME_CACHE_TTL) {
            return cachedGame;
        }
        cachedGame = getBoard()?.game || null;
        cachedGameTimestamp = now;
        return cachedGame;
    };

    const getFen = (g) => {
        try { return g?.getFEN ? g.getFEN() : null; }
        catch { return null; }
    };

    const getPlayerColor = (g) => {
        try { const v = g?.getPlayingAs?.(); return v === 2 ? 'b' : 'w'; }
        catch { return 'w'; }
    };

    const getSideToMove = (g) => {
        const fen = getFen(g);
        return fen ? (fen.split(' ')[1] || null) : null;
    };

    const isPlayersTurn = (g) => {
        const me = getPlayerColor(g);
        const stm = getSideToMove(g);
        return !!me && !!stm && me === stm;
    };

    const pa = () => (getGame()?.getPlayingAs ? getGame().getPlayingAs() : 1);

    function isBoardFlipped() {
        const now = Date.now();
        if ((now - cachedFlipTimestamp) < 1000) return cachedBoardFlipped;

        const el = getBoard();
        let flipped = false;

        try {
            const attr = el?.getAttribute?.('orientation');
            if (attr === 'black') flipped = true;
            else if (attr === 'white') flipped = false;
            else if (el?.classList?.contains('flipped')) flipped = true;
            else if (getGame()?.getPlayingAs?.() === 2) flipped = true;
        } catch {}

        cachedBoardFlipped = flipped;
        cachedFlipTimestamp = now;
        return flipped;
    }

    // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
    // ARROW DRAWING SYSTEM - VERSI BERSIH
    // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê

    // Clear hanya panah best move
    function clearBestMoveArrow() {
        const svgCanvas = document.getElementById('arrowCanvas');
        if (svgCanvas) {
            svgCanvas.querySelectorAll('.best-move-arrow').forEach(el => el.remove());
        }
    }

    // Clear hanya panah PV
    function clearPVArrows() {
        const svgCanvas = document.getElementById('arrowCanvas');
        if (svgCanvas) {
            svgCanvas.querySelectorAll('.pv-arrow-group').forEach(el => el.remove());
        }
    }

    // Clear SEMUA panah (untuk reset total)
    function clearArrows() {
        const svgCanvas = document.getElementById('arrowCanvas');
        if (svgCanvas) {
            const defs = svgCanvas.querySelector('defs');
            while (svgCanvas.firstChild) {
                svgCanvas.removeChild(svgCanvas.firstChild);
            }
            if (defs) {
                svgCanvas.appendChild(defs);
            } else {
                svgCanvas.appendChild(document.createElementNS("http://www.w3.org/2000/svg", "defs"));
            }
        }
    }

    // --- HELPER: Koordinat untuk simulasi klik ---
    function getSquareCenterClientXY(square) {
        if (!boardCtx || !square || square.length < 2) return null;
        const file = 'abcdefgh'.indexOf(square[0]);
        const rank = parseInt(square[1], 10);
        if (file < 0 || isNaN(rank)) return null;

        const el = getBoard();
        const rect = el.getBoundingClientRect();
        const size = Math.min(rect.width, rect.height);
        const tile = size / 8;
        const offsetX = rect.left + (rect.width - size) / 2;
        const offsetY = rect.top + (rect.height - size) / 2;

        let x = file, y = 8 - rank;
        if (isBoardFlipped()) { x = 7 - x; y = 7 - y; }

        return { x: offsetX + (x + 0.5) * tile, y: offsetY + (y + 0.5) * tile };
    }

    // --- HELPER: Konversi koordinat kotak ke SVG (0-100) ---
    function getSquarePosition(square, isFlipped) {
        const file = square.charCodeAt(0) - 97; // a-h ‚Üí 0-7
        const rank = parseInt(square[1]) - 1; // 1-8 ‚Üí 0-7

        let x = isFlipped ? (7 - file) : file;
        let y = isFlipped ? rank : (7 - rank);

        return {
            x: x * 12.5 + 6.25, // Tengah kotak (0-100)
            y: y * 12.5 + 6.25
        };
    }

    // --- DRAW BEST MOVE ARROW ---
    function drawArrow(from, to, color, thickness) {
        const svgCanvas = document.getElementById('arrowCanvas');
        if (!svgCanvas || !from || !to) return;

        // Hapus panah lama setiap kali fungsi dipanggil
        clearBestMoveArrow();

        // JIKA OFF: Jangan menggambar apa-apa
        if (!BotState.highlightEnabled) return;

        const isFlipped = isBoardFlipped();
        const start = getSquarePosition(from, isFlipped);
        const end = getSquarePosition(to, isFlipped);

        const dx = end.x - start.x;
        const dy = end.y - start.y;
        const length = Math.sqrt(dx * dx + dy * dy);

        // Pemendekan ujung panah agar tidak menempel ke pusat kotak
        let endX = end.x, endY = end.y;
        const shortenValue = 3.5;
        if (length > shortenValue) {
            const ratio = (length - shortenValue) / length;
            endX = start.x + dx * ratio;
            endY = start.y + dy * ratio;
        }

        const group = document.createElementNS("http://www.w3.org/2000/svg", "g");
        group.setAttribute("class", "best-move-arrow");

        const markerId = `head-bestmove-${color.replace(/[^a-zA-Z0-9]/g, '')}`;
        let defs = svgCanvas.querySelector('defs');
        if (!defs) {
            defs = document.createElementNS("http://www.w3.org/2000/svg", "defs");
            svgCanvas.insertBefore(defs, svgCanvas.firstChild);
        }

        // Marker Kepala Panah Hybrid Tajam & Kurus
        if (!document.getElementById(markerId)) {
            const marker = document.createElementNS("http://www.w3.org/2000/svg", "marker");
            marker.setAttribute("id", markerId);
            marker.setAttribute("markerWidth", "4.5");
            marker.setAttribute("markerHeight", "4.5");
            marker.setAttribute("refX", "2.5");
            marker.setAttribute("refY", "2.25");
            marker.setAttribute("orient", "auto");
            marker.setAttribute("markerUnits", "strokeWidth");

            const arrowHead = document.createElementNS("http://www.w3.org/2000/svg", "polygon");
            // Bentuk Hybrid: Tajam di depan, cekung di belakang (M0,0.5 L4.5,2.25 L0,4 L1,2.25)
            arrowHead.setAttribute("points", "0 0.5, 4.5 2.25, 0 4, 1 2.25");
            arrowHead.setAttribute("fill", color);
            marker.appendChild(arrowHead);
            defs.appendChild(marker);
        }

        // Garis Utama (Dibuat kurus dengan pembagi 3.8)
        const line = document.createElementNS("http://www.w3.org/2000/svg", "line");
        line.setAttribute("x1", start.x);
        line.setAttribute("y1", start.y);
        line.setAttribute("x2", endX);
        line.setAttribute("y2", endY);
        line.setAttribute("stroke", color);
        line.setAttribute("stroke-width", thickness / 3.8);
        line.setAttribute("stroke-linecap", "round");
        line.setAttribute("opacity", "0.85");
        line.setAttribute("marker-end", `url(#${markerId})`);

        group.appendChild(line);
        svgCanvas.appendChild(group);
    }

    // --- DRAW PV ARROWS (Multiple) ---
    function drawPVArrows(pvMoves) {
        console.log('GabiBot Pro: üéØ drawPVArrows called with:', pvMoves);

        if (!boardCtx) {
            const board = getBoard();
            if (board) attachToBoard(board);
            else return;
        }

        if (!pvMoves || !Array.isArray(pvMoves) || pvMoves.length === 0) return;
        if (!BotState.showPVArrows) return;

        let svgCanvas = document.getElementById('arrowCanvas');
        if (!svgCanvas) {
            const board = getBoard();
            if (board) {
                attachToBoard(board);
                svgCanvas = document.getElementById('arrowCanvas');
            }
            if (!svgCanvas) return;
        }

        clearPVArrows();

        const isFlipped = isBoardFlipped();
        const maxArrows = Math.min(pvMoves.length, BotState.pvArrowCount || 5);

        for (let i = 0; i < maxArrows; i++) {
            const uci = pvMoves[i];
            if (!uci || typeof uci !== 'string' || uci.length < 4) continue;

            const from = uci.substring(0, 2);
            const to = uci.substring(2, 4);

            if (!/^[a-h][1-8]$/.test(from) || !/^[a-h][1-8]$/.test(to)) continue;

            const hue = 120 - (i * 25);
            const color = `hsl(${Math.max(0, hue)}, 85%, 50%)`;

            drawPVArrowSVG(svgCanvas, from, to, color, isFlipped, i + 1);
        }

        console.log('GabiBot Pro: ‚úÖ PV arrows drawn');
    }

    // --- DRAW SINGLE PV ARROW ---
    function drawPVArrowSVG(svgCanvas, from, to, color, isFlipped, order) {
        const start = getSquarePosition(from, isFlipped);
        const end = getSquarePosition(to, isFlipped);

        // Perpendek panah
        const dx = end.x - start.x;
        const dy = end.y - start.y;
        const length = Math.sqrt(dx * dx + dy * dy);

        const shortenStart = 2;
        const shortenEnd = 3;

        let startX = start.x, startY = start.y;
        let endX = end.x, endY = end.y;

        if (length > (shortenStart + shortenEnd)) {
            const ratioStart = shortenStart / length;
            const ratioEnd = (length - shortenEnd) / length;
            startX = start.x + dx * ratioStart;
            startY = start.y + dy * ratioStart;
            endX = start.x + dx * ratioEnd;
            endY = start.y + dy * ratioEnd;
        }

        // Group
        const group = document.createElementNS("http://www.w3.org/2000/svg", "g");
        group.setAttribute("class", `pv-arrow-group pv-arrow-${order}`);

        // Marker
        const markerId = `pv-head-${order}-${Date.now()}`;
        let defs = svgCanvas.querySelector('defs');
        if (!defs) {
            defs = document.createElementNS("http://www.w3.org/2000/svg", "defs");
            svgCanvas.insertBefore(defs, svgCanvas.firstChild);
        }

        const marker = document.createElementNS("http://www.w3.org/2000/svg", "marker");
        marker.setAttribute("id", markerId);
        marker.setAttribute("markerWidth", "4");
        marker.setAttribute("markerHeight", "4");
        marker.setAttribute("refX", "3");
        marker.setAttribute("refY", "2");
        marker.setAttribute("orient", "auto");
        marker.setAttribute("markerUnits", "strokeWidth");

        const arrowPath = document.createElementNS("http://www.w3.org/2000/svg", "path");
        arrowPath.setAttribute("d", "M0,0 L4,2 L0,4 L1,2 Z");
        arrowPath.setAttribute("fill", color);
        marker.appendChild(arrowPath);
        defs.appendChild(marker);

        // Shadow
        const shadow = document.createElementNS("http://www.w3.org/2000/svg", "line");
        shadow.setAttribute("x1", startX + 0.3);
        shadow.setAttribute("y1", startY + 0.3);
        shadow.setAttribute("x2", endX + 0.3);
        shadow.setAttribute("y2", endY + 0.3);
        shadow.setAttribute("stroke", "rgba(0,0,0,0.4)");
        shadow.setAttribute("stroke-width", "1.8");
        shadow.setAttribute("stroke-linecap", "round");
        group.appendChild(shadow);

        // Main line
        const line = document.createElementNS("http://www.w3.org/2000/svg", "line");
        line.setAttribute("x1", startX);
        line.setAttribute("y1", startY);
        line.setAttribute("x2", endX);
        line.setAttribute("y2", endY);
        line.setAttribute("stroke", color);
        line.setAttribute("stroke-width", "1.5");
        line.setAttribute("stroke-linecap", "round");
        line.setAttribute("opacity", "0.9");
        line.setAttribute("marker-end", `url(#${markerId})`);
        group.appendChild(line);

        // Number circle
        if (order) {
            const midX = (startX + endX) / 2;
            const midY = (startY + endY) / 2;
            const r = 2.5;

            // Shadow circle
            const circleShadow = document.createElementNS("http://www.w3.org/2000/svg", "circle");
            circleShadow.setAttribute("cx", midX + 0.3);
            circleShadow.setAttribute("cy", midY + 0.3);
            circleShadow.setAttribute("r", r);
            circleShadow.setAttribute("fill", "rgba(0,0,0,0.5)");
            group.appendChild(circleShadow);

            // Main circle
            const circle = document.createElementNS("http://www.w3.org/2000/svg", "circle");
            circle.setAttribute("cx", midX);
            circle.setAttribute("cy", midY);
            circle.setAttribute("r", r);
            circle.setAttribute("fill", "rgba(0,0,0,0.85)");
            circle.setAttribute("stroke", color);
            circle.setAttribute("stroke-width", "0.5");
            group.appendChild(circle);

            // Number text
            const text = document.createElementNS("http://www.w3.org/2000/svg", "text");
            text.setAttribute("x", midX);
            text.setAttribute("y", midY);
            text.setAttribute("fill", "white");
            text.setAttribute("font-size", "3");
            text.setAttribute("font-weight", "bold");
            text.setAttribute("font-family", "Arial, sans-serif");
            text.setAttribute("text-anchor", "middle");
            text.setAttribute("dominant-baseline", "central");
            text.textContent = order.toString();
            group.appendChild(text);
        }

        svgCanvas.appendChild(group);
    }

    // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
    // MOVE EXECUTION (Final Version)
    // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê

    // Dispatch pointer/mouse event
    function dispatchPointerOrMouse(el, type, opts, usePointer) {
        if (!el) return;
        if (usePointer) {
            try {
                el.dispatchEvent(new PointerEvent(type, { bubbles: true, cancelable: true, composed: true, ...opts }));
                return;
            } catch {
                // fallback ke MouseEvent
            }
        }
        el.dispatchEvent(new MouseEvent(type.replace('pointer', 'mouse'), { bubbles: true, cancelable: true, composed: true, ...opts }));
    }

    // Cari target element di koordinat
    function getTargetAt(x, y) {
        return document.elementFromPoint(x, y) || getBoard() || document.body;
    }

    // Simulasi klik dari ‚Üí ke
    async function simulateClickMove(from, to, promotion) {
        const a = getSquareCenterClientXY(from);
        const b = getSquareCenterClientXY(to);
        if (!a || !b) return false;

        const usePointer = !!window.PointerEvent;
        const startEl = getTargetAt(a.x, a.y);
        const endEl = getTargetAt(b.x, b.y);
        if (!startEl || !endEl) return false;

        const fire = (el, type, coords, buttons) => {
            dispatchPointerOrMouse(el, usePointer ? type.replace('mouse','pointer') : type, {
                clientX: coords.x, clientY: coords.y,
                pointerId: 1, pointerType: 'mouse', isPrimary: true, buttons
            }, usePointer);
        };

        // klik asal
        fire(startEl, 'mousedown', a, 1);
        await sleep(15);
        fire(startEl, 'mouseup', a, 0);
        startEl.dispatchEvent(new MouseEvent('click', { bubbles:true, clientX:a.x, clientY:a.y }));

        await sleep(25);

        // klik tujuan
        fire(endEl, 'mousedown', b, 1);
        await sleep(15);
        fire(endEl, 'mouseup', b, 0);
        endEl.dispatchEvent(new MouseEvent('click', { bubbles:true, clientX:b.x, clientY:b.y }));

        return true;
    }

    function isPromotionMove(from, to, color = "w") {
        // putih promosi di rank 8, hitam di rank 1
        const promotionRank = (color === "w") ? "8" : "1";
        const fromRank = from[1];
        const toRank = to[1];
        return (fromRank === (color === "w" ? "7" : "2")) && (toRank === promotionRank);
    }

    // Tunggu FEN berubah
    async function waitForFenChange(prevFen, timeout = 1000) {
        const start = Date.now();
        while (Date.now() - start < timeout) {
            const g = getGame();
            const fen = g?.getFEN ? g.getFEN() : null;
            if (fen && fen !== prevFen) return true;
            await sleep(40);
        }
        return false;
    }

    // Batalkan move pending
    function cancelPendingMove() {
        if (pendingMoveTimeoutId) {
            clearTimeout(pendingMoveTimeoutId);
            pendingMoveTimeoutId = null;
        }
    }

    // Eksekusi move utama langsung ke engine
    async function makeMove(from, to, expectedFen) {
        const promotionChar = getPromotionChoice(); // ambil dari dropdown
        const game = getGame();
        if (!game || !BotState.autoMove) return false;

        const beforeFen = getFen(game);
        if (!beforeFen || beforeFen !== expectedFen || !isPlayersTurn(game)) return false;

        cancelPendingMove();

        const legal = game.getLegalMoves();
        const move = legal.find(m => m.from === from && m.to === to);
        if (!move) return false;

        const color = getPlayerColor(game);

        if (isPromotionMove(from, to, color)) {
            // PROMOSI ‚Üí langsung inject ke engine
            const moveData = {
                ...move,
                animate: true,
                userGenerated: true,
                promotion: String(promotionChar).toLowerCase()
            };
            game.move(moveData);
            console.log("‚úÖ Played (promotion):", from, "‚Üí", to, "promotion:", moveData.promotion);
        } else {
            // MOVE BIASA ‚Üí pakai simulasi klik
            await simulateClickMove(from, to);
            console.log("‚úÖ Played (simulate):", from, "‚Üí", to);
        }

        return await waitForFenChange(beforeFen, 1000);
    }

    // Ambil pilihan promosi dari UI
    function getPromotionChoice() {
        const select = document.getElementById("promotion-select");
        return select ? select.value : "q"; // fallback default queen
    }

    // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
    // ENGINE API
    // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
    function scoreFrom(obj) {
        if (!obj) return {};
        if (typeof obj === 'object') {
            if ('mate' in obj && obj.mate !== 0) return { mate: parseInt(obj.mate, 10) };
            if ('cp' in obj) return { cp: parseInt(obj.cp, 10) };
        }
        if (typeof obj === 'string') {
            if (obj.toUpperCase().includes('M')) {
                const m = parseInt(obj.replace(/[^-0-9]/g, ''), 10);
                if (!isNaN(m)) return { mate: m };
            }
            const cpFloat = parseFloat(obj);
            if (!isNaN(cpFloat)) return { cp: Math.round(cpFloat * 100) };
        }
        if (typeof obj === 'number') return { cp: Math.round(obj * 100) };
        return {};
    }

    function scoreToDisplay(score) {
        if (score && typeof score.mate === 'number' && score.mate !== 0) return `M${score.mate}`;
        if (score && typeof score.cp === 'number') return (score.cp / 100).toFixed(2);
        return '-';
    }

    function scoreNumeric(s) {
        if (!s) return -Infinity;
        if (typeof s.mate === 'number') return s.mate > 0 ? 100000 - s.mate : -100000 - s.mate;
        if (typeof s.cp === 'number') return s.cp;
        return -Infinity;
    }

    async function fetchEngineData(fen, depth, signal) {
        const startTime = performance.now();
        console.log(`GabiBot Pro: üì° API request | FEN: ${fen.substring(0, 25)}... | Depth: ${depth}`);

        const call = async (params) => {
            const url = `${API_URL}?fen=${encodeURIComponent(fen)}&depth=${depth}&${params}`;
            const ctrl = new AbortController();
            const onAbort = () => ctrl.abort('external-abort');

            if (signal?.aborted) {
                ctrl.abort('already-aborted');
                throw new DOMException('Aborted', 'AbortError');
            }

            signal?.addEventListener('abort', onAbort, { once: true });
            const to = setTimeout(() => ctrl.abort('timeout'), ANALYZE_TIMEOUT_MS);

            try {
                const res = await fetch(url, {
                    method: 'GET',
                    headers: { Accept: 'application/json' },
                    signal: ctrl.signal
                });

                const duration = performance.now() - startTime;

                if (!res.ok) {
                    console.warn(`GabiBot Pro: ‚ùå API failed (${res.status}) after ${duration.toFixed(0)}ms`);
                    throw new Error(`API error ${res.status}`);
                }

                const data = await res.json();
                if (data.success === false) {
                    console.warn(`GabiBot Pro: ‚ùå API success=false after ${duration.toFixed(0)}ms`);
                    throw new Error('API success=false');
                }

                console.log(`GabiBot Pro: ‚úÖ API success in ${duration.toFixed(0)}ms`);
                return data;
            } finally {
                clearTimeout(to);
                signal?.removeEventListener('abort', onAbort);
            }
        };

        try { return await call(`multipv=${MULTIPV}&mode=analysis`); }
        catch {
            try { return await call(`multipv=${MULTIPV}&mode=bestmove`); }
            catch { return await call('mode=bestmove'); }
        }
    }

    async function fetchEngineDataWithRetry(fen, depth, signal, maxRetries = 2) {
        if (PositionCache[fen]) {
            console.log('GabiBot Pro: üóÉÔ∏è Using cached analysis');
            return PositionCache[fen];
        }

        let lastError;
        for (let attempt = 0; attempt <= maxRetries; attempt++) {
            if (signal?.aborted || !BotState.hackEnabled) {
                throw new DOMException('Aborted', 'AbortError');
            }

            if (attempt > 0) {
                const backoff = Math.min(1000 * Math.pow(2, attempt - 1), 3000);
                console.log(`GabiBot Pro: üîÅ Retry #${attempt} (backoff: ${backoff}ms)`);
                await sleep(backoff);
            }

            try {
                const data = await fetchEngineData(fen, depth, signal);
                PositionCache[fen] = data;
                return data;
            } catch (error) {
                lastError = error;
                console.warn(`GabiBot Pro: ‚ö†Ô∏è Attempt #${attempt + 1} failed:`, error.message || error);
            }
        }

        console.error(`GabiBot Pro: üí• All attempts failed`);
        throw lastError;
    }

    function parseBestLine(data) {
        const lines = [];
        const pushLine = (uci, pv, score) => {
            if (!uci || uci.length < 4) return;
            lines.push({ uci: uci.trim(), pv: (pv || '').trim(), score: score || {} });
        };

        const addFromArray = (arr) => arr.forEach(item => {
            const pv = item.pv || item.line || item.moves || '';
            const uci = item.uci || (pv ? pv.split(' ')[0] : '');
            const score = scoreFrom(item.score || item.evaluation || item.eval);
            pushLine(uci, pv, score);
        });

        if (Array.isArray(data.analysis)) addFromArray(data.analysis);
        else if (Array.isArray(data.lines)) addFromArray(data.lines);
        else if (Array.isArray(data.pvs)) addFromArray(data.pvs);

        if (!lines.length && typeof data.bestmove === 'string') {
            const parts = data.bestmove.split(' ');
            let uci = parts.length > 1 ? parts[1] : parts[0];
            if (uci === 'bestmove' && parts[1]) uci = parts[1];
            const pv = data.pv || data.continuation || uci;
            const score = scoreFrom(data.evaluation);
            pushLine(uci, pv, score);
        }

        lines.sort((a, b) => scoreNumeric(b.score) - scoreNumeric(a.score));
        return lines[0] || null;
    }

    // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
    // CHESS MOVE GENERATOR - FULL LEGAL MOVES
    // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê

    const ChessEngine = {
        files: 'abcdefgh',

        // ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
        // HELPER FUNCTIONS
        // ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ

        fileToIdx(c) {
            return c.charCodeAt(0) - 97;
        },

        idxToFile(i) {
            return this.files[i];
        },

        // Parse FEN ke 2D board array
        fenToBoard(fen) {
            const placement = fen.split(' ')[0];
            const board = Array(8).fill(null).map(() => Array(8).fill(null));
            const ranks = placement.split('/');

            for (let r = 0; r < 8; r++) {
                let file = 0;
                for (const ch of ranks[r]) {
                    if (/\d/.test(ch)) {
                        file += parseInt(ch);
                    } else {
                        board[r][file] = ch;
                        file++;
                    }
                }
            }
            return board; // board[0] = rank 8, board[7] = rank 1
        },

        // Board array ke FEN placement
        boardToFen(board) {
            const rows = [];
            for (let r = 0; r < 8; r++) {
                let row = '';
                let empty = 0;
                for (let f = 0; f < 8; f++) {
                    if (board[r][f]) {
                        if (empty > 0) {
                            row += empty;
                            empty = 0;
                        }
                        row += board[r][f];
                    } else {
                        empty++;
                    }
                }
                if (empty > 0) row += empty;
                rows.push(row);
            }
            return rows.join('/');
        },

        // Get piece at (file 0-7, rank 1-8) from board
        pieceAtBoard(board, file, rank) {
            if (file < 0 || file > 7 || rank < 1 || rank > 8) return null;
            const row = 8 - rank;
            return board[row][file];
        },

        // Set piece at (file 0-7, rank 1-8) on board
        setPieceBoard(board, file, rank, piece) {
            const row = 8 - rank;
            board[row][file] = piece;
        },

        colorOf(piece) {
            if (!piece) return null;
            return piece === piece.toUpperCase() ? 'w' : 'b';
        },

        isEnemy(piece, color) {
            return piece && this.colorOf(piece) !== color;
        },

        isFriendly(piece, color) {
            return piece && this.colorOf(piece) === color;
        },

        // ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
        // FIND KING POSITION
        // ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ

        findKing(board, color) {
            const kingChar = color === 'w' ? 'K' : 'k';
            for (let rank = 1; rank <= 8; rank++) {
                for (let file = 0; file < 8; file++) {
                    if (this.pieceAtBoard(board, file, rank) === kingChar) {
                        return { file, rank };
                    }
                }
            }
            return null; // King not found (shouldn't happen in valid position)
        },

        // ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
        // CHECK IF SQUARE IS ATTACKED BY COLOR
        // ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ

        isSquareAttacked(board, targetFile, targetRank, byColor) {
            // Check attacks from pawns
            const pawnDir = byColor === 'w' ? -1 : 1; // Direction pawns attack FROM
            const pawnChar = byColor === 'w' ? 'P' : 'p';

            for (const df of [-1, 1]) {
                const pf = targetFile + df;
                const pr = targetRank + pawnDir;
                if (pf >= 0 && pf < 8 && pr >= 1 && pr <= 8) {
                    if (this.pieceAtBoard(board, pf, pr) === pawnChar) {
                        return true;
                    }
                }
            }

            // Check attacks from knights
            const knightChar = byColor === 'w' ? 'N' : 'n';
            const knightOffsets = [[1,2],[1,-2],[-1,2],[-1,-2],[2,1],[2,-1],[-2,1],[-2,-1]];

            for (const [df, dr] of knightOffsets) {
                const nf = targetFile + df;
                const nr = targetRank + dr;
                if (nf >= 0 && nf < 8 && nr >= 1 && nr <= 8) {
                    if (this.pieceAtBoard(board, nf, nr) === knightChar) {
                        return true;
                    }
                }
            }

            // Check attacks from king
            const kingChar = byColor === 'w' ? 'K' : 'k';
            for (let df = -1; df <= 1; df++) {
                for (let dr = -1; dr <= 1; dr++) {
                    if (df === 0 && dr === 0) continue;
                    const kf = targetFile + df;
                    const kr = targetRank + dr;
                    if (kf >= 0 && kf < 8 && kr >= 1 && kr <= 8) {
                        if (this.pieceAtBoard(board, kf, kr) === kingChar) {
                            return true;
                        }
                    }
                }
            }

            // Check attacks from sliding pieces (bishop, rook, queen)
            const bishopDirs = [[1,1],[1,-1],[-1,1],[-1,-1]];
            const rookDirs = [[0,1],[0,-1],[1,0],[-1,0]];

            const bishopChar = byColor === 'w' ? 'B' : 'b';
            const rookChar = byColor === 'w' ? 'R' : 'r';
            const queenChar = byColor === 'w' ? 'Q' : 'q';

            // Check diagonal attacks (bishop, queen)
            for (const [df, dr] of bishopDirs) {
                let f = targetFile + df;
                let r = targetRank + dr;
                while (f >= 0 && f < 8 && r >= 1 && r <= 8) {
                    const piece = this.pieceAtBoard(board, f, r);
                    if (piece) {
                        if (piece === bishopChar || piece === queenChar) {
                            return true;
                        }
                        break; // Blocked
                    }
                    f += df;
                    r += dr;
                }
            }

            // Check straight attacks (rook, queen)
            for (const [df, dr] of rookDirs) {
                let f = targetFile + df;
                let r = targetRank + dr;
                while (f >= 0 && f < 8 && r >= 1 && r <= 8) {
                    const piece = this.pieceAtBoard(board, f, r);
                    if (piece) {
                        if (piece === rookChar || piece === queenChar) {
                            return true;
                        }
                        break; // Blocked
                    }
                    f += df;
                    r += dr;
                }
            }

            return false;
        },

        // ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
        // CHECK IF KING IS IN CHECK
        // ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ

        isKingInCheck(board, kingColor) {
            const kingPos = this.findKing(board, kingColor);
            if (!kingPos) return false;

            const enemyColor = kingColor === 'w' ? 'b' : 'w';
            return this.isSquareAttacked(board, kingPos.file, kingPos.rank, enemyColor);
        },

        // ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
        // APPLY MOVE TO BOARD (Returns new board)
        // ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ

        applyMove(board, fromF, fromR, toF, toR, promo = null, isEnPassant = false, isCastling = null) {
            // Clone board
            const newBoard = board.map(row => [...row]);

            const piece = this.pieceAtBoard(newBoard, fromF, fromR);

            // Handle castling
            if (isCastling) {
                const rank = fromR;
                if (isCastling === 'K') { // Kingside
                    this.setPieceBoard(newBoard, 4, rank, null); // Remove king
                    this.setPieceBoard(newBoard, 7, rank, null); // Remove rook
                    this.setPieceBoard(newBoard, 6, rank, piece); // Place king
                    this.setPieceBoard(newBoard, 5, rank, this.colorOf(piece) === 'w' ? 'R' : 'r'); // Place rook
                } else { // Queenside
                    this.setPieceBoard(newBoard, 4, rank, null); // Remove king
                    this.setPieceBoard(newBoard, 0, rank, null); // Remove rook
                    this.setPieceBoard(newBoard, 2, rank, piece); // Place king
                    this.setPieceBoard(newBoard, 3, rank, this.colorOf(piece) === 'w' ? 'R' : 'r'); // Place rook
                }
                return newBoard;
            }

            // Handle en passant capture
            if (isEnPassant) {
                const capturedPawnRank = fromR; // The captured pawn is on same rank as moving pawn
                this.setPieceBoard(newBoard, toF, capturedPawnRank, null);
            }

            // Move the piece
            this.setPieceBoard(newBoard, fromF, fromR, null);

            // Handle promotion
            if (promo) {
                const promoChar = this.colorOf(piece) === 'w' ? promo.toUpperCase() : promo.toLowerCase();
                this.setPieceBoard(newBoard, toF, toR, promoChar);
            } else {
                this.setPieceBoard(newBoard, toF, toR, piece);
            }

            return newBoard;
        },

        // ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
        // GENERATE PSEUDO-LEGAL MOVES (tanpa check validation)
        // ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ

        generatePseudoLegalMoves(fen) {
            const parts = fen.split(' ');
            const sideToMove = parts[1];
            const castling = parts[2] || '-';
            const enPassant = parts[3] || '-';

            const board = this.fenToBoard(fen);
            const moves = [];

            const isEmpty = (f, r) => this.pieceAtBoard(board, f, r) === null;

            const pushMove = (fromF, fromR, toF, toR, piece, promo = null, isEP = false, castleType = null) => {
                moves.push({
                    fromF, fromR, toF, toR,
                    piece,
                    promo,
                    isEnPassant: isEP,
                    castling: castleType
                });
            };

            // Loop semua kotak
            for (let rank = 1; rank <= 8; rank++) {
                for (let file = 0; file < 8; file++) {
                    const piece = this.pieceAtBoard(board, file, rank);
                    if (!piece) continue;

                    const color = this.colorOf(piece);
                    if (color !== sideToMove) continue;

                    const pieceLower = piece.toLowerCase();

                    // ‚îÄ‚îÄ‚îÄ KNIGHT ‚îÄ‚îÄ‚îÄ
                    if (pieceLower === 'n') {
                        const offsets = [[1,2],[1,-2],[-1,2],[-1,-2],[2,1],[2,-1],[-2,1],[-2,-1]];
                        for (const [df, dr] of offsets) {
                            const tf = file + df, tr = rank + dr;
                            if (tf >= 0 && tf < 8 && tr >= 1 && tr <= 8) {
                                const target = this.pieceAtBoard(board, tf, tr);
                                if (!target || this.isEnemy(target, color)) {
                                    pushMove(file, rank, tf, tr, piece);
                                }
                            }
                        }
                    }

                    // ‚îÄ‚îÄ‚îÄ SLIDING PIECES (Bishop, Rook, Queen) ‚îÄ‚îÄ‚îÄ
                    const slide = (directions) => {
                        for (const [df, dr] of directions) {
                            let tf = file + df, tr = rank + dr;
                            while (tf >= 0 && tf < 8 && tr >= 1 && tr <= 8) {
                                const target = this.pieceAtBoard(board, tf, tr);
                                if (!target) {
                                    pushMove(file, rank, tf, tr, piece);
                                } else {
                                    if (this.isEnemy(target, color)) {
                                        pushMove(file, rank, tf, tr, piece);
                                    }
                                    break;
                                }
                                tf += df;
                                tr += dr;
                            }
                        }
                    };

                    if (pieceLower === 'b') slide([[1,1],[1,-1],[-1,1],[-1,-1]]);
                    if (pieceLower === 'r') slide([[0,1],[0,-1],[1,0],[-1,0]]);
                    if (pieceLower === 'q') slide([[1,1],[1,-1],[-1,1],[-1,-1],[0,1],[0,-1],[1,0],[-1,0]]);

                    // ‚îÄ‚îÄ‚îÄ KING (non-castling) ‚îÄ‚îÄ‚îÄ
                    if (pieceLower === 'k') {
                        for (let df = -1; df <= 1; df++) {
                            for (let dr = -1; dr <= 1; dr++) {
                                if (df === 0 && dr === 0) continue;
                                const tf = file + df, tr = rank + dr;
                                if (tf >= 0 && tf < 8 && tr >= 1 && tr <= 8) {
                                    const target = this.pieceAtBoard(board, tf, tr);
                                    if (!target || this.isEnemy(target, color)) {
                                        pushMove(file, rank, tf, tr, piece);
                                    }
                                }
                            }
                        }
                    }

                    // ‚îÄ‚îÄ‚îÄ PAWN ‚îÄ‚îÄ‚îÄ
                    if (pieceLower === 'p') {
                        const dir = color === 'w' ? 1 : -1;
                        const startRank = color === 'w' ? 2 : 7;
                        const promoRank = color === 'w' ? 8 : 1;

                        // Forward moves
                        const oneFwd = rank + dir;
                        if (oneFwd >= 1 && oneFwd <= 8 && isEmpty(file, oneFwd)) {
                            if (oneFwd === promoRank) {
                                ['q','r','b','n'].forEach(p => pushMove(file, rank, file, oneFwd, piece, p));
                            } else {
                                pushMove(file, rank, file, oneFwd, piece);

                                // Two squares from start
                                if (rank === startRank) {
                                    const twoFwd = rank + 2 * dir;
                                    if (isEmpty(file, twoFwd)) {
                                        pushMove(file, rank, file, twoFwd, piece);
                                    }
                                }
                            }
                        }

                        // Captures
                        for (const df of [-1, 1]) {
                            const cf = file + df;
                            if (cf < 0 || cf > 7) continue;

                            const captureRank = rank + dir;
                            if (captureRank < 1 || captureRank > 8) continue;

                            const target = this.pieceAtBoard(board, cf, captureRank);

                            if (target && this.isEnemy(target, color)) {
                                if (captureRank === promoRank) {
                                    ['q','r','b','n'].forEach(p => pushMove(file, rank, cf, captureRank, piece, p));
                                } else {
                                    pushMove(file, rank, cf, captureRank, piece);
                                }
                            }
                            // En passant
                            else if (enPassant !== '-') {
                                const epFile = this.fileToIdx(enPassant[0]);
                                const epRank = parseInt(enPassant[1]);
                                if (cf === epFile && captureRank === epRank) {
                                    pushMove(file, rank, cf, captureRank, piece, null, true);
                                }
                            }
                        }
                    }
                }
            }

            // ‚îÄ‚îÄ‚îÄ CASTLING ‚îÄ‚îÄ‚îÄ
            const kingFile = 4;
            const kingRank = sideToMove === 'w' ? 1 : 8;
            const kingPiece = this.pieceAtBoard(board, kingFile, kingRank);
            const expectedKing = sideToMove === 'w' ? 'K' : 'k';

            if (kingPiece === expectedKing) {
                const enemyColor = sideToMove === 'w' ? 'b' : 'w';

                // Check if king is currently in check
                const inCheck = this.isSquareAttacked(board, kingFile, kingRank, enemyColor);

                if (!inCheck) {
                    // Kingside
                    const canCastleKingside = sideToMove === 'w' ? castling.includes('K') : castling.includes('k');
                    if (canCastleKingside) {
                        const rookPiece = this.pieceAtBoard(board, 7, kingRank);
                        const expectedRook = sideToMove === 'w' ? 'R' : 'r';

                        if (rookPiece === expectedRook &&
                            isEmpty(5, kingRank) && isEmpty(6, kingRank) &&
                            !this.isSquareAttacked(board, 5, kingRank, enemyColor) &&
                            !this.isSquareAttacked(board, 6, kingRank, enemyColor)) {
                            pushMove(4, kingRank, 6, kingRank, kingPiece, null, false, 'K');
                        }
                    }

                    // Queenside
                    const canCastleQueenside = sideToMove === 'w' ? castling.includes('Q') : castling.includes('q');
                    if (canCastleQueenside) {
                        const rookPiece = this.pieceAtBoard(board, 0, kingRank);
                        const expectedRook = sideToMove === 'w' ? 'R' : 'r';

                        if (rookPiece === expectedRook &&
                            isEmpty(1, kingRank) && isEmpty(2, kingRank) && isEmpty(3, kingRank) &&
                            !this.isSquareAttacked(board, 2, kingRank, enemyColor) &&
                            !this.isSquareAttacked(board, 3, kingRank, enemyColor)) {
                            pushMove(4, kingRank, 2, kingRank, kingPiece, null, false, 'Q');
                        }
                    }
                }
            }

            return { moves, board, sideToMove };
        },

        // ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
        // GENERATE FULLY LEGAL MOVES
        // ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ

        generateLegalMoves(fen) {
            const { moves: pseudoMoves, board, sideToMove } = this.generatePseudoLegalMoves(fen);
            const legalMoves = [];

            for (const move of pseudoMoves) {
                const { fromF, fromR, toF, toR, piece, promo, isEnPassant, castling: castleType } = move;

                // Apply move to get new board state
                const newBoard = this.applyMove(
                    board,
                    fromF, fromR, toF, toR,
                    promo, isEnPassant, castleType
                );

                // Check if our king is in check after the move
                if (!this.isKingInCheck(newBoard, sideToMove)) {
                    legalMoves.push(move);
                }
            }

            // Convert to final format with UCI and SAN
            return this.formatMoves(legalMoves, board, fen);
        },

        // ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
        // FORMAT MOVES (Add UCI, SAN with disambiguation)
        // ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ

        formatMoves(moves, board, fen) {
            const result = [];

            for (const move of moves) {
                const { fromF, fromR, toF, toR, piece, promo, isEnPassant, castling: castleType } = move;

                // Generate UCI
                const from = this.idxToFile(fromF) + fromR;
                const to = this.idxToFile(toF) + toR;
                const uci = promo ? from + to + promo.toLowerCase() : from + to;

                // Generate SAN
                let san;

                if (castleType === 'K') {
                    san = 'O-O';
                } else if (castleType === 'Q') {
                    san = 'O-O-O';
                } else {
                    const pieceLetter = piece.toUpperCase();
                    const isCapture = this.pieceAtBoard(board, toF, toR) || isEnPassant;
                    const promoSAN = promo ? '=' + promo.toUpperCase() : '';

                    if (pieceLetter === 'P') {
                        // Pawn
                        san = (isCapture ? this.idxToFile(fromF) + 'x' : '') +
                            this.idxToFile(toF) + toR + promoSAN;
                    } else {
                        // Piece - check for disambiguation
                        const disambig = this.getDisambiguation(moves, move);
                        san = pieceLetter + disambig +
                            (isCapture ? 'x' : '') +
                            this.idxToFile(toF) + toR + promoSAN;
                    }
                }

                result.push({
                    uci,
                    san,
                    piece: piece.toLowerCase(),
                    from,
                    to
                });
            }

            return result;
        },

        // ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
        // GET DISAMBIGUATION STRING
        // ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ

        getDisambiguation(allMoves, currentMove) {
            const { fromF, fromR, toF, toR, piece } = currentMove;
            const pieceLower = piece.toLowerCase();

            // Find other moves with same piece type going to same square
            const conflicting = allMoves.filter(m =>
                                                m.piece.toLowerCase() === pieceLower &&
                                                m.toF === toF && m.toR === toR &&
                                                (m.fromF !== fromF || m.fromR !== fromR)
                                               );

            if (conflicting.length === 0) return '';

            const sameFile = conflicting.some(m => m.fromF === fromF);
            const sameRank = conflicting.some(m => m.fromR === fromR);

            if (!sameFile) {
                return this.idxToFile(fromF);
            } else if (!sameRank) {
                return fromR.toString();
            } else {
                return this.idxToFile(fromF) + fromR;
            }
        },

        // ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
        // MAKE MOVE & GET NEW FEN
        // ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ

        makeMove(fen, uciMove) {
            const parts = fen.split(' ');
            const sideToMove = parts[1];
            const castling = parts[2] || '-';
            const enPassant = parts[3] || '-';
            const halfMove = parseInt(parts[4] || '0');
            const fullMove = parseInt(parts[5] || '1');

            const board = this.fenToBoard(fen);

            // Parse UCI move
            const fromF = this.fileToIdx(uciMove[0]);
            const fromR = parseInt(uciMove[1]);
            const toF = this.fileToIdx(uciMove[2]);
            const toR = parseInt(uciMove[3]);
            const promo = uciMove[4] || null;

            const piece = this.pieceAtBoard(board, fromF, fromR);
            const pieceLower = piece ? piece.toLowerCase() : null;
            const captured = this.pieceAtBoard(board, toF, toR);

            // Detect special moves
            let isEnPassant = false;
            let castleType = null;

            if (pieceLower === 'p' && toF !== fromF && !captured) {
                isEnPassant = true;
            }

            if (pieceLower === 'k' && Math.abs(toF - fromF) === 2) {
                castleType = toF > fromF ? 'K' : 'Q';
            }

            // Apply move
            const newBoard = this.applyMove(board, fromF, fromR, toF, toR, promo, isEnPassant, castleType);

            // Update castling rights
            let newCastling = castling;
            if (pieceLower === 'k') {
                if (sideToMove === 'w') {
                    newCastling = newCastling.replace('K', '').replace('Q', '');
                } else {
                    newCastling = newCastling.replace('k', '').replace('q', '');
                }
            }
            if (pieceLower === 'r') {
                if (fromF === 0 && fromR === 1) newCastling = newCastling.replace('Q', '');
                if (fromF === 7 && fromR === 1) newCastling = newCastling.replace('K', '');
                if (fromF === 0 && fromR === 8) newCastling = newCastling.replace('q', '');
                if (fromF === 7 && fromR === 8) newCastling = newCastling.replace('k', '');
            }
            if (newCastling === '') newCastling = '-';

            // Update en passant square
            let newEnPassant = '-';
            if (pieceLower === 'p' && Math.abs(toR - fromR) === 2) {
                const epRank = sideToMove === 'w' ? 3 : 6;
                newEnPassant = this.idxToFile(fromF) + epRank;
            }

            // Update move counters
            const newHalfMove = (pieceLower === 'p' || captured) ? 0 : halfMove + 1;
            const newFullMove = sideToMove === 'b' ? fullMove + 1 : fullMove;
            const newSide = sideToMove === 'w' ? 'b' : 'w';

            // Construct new FEN
            return `${this.boardToFen(newBoard)} ${newSide} ${newCastling} ${newEnPassant} ${newHalfMove} ${newFullMove}`;
        },

        // ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
        // UTILITY: CHECK GAME STATE
        // ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ

        isCheckmate(fen) {
            const parts = fen.split(' ');
            const sideToMove = parts[1];
            const board = this.fenToBoard(fen);

            // Must be in check
            if (!this.isKingInCheck(board, sideToMove)) return false;

            // Must have no legal moves
            const legalMoves = this.generateLegalMoves(fen);
            return legalMoves.length === 0;
        },

        isStalemate(fen) {
            const parts = fen.split(' ');
            const sideToMove = parts[1];
            const board = this.fenToBoard(fen);

            // Must NOT be in check
            if (this.isKingInCheck(board, sideToMove)) return false;

            // Must have no legal moves
            const legalMoves = this.generateLegalMoves(fen);
            return legalMoves.length === 0;
        },

        isInCheck(fen) {
            const parts = fen.split(' ');
            const sideToMove = parts[1];
            const board = this.fenToBoard(fen);
            return this.isKingInCheck(board, sideToMove);
        }
    };

    // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
    // WRAPPER FUNCTIONS (untuk kompatibilitas dengan kode lama)
    // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê

    function generateLegalMoves(fen) {
        return ChessEngine.generateLegalMoves(fen);
    }

    function sanToUci(san, fen) {
        if (!san || !fen) return null;

        // Handle castling
        if (san === 'O-O' || san === '0-0') {
            const sideToMove = fen.split(' ')[1];
            return sideToMove === 'w' ? 'e1g1' : 'e8g8';
        }
        if (san === 'O-O-O' || san === '0-0-0') {
            const sideToMove = fen.split(' ')[1];
            return sideToMove === 'w' ? 'e1c1' : 'e8c8';
        }

        // Normalize SAN
        const cleanSan = san.replace(/[+#!?]/g, '');

        const legalMoves = generateLegalMoves(fen);

        // Exact match
        let match = legalMoves.find(m => m.san === cleanSan);
        if (match) return match.uci;

        // Without '=' for promotion
        match = legalMoves.find(m => m.san.replace('=', '') === cleanSan);
        if (match) return match.uci;

        // Fuzzy match by target square
        const targetMatch = cleanSan.match(/([a-h][1-8])/);
        if (targetMatch) {
            const targetSquare = targetMatch[1];
            const pieceMatch = cleanSan.match(/^([KQRBN])/);
            const pieceType = pieceMatch ? pieceMatch[1].toLowerCase() : 'p';

            const candidates = legalMoves.filter(m =>
                                                 m.to === targetSquare &&
                                                 m.piece === pieceType
                                                );

            if (candidates.length === 1) {
                return candidates[0].uci;
            }
        }

        return null;
    }

    function uciToSan(uci, fen) {
        if (!uci || !fen) return null;

        const legalMoves = generateLegalMoves(fen);
        const match = legalMoves.find(m => m.uci === uci);
        return match ? match.san : null;
    }

    function parsePVMoves(pvString, fen = null) {
        if (!pvString || typeof pvString !== 'string') {
            return [];
        }

        const tokens = pvString.trim().split(/\s+/);
        const uciMoves = [];
        let currentFen = fen;

        for (const token of tokens) {
            // Skip move numbers
            if (/^\d+\.+$/.test(token)) continue;

            // Skip evaluations
            if (/^[+-]?\d+\.?\d*$/.test(token) && !token.match(/^[a-h]/)) continue;

            // Skip ellipsis
            if (token === '...' || token === '..') continue;

            // Castling
            if (token === 'O-O' || token === '0-0') {
                if (currentFen) {
                    const sideToMove = currentFen.split(' ')[1];
                    const uci = sideToMove === 'w' ? 'e1g1' : 'e8g8';
                    uciMoves.push(uci);
                    currentFen = ChessEngine.makeMove(currentFen, uci);
                }
                continue;
            }

            if (token === 'O-O-O' || token === '0-0-0') {
                if (currentFen) {
                    const sideToMove = currentFen.split(' ')[1];
                    const uci = sideToMove === 'w' ? 'e1c1' : 'e8c8';
                    uciMoves.push(uci);
                    currentFen = ChessEngine.makeMove(currentFen, uci);
                }
                continue;
            }

            // UCI format
            if (/^[a-h][1-8][a-h][1-8][qrbnQRBN]?$/.test(token)) {
                const uci = token.toLowerCase();
                uciMoves.push(uci);
                if (currentFen) {
                    try {
                        currentFen = ChessEngine.makeMove(currentFen, uci);
                    } catch (e) {
                        // Invalid move, stop parsing
                        break;
                    }
                }
                continue;
            }

            // SAN format
            if (currentFen) {
                const uci = sanToUci(token, currentFen);
                if (uci) {
                    uciMoves.push(uci);
                    try {
                        currentFen = ChessEngine.makeMove(currentFen, uci);
                    } catch (e) {
                        break;
                    }
                }
            }
        }

        return uciMoves;
    }

    // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
    // FEN UTILITIES - FIXED & IMPROVED
    // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê

    function fenCharAtSquare(fen, square) {
        if (!fen || !square) return null;
        const placement = fen.split(' ')[0];
        const ranks = placement.split('/');
        const file = 'abcdefgh'.indexOf(square[0]);
        const rankNum = parseInt(square[1], 10);

        if (file < 0 || rankNum < 1 || rankNum > 8 || ranks.length !== 8) return null;

        const row = 8 - rankNum;
        const rowStr = ranks[row];
        let col = 0;

        for (const ch of rowStr) {
            if (/\d/.test(ch)) {
                const emptyCount = parseInt(ch, 10);
                if (file < col + emptyCount) return null; // Empty square
                col += emptyCount;
            } else {
                if (col === file) return ch;
                col++;
            }
        }
        return null;
    }

    function pieceFromFenChar(ch) {
        if (!ch) return null;
        const isUpper = ch === ch.toUpperCase();
        return { color: isUpper ? 'w' : 'b', type: ch.toLowerCase() };
    }

    function isEnPassantCapture(fen, from, to, ourColor) {
        const parts = fen.split(' ');
        const ep = parts[3];
        const fromPiece = pieceFromFenChar(fenCharAtSquare(fen, from));

        if (!fromPiece || fromPiece.color !== ourColor || fromPiece.type !== 'p') return false;
        return ep && ep !== '-' && to === ep && from[0] !== to[0];
    }

    // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
    // IMPROVED makeSimpleMove - Handles ALL special cases
    // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê

    function makeSimpleMove(fen, uciMove) {
        if (!fen || !uciMove || uciMove.length < 4) return fen;

        try {
            const parts = fen.split(' ');
            const placement = parts[0];
            const sideToMove = parts[1] || 'w';
            let castling = parts[2] || '-';
            let enPassant = parts[3] || '-';
            let halfMove = parseInt(parts[4] || '0', 10);
            let fullMove = parseInt(parts[5] || '1', 10);

            // Parse UCI move
            const from = uciMove.substring(0, 2);
            const to = uciMove.substring(2, 4);
            const promotion = uciMove[4] || null;

            const fromFile = 'abcdefgh'.indexOf(from[0]);
            const fromRank = parseInt(from[1], 10);
            const toFile = 'abcdefgh'.indexOf(to[0]);
            const toRank = parseInt(to[1], 10);

            if (fromFile < 0 || toFile < 0 || fromRank < 1 || toRank < 1) return fen;

            // Expand ranks to 8-char strings
            const expandRank = (rank) => {
                let expanded = '';
                for (const ch of rank) {
                    if (/\d/.test(ch)) {
                        expanded += '.'.repeat(parseInt(ch, 10));
                    } else {
                        expanded += ch;
                    }
                }
                return expanded;
            };

            // Compress back to FEN format
            const compressRank = (expanded) => {
                let compressed = '';
                let emptyCount = 0;
                for (const ch of expanded) {
                    if (ch === '.') {
                        emptyCount++;
                    } else {
                        if (emptyCount > 0) {
                            compressed += emptyCount;
                            emptyCount = 0;
                        }
                        compressed += ch;
                    }
                }
                if (emptyCount > 0) compressed += emptyCount;
                return compressed;
            };

            // Helper to set a square
            const setSquare = (ranks, file, rank, piece) => {
                const rowIdx = 8 - rank;
                const row = ranks[rowIdx];
                ranks[rowIdx] = row.substring(0, file) + piece + row.substring(file + 1);
            };

            // Helper to get a square
            const getSquare = (ranks, file, rank) => {
                const rowIdx = 8 - rank;
                return ranks[rowIdx][file];
            };

            // Expand all ranks
            const expandedRanks = placement.split('/').map(expandRank);

            // Get piece being moved
            const piece = getSquare(expandedRanks, fromFile, fromRank);
            if (!piece || piece === '.') return fen;

            const pieceType = piece.toLowerCase();
            const pieceColor = piece === piece.toUpperCase() ? 'w' : 'b';
            const targetPiece = getSquare(expandedRanks, toFile, toRank);
            const isCapture = targetPiece && targetPiece !== '.';

            // ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
            // HANDLE SPECIAL MOVES
            // ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ

            // 1. EN PASSANT
            let isEnPassant = false;
            if (pieceType === 'p' && to === enPassant && fromFile !== toFile) {
                isEnPassant = true;
                // Remove the captured pawn
                const capturedPawnRank = fromRank; // Same rank as moving pawn
                setSquare(expandedRanks, toFile, capturedPawnRank, '.');
            }

            // 2. CASTLING
            let isCastling = false;
            if (pieceType === 'k' && Math.abs(toFile - fromFile) === 2) {
                isCastling = true;
                const rank = fromRank;

                if (toFile > fromFile) {
                    // Kingside castling
                    const rook = getSquare(expandedRanks, 7, rank);
                    setSquare(expandedRanks, 7, rank, '.');
                    setSquare(expandedRanks, 5, rank, rook);
                } else {
                    // Queenside castling
                    const rook = getSquare(expandedRanks, 0, rank);
                    setSquare(expandedRanks, 0, rank, '.');
                    setSquare(expandedRanks, 3, rank, rook);
                }
            }

            // Move the piece
            setSquare(expandedRanks, fromFile, fromRank, '.');

            // 3. PROMOTION
            let finalPiece = piece;
            if (promotion) {
                finalPiece = pieceColor === 'w' ? promotion.toUpperCase() : promotion.toLowerCase();
            }
            setSquare(expandedRanks, toFile, toRank, finalPiece);

            // ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
            // UPDATE GAME STATE
            // ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ

            // 4. UPDATE CASTLING RIGHTS
            if (castling !== '-') {
                // King moved
                if (pieceType === 'k') {
                    if (pieceColor === 'w') {
                        castling = castling.replace('K', '').replace('Q', '');
                    } else {
                        castling = castling.replace('k', '').replace('q', '');
                    }
                }
                // Rook moved or captured
                if (pieceType === 'r' || isCapture) {
                    // White rooks
                    if (from === 'a1' || to === 'a1') castling = castling.replace('Q', '');
                    if (from === 'h1' || to === 'h1') castling = castling.replace('K', '');
                    // Black rooks
                    if (from === 'a8' || to === 'a8') castling = castling.replace('q', '');
                    if (from === 'h8' || to === 'h8') castling = castling.replace('k', '');
                }
                if (castling === '') castling = '-';
            }

            // 5. UPDATE EN PASSANT SQUARE
            enPassant = '-';
            if (pieceType === 'p' && Math.abs(toRank - fromRank) === 2) {
                // Pawn moved 2 squares
                const epRank = pieceColor === 'w' ? 3 : 6;
                enPassant = 'abcdefgh'[fromFile] + epRank;
            }

            // 6. UPDATE HALFMOVE CLOCK
            if (pieceType === 'p' || isCapture || isEnPassant) {
                halfMove = 0;
            } else {
                halfMove++;
            }

            // 7. UPDATE FULLMOVE NUMBER
            if (sideToMove === 'b') {
                fullMove++;
            }

            // 8. TOGGLE SIDE TO MOVE
            const newSideToMove = sideToMove === 'w' ? 'b' : 'w';

            // Build new FEN
            const newPlacement = expandedRanks.map(compressRank).join('/');
            return `${newPlacement} ${newSideToMove} ${castling} ${enPassant} ${halfMove} ${fullMove}`;

        } catch (e) {
            console.warn('makeSimpleMove error:', e);
            return fen;
        }
    }

    // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
    // IMPROVED getOurMoveFromPV - Now passes FEN for proper parsing
    // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê

    function getOurMoveFromPV(pv, ourColor, sideToMove, fen = null) {
        if (!pv) return null;

        // ‚úÖ Pass FEN to parsePVMoves for proper SAN parsing
        const moves = parsePVMoves(pv, fen);
        if (!moves.length) return null;

        // If it's our turn, take first move; otherwise take second
        const idx = (sideToMove === ourColor) ? 0 : 1;
        return moves[idx] || null;
    }

    // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
    // ADDITIONAL UTILITY FUNCTIONS
    // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê

    // Get all pieces on board from FEN
    function getPiecesFromFen(fen) {
        const pieces = [];
        const placement = fen.split(' ')[0];
        const ranks = placement.split('/');

        for (let rankIdx = 0; rankIdx < 8; rankIdx++) {
            let fileIdx = 0;
            for (const ch of ranks[rankIdx]) {
                if (/\d/.test(ch)) {
                    fileIdx += parseInt(ch, 10);
                } else {
                    const square = 'abcdefgh'[fileIdx] + (8 - rankIdx);
                    pieces.push({
                        square,
                        piece: ch,
                        color: ch === ch.toUpperCase() ? 'w' : 'b',
                        type: ch.toLowerCase()
                    });
                    fileIdx++;
                }
            }
        }

        return pieces;
    }

    // Find king position from FEN
    function findKingSquare(fen, color) {
        const kingChar = color === 'w' ? 'K' : 'k';
        const pieces = getPiecesFromFen(fen);
        const king = pieces.find(p => p.piece === kingChar);
        return king ? king.square : null;
    }

    // Check if a square is valid
    function isValidSquare(square) {
        if (!square || square.length !== 2) return false;
        const file = square[0];
        const rank = square[1];
        return 'abcdefgh'.includes(file) && '12345678'.includes(rank);
    }

    // Get distance between two squares
    function squareDistance(sq1, sq2) {
        if (!isValidSquare(sq1) || !isValidSquare(sq2)) return Infinity;

        const f1 = 'abcdefgh'.indexOf(sq1[0]);
        const r1 = parseInt(sq1[1], 10);
        const f2 = 'abcdefgh'.indexOf(sq2[0]);
        const r2 = parseInt(sq2[1], 10);

        return Math.max(Math.abs(f2 - f1), Math.abs(r2 - r1)); // Chebyshev distance
    }

    // Check if move is capture
    function isCaptureMove(fen, from, to) {
        const targetPiece = fenCharAtSquare(fen, to);
        const movingPiece = pieceFromFenChar(fenCharAtSquare(fen, from));

        if (targetPiece) return true;

        // Check en passant
        if (movingPiece && movingPiece.type === 'p') {
            const ep = fen.split(' ')[3];
            if (ep !== '-' && to === ep) return true;
        }

        return false;
    }

    // Check if move is check (requires making the move first)
    function isCheckMove(fen, uciMove) {
        const newFen = makeSimpleMove(fen, uciMove);
        if (newFen === fen) return false;

        const enemyColor = fen.split(' ')[1] === 'w' ? 'b' : 'w';
        return ChessEngine.isInCheck(newFen);
    }

    // Parse move for display
    function parseMoveInfo(fen, uciMove) {
        const from = uciMove.substring(0, 2);
        const to = uciMove.substring(2, 4);
        const promotion = uciMove[4] || null;

        const movingPiece = pieceFromFenChar(fenCharAtSquare(fen, from));
        const capturedPiece = pieceFromFenChar(fenCharAtSquare(fen, to));

        const isCapture = isCaptureMove(fen, from, to);
        const isEP = isEnPassantCapture(fen, from, to, movingPiece?.color);
        const isCastling = movingPiece?.type === 'k' && Math.abs('abcdefgh'.indexOf(to[0]) - 'abcdefgh'.indexOf(from[0])) === 2;
        const isPromo = !!promotion;

        return {
            from,
            to,
            piece: movingPiece,
            captured: capturedPiece,
            isCapture,
            isEnPassant: isEP,
            isCastling,
            isPromotion: isPromo,
            promotionPiece: promotion
        };
    }

    // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
    // PREMOVE SAFETY SYSTEM - COMPLETE FIXED VERSION
    // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê

    const PIECE_VALUES = { p: 1, n: 3, b: 3, r: 5, q: 9, k: 100 };

    function getPieceValue(pieceType) {
        if (!pieceType) return 0;
        return PIECE_VALUES[pieceType.toLowerCase()] || 0;
    }

    // ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
    // GET ATTACKERS OF SQUARE
    // ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ

    function getAttackersOfSquare(fen, targetSquare, attackerColor) {
        const attackers = [];

        if (!fen || !targetSquare || targetSquare.length !== 2) {
            return attackers;
        }

        const tFile = 'abcdefgh'.indexOf(targetSquare[0]);
        const tRank = parseInt(targetSquare[1], 10);

        if (tFile < 0 || tRank < 1 || tRank > 8) return attackers;

        const checkSquare = (file, rank, pieceTypes) => {
            if (file < 0 || file > 7 || rank < 1 || rank > 8) return;
            const sq = 'abcdefgh'[file] + rank;
            const ch = fenCharAtSquare(fen, sq);
            const piece = pieceFromFenChar(ch);
            if (piece && piece.color === attackerColor && pieceTypes.includes(piece.type)) {
                attackers.push({
                    square: sq,
                    piece: piece.type,
                    value: PIECE_VALUES[piece.type]
                });
            }
        };

        // Pawn attacks
        const pawnDir = attackerColor === 'w' ? 1 : -1;
        checkSquare(tFile - 1, tRank - pawnDir, ['p']);
        checkSquare(tFile + 1, tRank - pawnDir, ['p']);

        // Knight attacks
        const knightMoves = [
            [2, 1], [2, -1], [-2, 1], [-2, -1],
            [1, 2], [1, -2], [-1, 2], [-1, -2]
        ];
        knightMoves.forEach(([df, dr]) => checkSquare(tFile + df, tRank + dr, ['n']));

        // King attacks
        for (let df = -1; df <= 1; df++) {
            for (let dr = -1; dr <= 1; dr++) {
                if (df === 0 && dr === 0) continue;
                checkSquare(tFile + df, tRank + dr, ['k']);
            }
        }

        // Sliding pieces
        const directions = [
            { dx: 1, dy: 0, pieces: ['r', 'q'] },
            { dx: -1, dy: 0, pieces: ['r', 'q'] },
            { dx: 0, dy: 1, pieces: ['r', 'q'] },
            { dx: 0, dy: -1, pieces: ['r', 'q'] },
            { dx: 1, dy: 1, pieces: ['b', 'q'] },
            { dx: 1, dy: -1, pieces: ['b', 'q'] },
            { dx: -1, dy: 1, pieces: ['b', 'q'] },
            { dx: -1, dy: -1, pieces: ['b', 'q'] }
        ];

        for (const { dx, dy, pieces } of directions) {
            let f = tFile + dx;
            let r = tRank + dy;
            while (f >= 0 && f <= 7 && r >= 1 && r <= 8) {
                const sq = 'abcdefgh'[f] + r;
                const ch = fenCharAtSquare(fen, sq);
                if (ch) {
                    const piece = pieceFromFenChar(ch);
                    if (piece && piece.color === attackerColor && pieces.includes(piece.type)) {
                        attackers.push({
                            square: sq,
                            piece: piece.type,
                            value: PIECE_VALUES[piece.type]
                        });
                    }
                    break;
                }
                f += dx;
                r += dy;
            }
        }

        // Sort by value (lowest first for SEE)
        attackers.sort((a, b) => a.value - b.value);
        return attackers;
    }

    function isSquareAttackedBy(fen, square, attackerColor) {
        return getAttackersOfSquare(fen, square, attackerColor).length > 0;
    }

    // ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
    // FIND KING
    // ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ

    function findKing(fen, color) {
        if (!fen || !color) return null;

        const placement = fen.split(' ')[0];
        const ranks = placement.split('/');
        const kingChar = color === 'w' ? 'K' : 'k';

        for (let rankIdx = 0; rankIdx < 8; rankIdx++) {
            const rank = 8 - rankIdx;
            let file = 0;
            for (const ch of ranks[rankIdx]) {
                if (/\d/.test(ch)) {
                    file += parseInt(ch, 10);
                } else {
                    if (ch === kingChar) {
                        return 'abcdefgh'[file] + rank;
                    }
                    file++;
                }
            }
        }
        return null;
    }

    // ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
    // STATIC EXCHANGE EVALUATION (SEE)
    // ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ

    function staticExchangeEvaluation(fen, targetSquare, attackerColor, capturedPieceValue = 0) {
        const attackers = getAttackersOfSquare(fen, targetSquare, attackerColor);
        const defenderColor = attackerColor === 'w' ? 'b' : 'w';
        const defenders = getAttackersOfSquare(fen, targetSquare, defenderColor);

        if (attackers.length === 0) return -capturedPieceValue;

        let gain = capturedPieceValue;
        let pieceOnSquare = attackers[0].value;
        let attackerIdx = 0;
        let defenderIdx = 0;
        let isAttackerTurn = false;

        while (true) {
            if (isAttackerTurn) {
                if (attackerIdx >= attackers.length) break;
                gain -= pieceOnSquare;
                pieceOnSquare = attackers[attackerIdx].value;
                attackerIdx++;
            } else {
                if (defenderIdx >= defenders.length) break;
                gain += pieceOnSquare;
                pieceOnSquare = defenders[defenderIdx].value;
                defenderIdx++;
            }
            isAttackerTurn = !isAttackerTurn;
        }

        return gain;
    }

    // ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
    // CHECK PREMOVE SAFETY
    // ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ

    function checkPremoveSafety(fen, uci, ourColor) {
        // Validation
        if (!fen || !uci || uci.length < 4) {
            return { safe: false, reason: 'Invalid move', riskLevel: 100 };
        }

        const from = uci.substring(0, 2);
        const to = uci.substring(2, 4);
        const promotion = uci[4] || null;
        const oppColor = ourColor === 'w' ? 'b' : 'w';

        // Get moving piece
        const movingCh = fenCharAtSquare(fen, from);
        const movingPiece = pieceFromFenChar(movingCh);

        if (!movingPiece || movingPiece.color !== ourColor) {
            return { safe: false, reason: 'Not our piece', riskLevel: 100 };
        }

        // Get captured piece
        const destCh = fenCharAtSquare(fen, to);
        const destPiece = pieceFromFenChar(destCh);
        const isEP = isEnPassantCapture(fen, from, to, ourColor);

        const movingPieceValue = getPieceValue(movingPiece.type);
        const capturedValue = destPiece ? getPieceValue(destPiece.type) : (isEP ? 1 : 0);

        // Simulate the move
        const newFen = makeSimpleMove(fen, uci);
        if (!newFen || newFen === fen) {
            return { safe: false, reason: 'Invalid move simulation', riskLevel: 100 };
        }

        let riskLevel = 0;
        const reasons = [];

        // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
        // CHECK 1: King Safety (Critical)
        // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê

        if (movingPiece.type === 'k') {
            if (isSquareAttackedBy(newFen, to, oppColor)) {
                return { safe: false, reason: 'King moves into check', riskLevel: 100 };
            }

            // Castling checks
            const fileDiff = 'abcdefgh'.indexOf(to[0]) - 'abcdefgh'.indexOf(from[0]);
            if (Math.abs(fileDiff) === 2) {
                const passingFile = 'abcdefgh'.indexOf(from[0]) + (fileDiff > 0 ? 1 : -1);
                const passingSquare = 'abcdefgh'[passingFile] + from[1];

                if (isSquareAttackedBy(fen, from, oppColor)) {
                    return { safe: false, reason: 'Cannot castle out of check', riskLevel: 100 };
                }
                if (isSquareAttackedBy(fen, passingSquare, oppColor)) {
                    return { safe: false, reason: 'Cannot castle through check', riskLevel: 100 };
                }
            }
        } else {
            const kingPos = findKing(newFen, ourColor);
            if (kingPos && isSquareAttackedBy(newFen, kingPos, oppColor)) {
                return { safe: false, reason: 'Exposes king to check', riskLevel: 100 };
            }
        }

        // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
        // CHECK 2: Material Exchange Analysis
        // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê

        const attackersAfter = getAttackersOfSquare(newFen, to, oppColor);
        const defendersAfter = getAttackersOfSquare(newFen, to, ourColor);
        const isHanging = attackersAfter.length > 0 && defendersAfter.length === 0;
        const isUnderAttack = attackersAfter.length > 0;

        // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
        // CHECK 3: Queen Safety
        // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê

        if (movingPiece.type === 'q') {
            if (isHanging) {
                return { safe: false, reason: 'Hangs queen', riskLevel: 95 };
            }

            if (isUnderAttack) {
                const lowestAttacker = attackersAfter[0];
                if (lowestAttacker && lowestAttacker.value < PIECE_VALUES.q) {
                    const netGain = capturedValue - PIECE_VALUES.q;
                    if (netGain < -5 && defendersAfter.length <= attackersAfter.length) {
                        reasons.push('Queen exposed to loss');
                        riskLevel += 70;
                    }
                }
            }
        }

        // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
        // CHECK 4: Rook Safety
        // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê

        if (movingPiece.type === 'r') {
            if (isHanging && capturedValue < PIECE_VALUES.r) {
                return { safe: false, reason: 'Hangs rook', riskLevel: 80 };
            }

            if (isUnderAttack && capturedValue < PIECE_VALUES.r) {
                const lowestAttacker = attackersAfter[0];
                if (lowestAttacker && lowestAttacker.value < PIECE_VALUES.r) {
                    if (defendersAfter.length <= attackersAfter.length) {
                        reasons.push('Rook exposed');
                        riskLevel += 50;
                    }
                }
            }
        }

        // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
        // CHECK 5: Minor Piece Safety
        // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê

        if (movingPiece.type === 'n' || movingPiece.type === 'b') {
            if (isHanging && capturedValue < PIECE_VALUES.n) {
                reasons.push('Minor piece hangs');
                riskLevel += 40;
            }
        }

        // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
        // CHECK 6: Pawn & Promotion Safety
        // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê

        if (movingPiece.type === 'p') {
            if (isHanging && capturedValue === 0) {
                reasons.push('Pawn undefended');
                riskLevel += 10;
            }

            if (promotion && isHanging) {
                reasons.push('Promoted piece hangs');
                riskLevel += 60;
            }
        }

        // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
        // CHECK 7: SEE
        // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê

        if (isUnderAttack && !isHanging) {
            const seeValue = staticExchangeEvaluation(newFen, to, oppColor, movingPieceValue);
            if (seeValue < -3) {
                reasons.push('Negative exchange');
                riskLevel += Math.min(50, Math.abs(seeValue) * 10);
            }
        }

        // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
        // RESULT
        // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê

        const safe = riskLevel < 50;
        const reason = reasons.length > 0 ? reasons.join(', ') : (safe ? 'Safe move' : 'Risky');

        return {
            safe,
            reason,
            riskLevel,
            details: {
                movingPiece: movingPiece.type,
                capturedPiece: destPiece?.type || (isEP ? 'p' : null),
                attackers: attackersAfter.length,
                defenders: defendersAfter.length,
                isHanging,
                isCapture: capturedValue > 0
            }
        };
    }

    // ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
    // SHOULD PREMOVE - FIXED
    // ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ

    function shouldPremove(uci, fen, game = null) {
        // Basic validation
        if (!BotState.premoveEnabled) return false;
        if (!uci || typeof uci !== 'string' || uci.length < 4) return false;
        if (!fen || typeof fen !== 'string') return false;

        game = game || getGame();
        if (!game) return false;

        const ourColor = getPlayerColor(game);
        if (!ourColor) return false;

        // Check if it's opponent's turn (premove only makes sense then)
        const sideToMove = fen.split(' ')[1];
        if (sideToMove === ourColor) return false; // Our turn - make normal move

        const from = uci.substring(0, 2);
        const to = uci.substring(2, 4);

        const fromCh = fenCharAtSquare(fen, from);
        const toCh = fenCharAtSquare(fen, to);
        const fromPiece = pieceFromFenChar(fromCh);
        const toPiece = pieceFromFenChar(toCh);

        // Must be our piece
        if (!fromPiece || fromPiece.color !== ourColor) return false;

        // Cannot capture own piece
        if (toPiece && toPiece.color === ourColor) return false;

        // Safety check
        const safetyCheck = checkPremoveSafety(fen, uci, ourColor);

        // Block critical risk regardless of mode
        if (safetyCheck.riskLevel >= 90) {
            console.log(`GabiBot: Premove BLOCKED (critical) - ${safetyCheck.reason}`);
            return false;
        }

        // Block high risk unless 'every' mode
        if (safetyCheck.riskLevel >= 70 && BotState.premoveMode !== 'every') {
            console.log(`GabiBot: Premove blocked (high risk) - ${safetyCheck.reason}`);
            return false;
        }

        // Mode-based filtering (‚úÖ Fixed: added block scope with {})
        switch (BotState.premoveMode) {
            case 'off':
            case 'disabled': {
                return false;
            }

            case 'every': {
                return true;
            }

            case 'capture': {
                const isCapture = (toPiece && toPiece.color !== ourColor) ||
                      isEnPassantCapture(fen, from, to, ourColor);
                return isCapture;
            }

            case 'filter': {
                return !!BotState.premovePieces?.[fromPiece.type];
            }

            case 'safe': {
                return safetyCheck.safe;
            }

            case 'winning': {
                const evalChance = getEvalBasedPremoveChance(BotState.lastEval, ourColor);
                return evalChance >= 50 && safetyCheck.safe;
            }

            default: {
                return false;
            }
        }
    }

    // ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
    // EVAL-BASED PREMOVE CHANCE
    // ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ

    function getEvalBasedPremoveChance(evaluation, ourColor) {
        if (!BotState.premoveEnabled) return 0;

        const game = getGame();
        if (!game || isPlayersTurn(game)) return 0;

        let evalScore = 0;
        let isMate = false;
        let mateFor = null;

        // Parse evaluation
        if (typeof evaluation === 'string') {
            if (!evaluation || evaluation === '-' || evaluation === 'Error') return 0;

            const mateMatch = evaluation.match(/([+-])?M([+-]?\d+)/i);
            if (mateMatch) {
                isMate = true;
                const sign = mateMatch[1] === '-' ? -1 : 1;
                const mateNum = parseInt(mateMatch[2], 10);
                const absoluteMateValue = sign * Math.abs(mateNum);

                mateFor = ourColor === 'w'
                    ? (absoluteMateValue > 0 ? 'us' : 'them')
                : (absoluteMateValue < 0 ? 'us' : 'them');
            } else {
                evalScore = parseFloat(evaluation);
            }
        } else if (typeof evaluation === 'number') {
            evalScore = evaluation;
        } else if (evaluation && typeof evaluation === 'object') {
            if ('mate' in evaluation && evaluation.mate !== 0) {
                isMate = true;
                const mateNum = evaluation.mate;
                mateFor = ourColor === 'w'
                    ? (mateNum > 0 ? 'us' : 'them')
                : (mateNum < 0 ? 'us' : 'them');
            } else if ('cp' in evaluation) {
                evalScore = evaluation.cp / 100;
            }
        }

        if (isNaN(evalScore) && !isMate) return 0;

        if (isMate) {
            return mateFor === 'us' ? 95 : 10;
        }

        const ourEval = ourColor === 'w' ? evalScore : -evalScore;

        if (ourEval >= 5.0) return 95;
        if (ourEval >= 3.0) return 85;
        if (ourEval >= 2.0) return 70;
        if (ourEval >= 1.0) return 50;
        if (ourEval >= 0.5) return 35;
        if (ourEval >= 0) return 25;
        if (ourEval >= -0.5) return 20;
        if (ourEval >= -1.0) return 15;
        return 10;
    }

    // ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
    // GET PREMOVE FOR PREDICTED POSITION
    // ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ

    function getPremoveForPredictedPosition(currentFen, pv, ourColor) {
        if (!pv || !currentFen) return null;

        const moves = parsePVMoves(pv, currentFen);
        if (moves.length < 2) return null;

        const sideToMove = currentFen.split(' ')[1];

        if (sideToMove !== ourColor) {
            const opponentMove = moves[0];
            const ourMove = moves[1];

            if (!opponentMove || !ourMove) return null;

            const fenAfterOpponent = makeSimpleMove(currentFen, opponentMove);
            if (!fenAfterOpponent) return null;

            const safety = checkPremoveSafety(fenAfterOpponent, ourMove, ourColor);

            if (safety.safe) {
                return {
                    premove: ourMove,
                    predictedOpponentMove: opponentMove,
                    fenAfterOpponent,
                    confidence: 100 - safety.riskLevel
                };
            }
        } else {
            return {
                premove: moves[0],
                predictedOpponentMove: null,
                fenAfterOpponent: null,
                confidence: 100
            };
        }

        return null;
    }

    // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
    // EXECUTE ACTION - IMPROVED
    // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê

    async function executeAction(selectedUci, analysisFen) {
        try {
            // Clear only best move arrow, preserve PV arrows
            clearBestMoveArrow();

            if (!selectedUci || selectedUci.length < 4) {
                console.log('GabiBot: No valid move to execute');
                return;
            }

            const from = selectedUci.substring(0, 2);
            const to = selectedUci.substring(2, 4);
            const promotionChar = selectedUci.length >= 5 ? selectedUci[4] : null;

            // Draw best move arrow
            drawArrow(from, to, 'rgba(100, 255, 100, 0.7)', 4);

            // Check if auto-move is enabled
            if (!BotState.hackEnabled || !BotState.autoMove) {
                BotState.statusInfo = 'Ready (manual mode)';
                updateDisplay();
                return;
            }

            const game = getGame();
            if (!game) {
                BotState.statusInfo = 'No game found';
                updateDisplay();
                return;
            }

            if (!isPlayersTurn(game)) {
                BotState.statusInfo = 'Waiting for opponent...';
                updateDisplay();
                return;
            }

            // Cancel any pending move
            cancelPendingMove();

            // Calculate delay
            const baseDelay = Math.max(0, AUTO_MOVE_BASE - BotState.autoMoveSpeed * AUTO_MOVE_STEP);
            const totalDelay = getCalculatedDelay(baseDelay, BotState.randomDelay);

            console.log(`GabiBot: Move ${selectedUci} scheduled in ${totalDelay}ms`);
            BotState.statusInfo = `Moving in ${(totalDelay / 1000).toFixed(1)}s`;
            updateDisplay();

            // Schedule the move
            pendingMoveTimeoutId = setTimeout(async () => {
                try {
                    const g = getGame();
                    if (!g) {
                        BotState.statusInfo = 'Game ended';
                        updateDisplay();
                        return;
                    }

                    if (!isPlayersTurn(g)) {
                        BotState.statusInfo = 'Move canceled (not our turn)';
                        updateDisplay();
                        return;
                    }

                    const currentFen = getFen(g);
                    if (currentFen !== analysisFen) {
                        BotState.statusInfo = 'Move canceled (position changed)';
                        updateDisplay();
                        // Trigger re-analysis
                        lastFenProcessedMain = '';
                        tick();
                        return;
                    }

                    BotState.statusInfo = 'Making move...';
                    updateDisplay();

                    const success = await makeMove(from, to, analysisFen, promotionChar);

                    if (success) {
                        BotState.statusInfo = '‚úì Move made!';
                        console.log(`GabiBot: ‚úì Move ${selectedUci} executed successfully`);
                    } else {
                        BotState.statusInfo = '‚ùå Move failed';
                        console.error(`GabiBot: ‚úó Move ${selectedUci} failed`);

                        // Retry after delay
                        setTimeout(() => {
                            if (BotState.hackEnabled && isPlayersTurn(getGame())) {
                                lastFenProcessedMain = '';
                                tick();
                            }
                        }, 800);
                    }

                    updateDisplay();
                } catch (error) {
                    console.error('GabiBot: Error executing move:', error);
                    BotState.statusInfo = '‚ùå Move error';
                    updateDisplay();
                }
            }, totalDelay);

        } catch (error) {
            console.error('GabiBot: Error in executeAction:', error);
            BotState.statusInfo = '‚ùå Error';
            updateDisplay();
        }
    }

    // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
    // SCHEDULE ANALYSIS - IMPROVED
    // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê

    function scheduleAnalysis(kind, fen) {
        const analysisId = ++currentAnalysisId;

        analysisQueue = analysisQueue.then(async () => {
            // Check if this analysis is still valid
            if (analysisId !== currentAnalysisId) {
                // console.log('GabiBot: Analysis superseded');
                return;
            }

            if (!BotState.hackEnabled) return;

            const game = getGame();
            if (!game) return;

            // Check if we've already processed this FEN
            if (kind === 'main') {
                if (lastFenProcessedMain === fen) return;
            } else {
                if (lastFenProcessedPremove === fen) return;
            }

            const ctrl = new AbortController();

            try {
                BotState.statusInfo = kind === 'main' ? 'üîÑ Analyzing...' : 'üîÑ Analyzing (premove)...';
                updateDisplay();

                const randomDepth = getRandomDepth();

                // Double-check if still valid
                if (analysisId !== currentAnalysisId) {
                    ctrl.abort('superseded');
                    return;
                }

                const data = await fetchEngineDataWithRetry(fen, randomDepth, ctrl.signal);

                // Check again after async operation
                if (analysisId !== currentAnalysisId) {
                    console.log('GabiBot: Analysis result discarded (superseded)');
                    return;
                }

                const best = parseBestLine(data);

                if (kind === 'main') {
                    await handleMainAnalysis(best, fen, game);
                    lastFenProcessedMain = fen;
                } else {
                    await handlePremoveAnalysis(best, fen, game);
                    lastFenProcessedPremove = fen;
                }

            } catch (error) {
                handleAnalysisError(error);
            }
        });
    }

    // ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
    // HANDLE MAIN ANALYSIS RESULT
    // ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ

    async function handleMainAnalysis(best, fen, game) {
        BotState.bestMove = best?.uci || '-';
        BotState.currentEvaluation = scoreToDisplay(best?.score);
        BotState.principalVariation = best?.pv || 'Not available';
        BotState.statusInfo = '‚úì Ready';
        BotState.currentFen = fen;
        BotState.lastEval = best?.score; // Store for premove chance calculation

        // Parse PV moves
        const pvString = best?.pv || best?.uci || '';
        const pvMoves = parsePVMoves(pvString, fen);
        lastPVData = pvMoves;

        //console.log('GabiBot Pro: üìã PV Moves:', pvMoves);

        updateDisplay();
        updateUIDisplay();

        // Draw PV arrows first (will be under best move arrow)
        if (BotState.showPVArrows && pvMoves.length > 0) {
            //console.log('GabiBot Pro: üé® Drawing PV arrows...');
            drawPVArrows(pvMoves);
        }

        // Then execute action (draws best move arrow on top)
        if (best) {
            await executeAction(best.uci, fen);
        }
    }

    // ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
    // HANDLE PREMOVE ANALYSIS RESULT
    // ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ

    async function handlePremoveAnalysis(best, fen, game) {
        const ourColor = getPlayerColor(game);
        const stm = getSideToMove(game);

        // Tentukan UCI move
        let ourUci = getOurMoveFromPV(best?.pv || '', ourColor, stm, fen);
        if (!ourUci && stm === ourColor) {
            ourUci = best?.uci || null;
        }

        // Skor untuk display & numeric
        const scoreDisplay = scoreToDisplay(best?.score);
        const scoreValue = scoreNumeric(best?.score);

        // Parse PV & arrows
        const pvMoves = parsePVMoves(best?.pv || '', fen);
        lastPVData = pvMoves;
        clearBestMoveArrow();
        if (BotState.showPVArrows && pvMoves.length > 0) {
            drawPVArrows(pvMoves);
        }

        // Validasi premove
        if (!ourUci) {
            BotState.statusInfo = 'Premove unavailable (no PV)';
            updateDisplay();
            return;
        }
        if (!shouldPremove(ourUci, fen, game)) {
            BotState.statusInfo = `Premove skipped (${BotState.premoveMode})`;
            updateDisplay();
            return;
        }

        const safetyCheck = checkPremoveSafety(fen, ourUci, ourColor);
        if (!safetyCheck.safe) {
            BotState.statusInfo = `üõ°Ô∏è Premove blocked: ${safetyCheck.reason}`;
            updateDisplay();
            return;
        }

        // Hitung chance
        let currentChance = getEvalBasedPremoveChance(scoreValue, ourColor);
        if (safetyCheck.riskLevel > 0) {
            const riskPenalty = safetyCheck.riskLevel * 0.5;
            currentChance = Math.max(5, currentChance - riskPenalty);
        }

        // Roll probabilistik
        const roll = Math.random() * 100;
        if (roll > currentChance) {
            BotState.statusInfo = `Premove skipped: ${roll.toFixed(0)}% > ${currentChance.toFixed(0)}%`;
            updateDisplay();
            return;
        }

        // Eksekusi premove
        const from = ourUci.substring(0, 2);
        const to = ourUci.substring(2, 4);

        drawArrow(from, to, 'rgba(80, 180, 255, 0.7)', 3);
        await simulateClickMove(from, to);
        await sleep(80);

        lastPremoveFen = fen;
        lastPremoveUci = ourUci;

        BotState.statusInfo = `‚úÖ Premove: ${ourUci} (${scoreDisplay})`;
        updateDisplay();

        console.log(`GabiBot: Premove ${ourUci} executed (chance: ${currentChance.toFixed(0)}%)`);
    }


    // ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
    // HANDLE ANALYSIS ERROR
    // ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ

    function handleAnalysisError(error) {
        const errorName = String(error?.name || error).toLowerCase();

        if (errorName.includes('abort')) {
            BotState.statusInfo = '‚è∏ Analysis canceled';
        } else {
            console.error('GabiBot API Error:', error);
            BotState.statusInfo = '‚ùå API Error';
            BotState.currentEvaluation = 'Error';
        }

        updateDisplay();
    }

    // ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
    // TICK FUNCTION - IMPROVED
    // ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ

    async function tick() {
        // Prevent concurrent execution
        if (isTickRunning) {
            //    console.log('GabiBot: Tick already running, skipping');
            return;
        }

        if (!BotState.hackEnabled) {
            return;
        }

        isTickRunning = true;

        try {
            const game = getGame();
            if (!game) {
                BotState.statusInfo = 'No game found';
                updateDisplay();
                return;
            }

            // Check game over
            if (typeof game.isGameOver === 'function' && game.isGameOver()) {
                handleGameOver();
                return;
            }

            const fen = getFen(game);
            if (!fen || typeof fen !== 'string') {
                BotState.statusInfo = 'Invalid position';
                updateDisplay();
                return;
            }

            // Position changed - reset state
            if (fen !== lastFenSeen) {
                handlePositionChange(fen);
            }

            // Main analysis or premove based on turn
            if (isPlayersTurn(game)) {
                await handleOurTurn(fen);
            } else {
                await handleOpponentTurn(game, fen);
            }

        } catch (error) {
            console.error('GabiBot: Error in tick:', error);
            BotState.statusInfo = '‚ùå Tick error';
            updateDisplay();
        } finally {
            isTickRunning = false;
        }
    }

    // ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
    // TICK HELPER FUNCTIONS
    // ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
    function handleGameOver() {
        BotState.currentEvaluation = 'GAME OVER';
        BotState.bestMove = '-';
        BotState.principalVariation = 'Game ended';
        BotState.statusInfo = 'Game finished';

        clearArrows();
        cancelPendingMove();

        updateDisplay();

        //   console.log('GabiBot: Game over detected in tick');
    }

    function handlePositionChange(fen) {
        //    console.log('GabiBot Pro: Position changed, resetting state');

        lastFenSeen = fen;
        cancelPendingMove();
        clearArrows();

        // Reset tracking variables
        lastPremoveFen = '';
        lastPremoveUci = '';
        lastPVData = [];

        // Reset processed FEN to force re-analysis
        // (but keep lastFenProcessedMain/Premove to avoid duplicate analysis)
    }

    async function handleOurTurn(fen) {
        if (lastFenProcessedMain !== fen) {
            scheduleAnalysis('main', fen);
        }
    }

    async function handleOpponentTurn(game, fen) {
        if (BotState.premoveEnabled) {
            if (lastFenProcessedPremove !== fen) {
                scheduleAnalysis('premove', fen);
            } else {
                // Update premove chance display
                updatePremoveChanceDisplay(game);

                // Update status
                if (lastPremoveUci && lastPremoveFen === fen) {
                    BotState.statusInfo = 'Waiting (premove ready)...';
                } else {
                    BotState.statusInfo = 'Waiting for opponent...';
                }
                updateDisplay();
            }
        } else {
            // Premove disabled
            const chanceEl = qs('[name="premoveChance"] .itemState');
            if (chanceEl) chanceEl.textContent = '0%';

            BotState.statusInfo = 'Waiting for opponent...';
            updateDisplay();
        }
    }

    function updatePremoveChanceDisplay(game) {
        const chanceEl = qs('[name="premoveChance"] .itemState');
        if (!chanceEl) return;

        if (BotState.currentEvaluation && BotState.currentEvaluation !== '-') {
            const ourColor = getPlayerColor(game);
            const currentChance = getEvalBasedPremoveChance(BotState.currentEvaluation, ourColor);
            chanceEl.textContent = `${Math.round(currentChance)}%`;
        } else {
            chanceEl.textContent = '-%';
        }
    }

    // ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
    // TICK LOOP CONTROL
    // ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ

    function startTickLoop() {
        stopTickLoop();

        const speed = Number(BotState.updateSpeed) || 8;
        const interval = Math.max(150, 1100 - speed * 100);

        //   console.log(`GabiBot: Starting tick loop (interval: ${interval}ms)`);

        // Use timeout for first tick to avoid double execution
        managedTimeout(() => {
            tick();
            tickTimer = setInterval(tick, interval);
        }, 100, 'initial-tick');
    }

    function stopTickLoop() {
        if (tickTimer) {
            clearInterval(tickTimer);
            tickTimer = null;
        }
        isTickRunning = false;
        //    console.log('GabiBot: Tick loop stopped');
    }

    const autoMatch = async function() {
        const delay = (ms) => new Promise(resolve => setTimeout(resolve, ms));

        // ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
        // GUARDS
        // ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
        if (autoMatchInProgress) {
            console.log("[AutoMatch] Already in progress, skipping...");
            return;
        }
        if (!BotState.autoMatchEnabled) {
            console.log("[AutoMatch] Not enabled");
            return;
        }
        if (autoStartTriggered) {
            console.log("[AutoMatch] Already triggered");
            return;
        }
        if (autoMatchAttempts >= MAX_AUTO_MATCH_ATTEMPTS) {
            console.log("[AutoMatch] Max attempts reached, resetting...");
            autoMatchAttempts = 0;
            return;
        }

        // ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
        // CHECK FOR GAME OVER MODAL
        // ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
        const gameOverModal = document.querySelector('.game-over-modal-container') ||
              document.querySelector('.game-over-modal-content') ||
              document.querySelector('[data-cy="game-over-modal"]');

        if (!gameOverModal) {
            console.log("[AutoMatch] No game over modal found");
            autoMatchAttempts = 0;
            return;
        }

        autoMatchInProgress = true;
        autoMatchAttempts++;
        console.log(`[AutoMatch] Attempt ${autoMatchAttempts}/${MAX_AUTO_MATCH_ATTEMPTS}`);

        try {
            // ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
            // STEP 1: DECLINE REMATCH (if needed)
            // ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
            const declineBtn = findDeclineButton();
            if (declineBtn) {
                console.log("[AutoMatch] Clicking decline button...");
                declineBtn.click();
                await delay(1500);
                autoMatchInProgress = false;
                return;
            }

            // ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
            // STEP 2: FIND NEW GAME BUTTON
            // ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
            const newGameBtn = findNewGameButton();

            if (!newGameBtn) {
                console.warn("[AutoMatch] No New Game button found!");
                debugLogButtons(); // Debug: log semua button yang ada
                autoMatchInProgress = false;
                return;
            }

            console.log("[AutoMatch] Found button:", newGameBtn.textContent?.trim());

            // ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
            // STEP 3: WAIT AND CLICK
            // ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
            const delayMs = getAutoMatchDelay();
            BotState.statusInfo = `New game in ${delayMs / 1000}s...`;
            updateDisplay();

            autoStartTriggered = true;
            await delay(delayMs);

            // Re-check if modal still exists
            const modalStillExists = document.querySelector('.game-over-modal-container') ||
                  document.querySelector('.game-over-modal-content');
            if (!modalStillExists) {
                console.log("[AutoMatch] Modal disappeared, game may have started");
                resetAutoMatchState();
                return;
            }

            // Re-find button (DOM might have changed)
            const buttonToClick = findNewGameButton();
            if (!buttonToClick) {
                console.warn("[AutoMatch] Button no longer available");
                resetAutoMatchState();
                return;
            }

            // ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
            // STEP 4: CLICK AND RESET
            // ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
            console.log("[AutoMatch] Clicking:", buttonToClick.textContent?.trim());
            buttonToClick.click();

            await delay(500);
            resetForNewGame();

        } catch (error) {
            console.error('[AutoMatch] Error:', error);
            BotState.statusInfo = 'AutoMatch error';
            updateDisplay();
        } finally {
            autoMatchInProgress = false;
            autoStartTriggered = false;
        }
    };

    // ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
    // HELPER: Find Decline Button
    // ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
    function findDeclineButton() {
        const declineSelectors = [
            '[aria-label="Decline Rematch"]',
            '[aria-label="Decline"]',
            '[data-cy="rematch-decline-button"]',
            'button.ui_v5-button-basic[aria-label*="ecline"]'
        ];

        for (const selector of declineSelectors) {
            const btn = document.querySelector(selector);
            if (btn && isElementVisible(btn)) return btn;
        }

        // Fallback: cari button dengan teks decline
        const allButtons = document.querySelectorAll('.game-over-modal-content button, .game-over-modal-container button');
        for (const btn of allButtons) {
            const text = (btn.textContent || '').toLowerCase().trim();
            const ariaLabel = (btn.getAttribute('aria-label') || '').toLowerCase();
            if (text.includes('decline') || text.includes('tolak') ||
                ariaLabel.includes('decline') || text === '‚úï' || text === 'x') {
                if (isElementVisible(btn)) return btn;
            }
        }

        return null;
    }

    // ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
    // HELPER: Find New Game Button - IMPROVED
    // ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
    function findNewGameButton() {
        // Priority 1: Specific selectors (Chess.com 2024)
        const prioritySelectors = [
            '[data-cy="new-game-button"]',
            '[data-cy="sidebar-game-over-new-game-button"]',
            '[data-cy="next-arena-game-button"]',
            '[data-cy="tournament-next-game-button"]',
            '.game-over-buttons-wrapper button.ui_v5-button-primary',
            '.game-over-buttons-component button.ui_v5-button-primary',
            '.game-over-modal-content button.ui_v5-button-primary'
        ];

        for (const selector of prioritySelectors) {
            const btn = document.querySelector(selector);
            if (btn && isElementVisible(btn) && !isExcludedButton(btn)) {
                return btn;
            }
        }

        // Priority 2: Find by text content
        const includePatterns = [
            /new\s*(game|opponent)/i,
            /play\s*again/i,
            /next\s*(game|round|opponent)/i,
            /main\s*lagi/i,
            /new\s*\d+\s*min/i,
            /new\s*\d+\+\d+/i,
            /rematch/i // Jika tidak ada tombol lain, rematch juga OK
        ];

        const excludePatterns = [
            /analysis/i,
            /review/i,
            /share/i,
            /download/i,
            /report/i
        ];

        const allButtons = document.querySelectorAll(`
        .game-over-modal-content button,
        .game-over-modal-container button,
        .game-over-buttons-component button,
        .game-over-buttons-wrapper button,
        [class*="game-over"] button
    `);

        let bestMatch = null;
        let rematchButton = null;

        for (const btn of allButtons) {
            if (!isElementVisible(btn)) continue;

            const text = (btn.textContent || '').replace(/\s+/g, ' ').trim().toLowerCase();
            const ariaLabel = (btn.getAttribute('aria-label') || '').toLowerCase();
            const fullText = text + ' ' + ariaLabel;

            // Skip excluded buttons
            if (excludePatterns.some(p => p.test(fullText))) continue;

            // Check for rematch (lower priority)
            if (/rematch/i.test(fullText)) {
                rematchButton = btn;
                continue;
            }

            // Check for new game patterns
            for (const pattern of includePatterns) {
                if (pattern.test(fullText)) {
                    bestMatch = btn;
                    break;
                }
            }

            if (bestMatch) break;
        }

        return bestMatch || rematchButton;
    }

    // ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
    // HELPER: Check if button should be excluded
    // ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
    function isExcludedButton(btn) {
        const text = (btn.textContent || '').toLowerCase();
        const ariaLabel = (btn.getAttribute('aria-label') || '').toLowerCase();
        const combined = text + ' ' + ariaLabel;

        const excludeWords = ['analysis', 'review', 'share', 'download', 'report', 'close'];
        return excludeWords.some(word => combined.includes(word));
    }

    // ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
    // HELPER: Check if element is visible
    // ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
    function isElementVisible(el) {
        if (!el) return false;

        const style = window.getComputedStyle(el);
        if (style.display === 'none') return false;
        if (style.visibility === 'hidden') return false;
        if (style.opacity === '0') return false;

        const rect = el.getBoundingClientRect();
        if (rect.width === 0 || rect.height === 0) return false;

        return true;
    }

    // ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
    // DEBUG: Log all buttons in modal
    // ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
    function debugLogButtons() {
        console.log("=== DEBUG: All buttons in game-over modal ===");

        const modal = document.querySelector('.game-over-modal-content') ||
              document.querySelector('.game-over-modal-container');

        if (!modal) {
            console.log("No modal found!");
            return;
        }

        const buttons = modal.querySelectorAll('button');
        console.log(`Found ${buttons.length} buttons:`);

        buttons.forEach((btn, i) => {
            console.log(`[${i}] Text: "${btn.textContent?.trim()}" | ` +
                        `Aria: "${btn.getAttribute('aria-label')}" | ` +
                        `Class: "${btn.className}" | ` +
                        `Visible: ${isElementVisible(btn)}`);
        });

        console.log("==============================================");
    }

    // ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
    // IMPROVED: Auto Watchers with better detection
    // ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
    function startAutoWatchers() {
        stopAutoWatchers();

        let gameEndDetected = false;
        let watcherErrorCount = 0;

        gameEndInterval = setInterval(() => {
            try {
                const gameOverModal = document.querySelector('.game-over-modal-content') ||
                      document.querySelector('.game-over-modal-container') ||
                      document.querySelector('[data-cy="game-over-modal"]');

                if (gameOverModal && !gameEndDetected) {
                    console.log("[Watcher] Game over detected");
                    handleGameEndDetected();
                    gameEndDetected = true;

                    if (BotState.autoMatchEnabled) {
                        // Delay sebelum autoMatch untuk memberi waktu modal load
                        managedTimeout(() => {
                            if (BotState.autoMatchEnabled) {
                                autoMatch();
                            }
                        }, 2000, 'auto-match-trigger');
                    }
                }

                if (!gameOverModal && gameEndDetected) {
                    console.log("[Watcher] Modal closed, new game may have started");
                    handleNewGameStarted();
                    gameEndDetected = false;
                }

                watcherErrorCount = 0;

            } catch (error) {
                watcherErrorCount++;
                console.error('[Watcher] Error:', error);

                if (watcherErrorCount > 10) {
                    console.error('[Watcher] Too many errors, restarting...');
                    startAutoWatchers();
                }
            }
        }, 1000);

        console.log('[Watcher] Auto watchers started');
    }

    // ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
    // HELPER: Get delay based on context
    // ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
    function getAutoMatchDelay() {
        const isArena = document.querySelector('[data-cy="next-arena-game-button"]') ||
              document.querySelector('.game-over-arena-button-component');
        if (isArena) return 3000;
        if (typeof BotState.autoMatchDelay === 'number') {
            return Math.max(1000, Math.min(30000, BotState.autoMatchDelay));
        }
        return 5000;
    }

    // ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
    // HELPER: Reset state for new game
    // ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
    function resetForNewGame() {
        lastFenProcessedMain = '';
        lastFenProcessedPremove = '';
        lastFenSeen = '';
        lastPVData = [];
        lastPremoveFen = '';
        lastPremoveUci = '';

        BotState.bestMove = '-';
        BotState.currentEvaluation = '-';
        BotState.principalVariation = '-';
        BotState.statusInfo = 'Searching for game...';

        clearArrows();
        cancelPendingMove();
        updateDisplay();

        autoMatchInProgress = false;
        autoStartTriggered = false;
        autoMatchAttempts = 0;
    }

    function resetAutoMatchState() {
        autoMatchInProgress = false;
        autoStartTriggered = false;
        autoMatchAttempts = 0;
    }

    // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
    // BONUS: Smart Auto Match with Opponent Filter
    // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
    const smartAutoMatch = async function() {
        if (!BotState.autoMatchEnabled || autoMatchInProgress) return;
        const gameOverModal = document.querySelector('.game-over-modal-container');
        if (!gameOverModal) return;

        if (BotState.autoMatchRatingFilter) {
            const opponentRating = getOpponentRating();
            const minRating = BotState.autoMatchMinRating || 0;
            const maxRating = BotState.autoMatchMaxRating || 9999;
            if (opponentRating && (opponentRating < minRating || opponentRating > maxRating)) {
                BotState.autoMatchAllowRematch = false;
            }
        }
        await autoMatch();
    };

    // ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
    // HELPER: Get opponent rating from game over modal
    // ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
    function getOpponentRating() {
        try {
            const ratingSelectors = [
                '.game-over-modal-content .user-rating',
                '.game-over-header-component .rating',
                '[data-cy="opponent-rating"]'
            ];
            for (const selector of ratingSelectors) {
                const el = document.querySelector(selector);
                if (el) {
                    const text = el.textContent || '';
                    const match = text.match(/\d{3,4}/);
                    if (match) return parseInt(match[0], 10);
                }
            }
        } catch (error) {
            console.error('[AutoMatch] Error getting opponent rating:', error);
        }
        return null;
    }

    // ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
    // AUTO WATCHERS - IMPROVED
    // ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ

    function stopAutoWatchers() {
        if (gameEndInterval) {
            clearInterval(gameEndInterval);
            gameEndInterval = null;
        }
        if (gameStartInterval) {
            clearInterval(gameStartInterval);
            gameStartInterval = null;
        }

        clearAllManagedTimeouts();

        //  console.log('GabiBot: Auto watchers stopped');
    }

    function handleGameEndDetected() {
        console.log('GabiBot: Game over detected');

        clearArrows();
        cancelPendingMove();

        BotState.statusInfo = 'Game ended';
        BotState.currentEvaluation = '-';
        BotState.bestMove = '-';
        BotState.principalVariation = '-';

        // Reset tracking
        lastFenProcessedMain = '';
        lastFenProcessedPremove = '';
        lastFenSeen = '';
        lastPVData = [];

        updateDisplay();
        ui?.updateDisplay?.(pa());
    }

    function handleNewGameStarted() {
        //  console.log('GabiBot: New game started');

        if (BotState.hackEnabled) {
            BotState.statusInfo = 'Ready';
            updateDisplay();
            ui?.updateDisplay?.(pa());

            // Delay tick to allow game to initialize
            managedTimeout(() => {
                if (BotState.hackEnabled) {
                    lastFenProcessedMain = '';
                    lastFenProcessedPremove = '';
                    tick();
                }
            }, 500, 'new-game-tick');
        }
    }

    // ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
    // AUTO REMATCH LOGIC
    // ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ

    function scheduleAutoRematch() {
        BotState.statusInfo = 'Looking for rematch...';
        updateDisplay();

        // Step 1: Try Rematch button (2s)
        managedTimeout(() => {
            if (!BotState.gameActive) tryClickRematchButton();
        }, 2000, 'rematch-step1');

        // Step 2: Try "New X min" button (12s)
        managedTimeout(() => {
            if (!BotState.gameActive) tryClickNewGameButton();
        }, 12000, 'rematch-step2');

        // Step 3: Fallback to New Game tab (22s)
        managedTimeout(async () => {
            if (!BotState.gameActive) await tryNewGameTabFallback();
        }, 22000, 'rematch-step3');
    }

    function tryClickRematchButton() {
        const modal = qs('.game-over-modal-content');
        if (!modal) return;

        const btn = qsa('button', modal).find(b =>
                                              /rematch/i.test((b.textContent || '').trim()) ||
                                              /rematch/i.test((b.getAttribute?.('aria-label') || '').trim()) ||
                                              /rematch/i.test((b.getAttribute?.('title') || '').trim())
                                             );

        if (btn) {
            btn.click();
        }
    }

    function tryClickNewGameButton() {
        const modal = qs('.game-over-modal-content');
        if (!modal) return;

        const btn = qsa('button', modal).find(b => {
            const text = (b.textContent || '').replace(/\s+/g, ' ').trim();
            return /new.*\d+.*min/i.test(text);
        });

        if (btn) {
            btn.click();
        }
    }

    async function tryNewGameTabFallback() {
        const modal = qs('.game-over-modal-content');
        if (!modal) return;

        try {
            const closeBtn = qs('[aria-label="Close"]', modal);
            if (closeBtn) {
                closeBtn.click();
                await sleep(500);
            }

            const tab = qs('[data-tab="newGame"]') ||
                  qsa('.tabs-tab').find(t => /new.*game/i.test(t.textContent || ''));

            if (tab) {
                tab.click();
                await sleep(400);

                const startBtn = qsa('button').find(b =>
                                                    /start.*game/i.test((b.textContent || '').trim()) ||
                                                    /play.*game/i.test((b.textContent || '').trim())
                                                   );

                if (startBtn) {
                    startBtn.click();
                }
            }
        } catch (error) {
            console.error('Error in New Game tab fallback:', error);
        }
    }

    // ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
    // AUTO MATCH FUNCTION
    // ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ

    function startAutoMatchInterval() {
        if (autoMatchInterval) {
            clearInterval(autoMatchInterval);
        }

        autoMatchInterval = setInterval(() => {
            if (BotState.hackEnabled && BotState.autoMatchEnabled) {
                try {
                    if (!BotState.autoMatchCooldown) {
                        autoMatch();
                        BotState.autoMatchCooldown = true;
                        setTimeout(() => {
                            BotState.autoMatchCooldown = false;
                        }, 5000);
                    }
                } catch (error) {
                    console.error('Error in autoMatch:', error);
                }
            }
        }, 3000);
    }

    function stopAutoMatchInterval() {
        if (autoMatchInterval) {
            clearInterval(autoMatchInterval);
            autoMatchInterval = null;
        }
    }

    // ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
    // CLOCK OVERLAY
    // ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ

    function startClockInterval() {
        if (clockInterval) {
            clearInterval(clockInterval);
        }

        updateClockOverlay();
        clockInterval = setInterval(() => {
            try {
                updateClockOverlay();
            } catch (error) {
                console.error('Error updating clock overlay:', error);
            }
        }, 1000);
    }

    function stopClockInterval() {
        if (clockInterval) {
            clearInterval(clockInterval);
            clockInterval = null;
        }
    }
    // ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
    //                                                                                        MODE ANALISA
    // ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
    // ==================== VARIABLES ====================
    let panel = null;
    let isConnected = false;
    let isAnalyzing = false;
    let lastFen = '';
    let lastAnalyzedFen = '';
    let reconnectAttempts = 0;
    let autoAnalyzeTimeout = null;
    let currentArrow = null;

    // ==================== UTILITY FUNCTIONS ====================
    function log(message, type = 'info') {
        const prefix = '[Chess Helper]';
        switch(type) {
            case 'error': console.error(prefix, message); break;
            case 'warn': console.warn(prefix, message); break;
            default: console.log(prefix, message);
        }
    }

    function debounceAnalyze(func, wait) {
        let timeout;
        return function executedFunction(...args) {
            const later = () => {
                clearTimeout(timeout);
                func(...args);
            };
            clearTimeout(timeout);
            timeout = setTimeout(later, wait);
        };
    }

    // ==================== STATUS UPDATES ====================
    function updateStatus(text) {
        const status = document.getElementById('helper-status');
        if (status) status.textContent = text;
    }

    function updateIndicator(state) {
        const indicator = document.getElementById('status-indicator');
        if (!indicator) return;

        indicator.className = 'indicator';
        switch(state) {
            case 'connected': indicator.classList.add('connected'); break;
            case 'analyzing': indicator.classList.add('analyzing'); break;
            default: indicator.classList.add('disconnected');
        }
    }

    function setAnalyzing(analyzing) {
        isAnalyzing = analyzing;
        const btn = document.getElementById('analyze-btn');
        if (btn) {
            btn.disabled = analyzing;
            btn.innerHTML = analyzing
                ? '‚è≥ Menganalisis...'
            : 'üîç Analisis Posisi <span style="font-size: 11px; opacity: 0.7;">(Spasi)</span>';
        }
        updateIndicator(analyzing ? 'analyzing' : (isConnected ? 'connected' : 'disconnected'));
    }

    // ==================== GET FEN ====================
    function getFENanalyze() {
        if (typeof window !== 'undefined') {
            if (window.game?.getFEN) return window.game.getFEN();
            if (window.game?.fen) return typeof window.game.fen === 'function' ? window.game.fen() : window.game.fen;

            const boardElement = document.querySelector('chess-board, wc-chess-board');
            if (boardElement) {
                const game = boardElement.game || boardElement._game || boardElement.controller?.game;
                if (game?.getFEN) return game.getFEN();
                if (game?.fen) return typeof game.fen === 'function' ? game.fen() : game.fen;
            }
        }

        try {
            const liveGame = document.querySelector('.live-game-buttons-component');
            if (liveGame) {
                const reactFiber = Object.keys(liveGame).find(key => key.startsWith('__reactFiber'));
                if (reactFiber) {
                    let fiber = liveGame[reactFiber];
                    while (fiber) {
                        if (fiber.memoizedProps?.game?.getFEN) {
                            return fiber.memoizedProps.game.getFEN();
                        }
                        fiber = fiber.return;
                    }
                }
            }
        } catch (e) { }

        if (window.lichess?.analysis?.node?.fen) return window.lichess.analysis.node.fen;
        if (window.lichess?.round?.data?.game?.fen) return window.lichess.round.data.game.fen;

        const fenElement = document.querySelector('[data-fen]');
        if (fenElement?.dataset?.fen) return fenElement.dataset.fen;

        const scripts = document.querySelectorAll('script');
        for (const script of scripts) {
            const match = script.textContent?.match(/"fen":\s*"([^"]+)"/);
            if (match) return match[1];
        }

        const fenRegex = /([rnbqkpRNBQKP1-8]+\/){7}[rnbqkpRNBQKP1-8]+\s+[wb]\s+[KQkq-]+\s+[a-h1-8-]+\s+\d+\s+\d+/;
        const bodyMatch = document.body.innerHTML.match(fenRegex);
        if (bodyMatch) return bodyMatch[0];

        return null;
    }

    function getPlayerColoranalyze() {
        const board = document.querySelector('chess-board, wc-chess-board');
        if (board) {
            if (board.classList.contains('flipped')) return 'black';
            if (board.getAttribute('orientation')) return board.getAttribute('orientation');
        }

        const cgWrap = document.querySelector('.cg-wrap');
        if (cgWrap?.classList.contains('orientation-black')) return 'black';

        return 'white';
    }

    function getTurnanalyze(fen) {
        if (!fen) return null;
        const parts = fen.split(' ');
        return parts[1] === 'w' ? 'white' : 'black';
    }

    function isMyTurnanalyze() {
        const fen = getFENanalyze();
        const turn = getTurnanalyze(fen);
        const myColor = getPlayerColoranalyze();
        return turn === myColor;
    }

    function isBoardFlippedAnalyze() {
        const board = document.querySelector('chess-board, wc-chess-board');
        if (board) {
            return board.classList.contains('flipped') || board.getAttribute('flipped') === 'true';
        }
        const cgWrap = document.querySelector('.cg-wrap');
        return cgWrap?.classList.contains('orientation-black') || false;
    }

    // ==================== WEBSOCKET (Chess-API) ====================
    function connectWebSocket(callback) {
        if (ws && ws.readyState === WebSocket.OPEN) {
            if (callback) callback();
            return;
        }

        updateStatus('üîå Menghubungkan ke Chess-API...');
        ws = new WebSocket(BotState.CHESS_API_WS);

        ws.onopen = () => {
            isConnected = true;
            reconnectAttempts = 0;
            updateIndicator('connected');
            updateStatus('‚úÖ Terhubung ke Chess-API');
            log('WebSocket connected');
            if (callback) callback();
        };

        ws.onmessage = (event) => {
            try {
                const data = JSON.parse(event.data);
                handleAnalysisResult(data);
            } catch (e) {
                log('Parse error: ' + e.message, 'error');
            }
        };

        ws.onclose = () => {
            isConnected = false;
            updateIndicator('disconnected');

            const delay = Math.min(
                BotState.RECONNECT_INTERVAL * Math.pow(2, reconnectAttempts),
                BotState.MAX_RECONNECT_INTERVAL
            );
            reconnectAttempts++;

            log(`WebSocket closed, reconnecting in ${delay/1000}s...`);
            setTimeout(() => connectWebSocket(), delay);
        };

        ws.onerror = (error) => {
            log('WebSocket error', 'error');
            isConnected = false;
            updateIndicator('disconnected');
        };
    }

    // ==================== STOCKFISH ONLINE API ====================
    async function analyzeWithStockfishOnline(fen, depth) {
        const actualDepth = Math.min(Math.max(depth, 1), 15);
        const encodedFEN = encodeURIComponent(fen);
        const url = `${BotState.STOCKFISH_API}?fen=${encodedFEN}&depth=${actualDepth}&mode=bestmove`;

        log(`Analyzing with Stockfish Online (depth ${actualDepth})`);
        updateStatus(`‚òÅÔ∏è Stockfish Online (depth ${actualDepth})...`);

        const controller = new AbortController();
        const timeoutId = setTimeout(() => controller.abort(), BotState.TIMEOUT);

        try {
            const response = await fetch(url, {
                method: 'GET',
                signal: controller.signal
            });
            clearTimeout(timeoutId);

            if (!response.ok) {
                throw new Error(`HTTP ${response.status}: ${response.statusText}`);
            }

            const data = await response.json();
            log('Stockfish Online response:', data);

            if (!data.success) {
                throw new Error(data.data || 'Analysis failed');
            }

            let bestMove = data.bestmove || '';
            if (bestMove.startsWith('bestmove ')) {
                bestMove = bestMove.split(' ')[1];
            }

            let continuation = [];
            if (data.continuation) {
                continuation = data.continuation.split(' ').filter(m => m && !m.includes('bestmove'));
            }

            const pvMoves = [bestMove, ...continuation].filter(m => m && m.length >= 4);

            handleAnalysisResult({
                success: true,
                move: bestMove,
                eval: data.evaluation,
                mate: data.mate,
                depth: actualDepth,
                continuation: continuation,
                pvMoves: pvMoves
            });

        } catch (error) {
            clearTimeout(timeoutId);
            if (error.name === 'AbortError') {
                throw new Error('Request timeout');
            }
            throw error;
        }
    }

    // ==================== ANALYZE POSITION ====================
    async function analyzePosition() {
        const fen = getFENanalyze();

        if (!fen) {
            updateStatus('‚ùå Tidak dapat menemukan posisi FEN');
            log('Could not find FEN', 'error');
            return;
        }

        if (fen === lastAnalyzedFen && !isAnalyzing) {
            updateStatus('‚ÑπÔ∏è Posisi sudah dianalisis');
            return;
        }

        setAnalyzing(true);
        lastFen = fen;

        try {
            if (BotState.USE_STOCKFISH_ONLINE) {
                await analyzeWithStockfishOnline(fen, BotState.DEPTH);
            } else if (BotState.USE_WEBSOCKET) {
                await analyzeWithWebSocket(fen);
            }
            lastAnalyzedFen = fen;
        } catch (error) {
            log('Analysis error: ' + error.message, 'error');
            updateStatus('‚ùå Error: ' + error.message);
            setAnalyzing(false);
        }
    }

    async function analyzeWithWebSocket(fen) {
        return new Promise((resolve, reject) => {
            const payload = {
                fen: fen,
                depth: BotState.DEPTH,
                maxThinkingTime: BotState.MAX_THINKING_TIME,
                multiPV: BotState.pvArrowCount || 3
            };

            if (!ws || ws.readyState !== WebSocket.OPEN) {
                connectWebSocket(() => {
                    ws.send(JSON.stringify(payload));
                    resolve();
                });
            } else {
                ws.send(JSON.stringify(payload));
                resolve();
            }
        });
    }

    // ==================== PV ARROW COLORS ====================
    const PV_ARROW_COLORS = [
        { stroke: '#22c55e', fill: 'rgba(34, 197, 94, 0.8)', badge: '#22c55e' }, // 1 - Green
        { stroke: '#3b82f6', fill: 'rgba(59, 130, 246, 0.7)', badge: '#3b82f6' }, // 2 - Blue
        { stroke: '#f97316', fill: 'rgba(249, 115, 22, 0.7)', badge: '#f97316' }, // 3 - Orange
        { stroke: '#a855f7', fill: 'rgba(168, 85, 247, 0.6)', badge: '#a855f7' }, // 4 - Purple
        { stroke: '#ec4899', fill: 'rgba(236, 72, 153, 0.6)', badge: '#ec4899' }, // 5 - Pink
        { stroke: '#14b8a6', fill: 'rgba(20, 184, 166, 0.5)', badge: '#14b8a6' }, // 6 - Teal
        { stroke: '#eab308', fill: 'rgba(234, 179, 8, 0.5)', badge: '#eab308' }, // 7 - Yellow
        { stroke: '#6366f1', fill: 'rgba(99, 102, 241, 0.5)', badge: '#6366f1' } // 8 - Indigo
    ];

    // ==================== HANDLE ANALYSIS RESULT ====================
    function handleAnalysisResult(result) {
        setAnalyzing(false);

        if (result.type === 'info') {
            updateStatus(`üîç Analyzing depth ${result.depth || '?'}...`);
            return;
        }

        const move = result.san || result.move || result.bestMove || '‚Äî';

        // ============ EVALUATION CALCULATION ============
        let evalText = '0.00';
        let evalPercent = 50;
        let evalColor = '#fbbf24';
        let isMate = false;

        if (result.mate !== undefined && result.mate !== null && result.mate !== 0) {
            isMate = true;
            const mateIn = result.mate;
            evalText = `M${mateIn > 0 ? '+' : ''}${mateIn}`;
            evalPercent = mateIn > 0 ? 95 : 5;
            evalColor = mateIn > 0 ? '#22c55e' : '#ef4444';
        } else {
            let centipawns = 0;

            if (result.eval !== undefined && result.eval !== null) {
                centipawns = Number(result.eval);
            } else if (result.evaluation !== undefined && result.evaluation !== null) {
                centipawns = Number(result.evaluation);
            } else if (result.score !== undefined && result.score !== null) {
                centipawns = Number(result.score);
            }

            const pawns = centipawns / 100;
            evalText = (pawns >= 0 ? '+' : '') + pawns.toFixed(2);

            const clampedPawns = Math.max(-10, Math.min(10, pawns));
            evalPercent = 50 + (clampedPawns * 4.5);
            evalPercent = Math.max(5, Math.min(95, evalPercent));

            if (pawns >= 3) {
                evalColor = '#22c55e';
            } else if (pawns >= 1) {
                evalColor = '#4ade80';
            } else if (pawns >= 0.3) {
                evalColor = '#86efac';
            } else if (pawns <= -3) {
                evalColor = '#ef4444';
            } else if (pawns <= -1) {
                evalColor = '#f87171';
            } else if (pawns <= -0.3) {
                evalColor = '#fca5a5';
            } else {
                evalColor = '#fbbf24';
            }
        }

        const depth = result.depth || BotState.DEPTH;

        // ============ EXTRACT PV MOVES ============
        let continuation = '‚Äî';
        let pvMoves = [];

        if (result.pvMoves && Array.isArray(result.pvMoves)) {
            pvMoves = result.pvMoves;
            continuation = pvMoves.slice(0, 8).join(' ‚Üí ');
        } else if (result.continuation) {
            const moves = Array.isArray(result.continuation)
            ? result.continuation
            : result.continuation.split(' ');
            const bestMove = result.move || result.bestMove || '';
            pvMoves = [bestMove, ...moves].filter(m => m && m.length >= 4);
            continuation = moves.slice(0, 8).join(' ‚Üí ');
        } else if (result.pv) {
            const moves = Array.isArray(result.pv) ? result.pv : result.pv.split(' ');
            pvMoves = moves.filter(m => m && m.length >= 4);
            continuation = moves.slice(0, 8).join(' ‚Üí ');
        }

        // ============ UPDATE UI ============
        const bestMoveEl = document.getElementById('best-move');
        if (bestMoveEl) bestMoveEl.textContent = move.toUpperCase();

        const evalScoreEl = document.getElementById('eval-score');
        if (evalScoreEl) {
            evalScoreEl.textContent = evalText;
            evalScoreEl.style.color = evalColor;
            evalScoreEl.style.fontWeight = isMate ? 'bold' : 'normal';
            if (isMate) {
                evalScoreEl.style.textShadow = '0 0 8px ' + evalColor;
            } else {
                evalScoreEl.style.textShadow = 'none';
            }
        }

        const depthEl = document.getElementById('depth-info');
        if (depthEl) depthEl.textContent = depth;

        const continuationEl = document.getElementById('continuation');
        if (continuationEl) continuationEl.textContent = continuation;

        updateEvalBar(evalPercent, evalColor, evalText);
        updateStatus('‚úÖ Analisis selesai');
        updateIndicator('connected');

        // ============ DRAW ARROWS ============
        const moveUCI = result.from && result.to ? (result.from + result.to) : move;

        if (BotState.HIGHLIGHT_SQUARES) {
            highlightMoveAnalyze(moveUCI);
        }

        if (BotState.SHOW_ARROWS || BotState.showPVArrows) {
            if (pvMoves.length > 0 && BotState.showPVArrows) {
                drawPVArrowsSequential(pvMoves);
            } else {
                drawSingleArrow(moveUCI, PV_ARROW_COLORS[0], 1);
            }
        }

        log(`Best move: ${move}, Eval: ${evalText} (${evalPercent.toFixed(1)}%), Depth: ${depth}, PV: ${pvMoves.length} moves`);
    }

    // ==================== EVALUATION BAR ====================
    function updateEvalBar(percent, color, evalText) {
        const evalBarFill = document.getElementById('eval-bar-fill');
        if (!evalBarFill) {
            log('Eval bar fill element not found', 'warn');
            return;
        }

        const validPercent = Math.max(0, Math.min(100, Number(percent) || 50));
        log(`Updating eval bar: ${validPercent.toFixed(1)}% | Color: ${color}`);

        evalBarFill.style.transition = 'width 0.5s ease, background 0.5s ease';
        evalBarFill.style.width = `${validPercent}%`;

        if (validPercent >= 50) {
            evalBarFill.style.background = `linear-gradient(90deg, #475569 0%, ${color} 100%)`;
        } else {
            evalBarFill.style.background = `linear-gradient(90deg, ${color} 0%, #475569 100%)`;
        }

        if (validPercent >= 80 || validPercent <= 20) {
            evalBarFill.style.boxShadow = `0 0 12px ${color}, inset 0 0 8px rgba(255,255,255,0.2)`;
        } else {
            evalBarFill.style.boxShadow = 'inset 0 0 8px rgba(255,255,255,0.1)';
        }

        const evalBarContainer = document.querySelector('.eval-bar');
        if (evalBarContainer) {
            evalBarContainer.style.borderColor = color;
        }

        const barLabel = document.getElementById('eval-bar-label');
        if (barLabel) {
            barLabel.textContent = evalText;
        }
    }

    // ==================== DRAW PV ARROWS (SEQUENTIAL - NO OVERLAP) ====================
    function drawPVArrowsSequential(pvMoves) {
        removeAllArrows();

        if (!pvMoves || pvMoves.length === 0) {
            log('No PV moves to draw', 'warn');
            return;
        }

        const board = document.querySelector('chess-board, wc-chess-board, cg-board, .cg-wrap');
        if (!board) {
            log('Chess board not found', 'warn');
            return;
        }

        const boardRect = board.getBoundingClientRect();
        const squareSize = boardRect.width / 8;
        const isFlipped = isBoardFlippedAnalyze();

        // Create SVG container
        const svg = document.createElementNS('http://www.w3.org/2000/svg', 'svg');
        svg.classList.add('chess-helper-pv-arrows');
        svg.style.cssText = `
        position: absolute;
        top: 0;
        left: 0;
        width: ${boardRect.width}px;
        height: ${boardRect.height}px;
        pointer-events: none;
        z-index: 100;
        overflow: visible;
    `;

        board.style.position = 'relative';

        const maxArrows = Math.min(BotState.pvArrowCount || 5, pvMoves.length, PV_ARROW_COLORS.length);
        log(`Drawing ${maxArrows} PV arrows from ${pvMoves.length} moves`);

        // Draw arrows from LAST to FIRST (so arrow #1 is on top)
        for (let i = maxArrows - 1; i >= 0; i--) {
            const move = pvMoves[i];
            if (!move || move.length < 4) continue;

            const from = move.substring(0, 2).toLowerCase();
            const to = move.substring(2, 4).toLowerCase();

            const fromCoords = squareToCoords(from, squareSize, isFlipped);
            const toCoords = squareToCoords(to, squareSize, isFlipped);

            if (!fromCoords || !toCoords) {
                log(`Invalid coordinates for move ${move}`, 'warn');
                continue;
            }

            const color = PV_ARROW_COLORS[i];
            const isFirst = i === 0;

            const lineWidth = isFirst ? 12 : Math.max(4, 10 - i * 1.5);
            const opacity = isFirst ? 1 : Math.max(0.4, 1 - i * 0.15);
            const arrowHeadSize = squareSize * (isFirst ? 0.45 : 0.35 - i * 0.02);

            const group = document.createElementNS('http://www.w3.org/2000/svg', 'g');
            group.setAttribute('data-move', move);
            group.setAttribute('data-rank', i + 1);

            const dx = toCoords.x - fromCoords.x;
            const dy = toCoords.y - fromCoords.y;
            const angle = Math.atan2(dy, dx);

            const endX = toCoords.x - Math.cos(angle) * arrowHeadSize * 0.7;
            const endY = toCoords.y - Math.sin(angle) * arrowHeadSize * 0.7;

            // Outline for first arrow
            if (isFirst) {
                const outline = document.createElementNS('http://www.w3.org/2000/svg', 'line');
                outline.setAttribute('x1', fromCoords.x);
                outline.setAttribute('y1', fromCoords.y);
                outline.setAttribute('x2', endX);
                outline.setAttribute('y2', endY);
                outline.setAttribute('stroke', '#000');
                outline.setAttribute('stroke-width', lineWidth + 4);
                outline.setAttribute('stroke-linecap', 'round');
                outline.setAttribute('opacity', '0.3');
                group.appendChild(outline);
            }

            // Main line
            const line = document.createElementNS('http://www.w3.org/2000/svg', 'line');
            line.setAttribute('x1', fromCoords.x);
            line.setAttribute('y1', fromCoords.y);
            line.setAttribute('x2', endX);
            line.setAttribute('y2', endY);
            line.setAttribute('stroke', color.stroke);
            line.setAttribute('stroke-width', lineWidth);
            line.setAttribute('stroke-linecap', 'round');
            line.setAttribute('opacity', opacity);
            group.appendChild(line);

            // Arrow head
            const headPoints = [
                [toCoords.x, toCoords.y],
                [toCoords.x - arrowHeadSize * Math.cos(angle - 0.5), toCoords.y - arrowHeadSize * Math.sin(angle - 0.5)],
                [toCoords.x - arrowHeadSize * Math.cos(angle + 0.5), toCoords.y - arrowHeadSize * Math.sin(angle + 0.5)]
            ];

            const arrowHead = document.createElementNS('http://www.w3.org/2000/svg', 'polygon');
            arrowHead.setAttribute('points', headPoints.map(p => p.join(',')).join(' '));
            arrowHead.setAttribute('fill', color.fill);
            arrowHead.setAttribute('opacity', opacity);
            group.appendChild(arrowHead);

            // Rank badge
            if (BotState.showPVRankBadges !== false) {
                const badgeRadius = squareSize * (isFirst ? 0.22 : 0.18);

                // Shadow
                const badgeShadow = document.createElementNS('http://www.w3.org/2000/svg', 'circle');
                badgeShadow.setAttribute('cx', fromCoords.x + 2);
                badgeShadow.setAttribute('cy', fromCoords.y + 2);
                badgeShadow.setAttribute('r', badgeRadius);
                badgeShadow.setAttribute('fill', 'rgba(0,0,0,0.3)');
                group.appendChild(badgeShadow);

                // Circle
                const badge = document.createElementNS('http://www.w3.org/2000/svg', 'circle');
                badge.setAttribute('cx', fromCoords.x);
                badge.setAttribute('cy', fromCoords.y);
                badge.setAttribute('r', badgeRadius);
                badge.setAttribute('fill', color.badge);
                badge.setAttribute('stroke', '#fff');
                badge.setAttribute('stroke-width', isFirst ? '3' : '2');
                group.appendChild(badge);

                // Number
                const text = document.createElementNS('http://www.w3.org/2000/svg', 'text');
                text.setAttribute('x', fromCoords.x);
                text.setAttribute('y', fromCoords.y);
                text.setAttribute('text-anchor', 'middle');
                text.setAttribute('dominant-baseline', 'central');
                text.setAttribute('fill', '#fff');
                text.setAttribute('font-size', badgeRadius * 1.4);
                text.setAttribute('font-weight', 'bold');
                text.setAttribute('font-family', 'Arial, sans-serif');
                text.textContent = i + 1;
                group.appendChild(text);
            }

            svg.appendChild(group);
        }

        board.appendChild(svg);
        log(`Successfully drew ${maxArrows} PV arrows`);
    }

    // ==================== SINGLE ARROW ====================
    function drawSingleArrow(move, color, rank) {
        if (!move || move.length < 4) return;
        drawPVArrowsSequential([move]);
    }

    function drawArrowAnalyze(move) {
        drawSingleArrow(move, PV_ARROW_COLORS[0], 1);
    }

    // ==================== SQUARE TO COORDINATES ====================
    function squareToCoords(square, squareSize, isFlipped) {
        if (!square || square.length !== 2) return null;

        const file = square.charCodeAt(0) - 'a'.charCodeAt(0);
        const rank = parseInt(square[1]) - 1;

        let x, y;
        if (isFlipped) {
            x = (7 - file) * squareSize + squareSize / 2;
            y = rank * squareSize + squareSize / 2;
        } else {
            x = file * squareSize + squareSize / 2;
            y = (7 - rank) * squareSize + squareSize / 2;
        }

        return { x, y };
    }

    // ==================== HIGHLIGHT MOVES ====================
    function highlightMoveAnalyze(move) {
        document.querySelectorAll('.chess-helper-highlight, .chess-helper-from, .chess-helper-to').forEach(el => {
            el.classList.remove('chess-helper-highlight', 'chess-helper-from', 'chess-helper-to');
        });

        if (!move || move.length < 4) return;

        const from = move.substring(0, 2).toLowerCase();
        const to = move.substring(2, 4).toLowerCase();

        // Chess.com
        document.querySelectorAll(`[data-square="${from}"]`).forEach(el => {
            el.classList.add('chess-helper-from');
        });
        document.querySelectorAll(`[data-square="${to}"]`).forEach(el => {
            el.classList.add('chess-helper-to');
        });

        // Lichess
        document.querySelectorAll(`.square-${from}, .${from}`).forEach(el => {
            el.classList.add('chess-helper-from');
        });
        document.querySelectorAll(`.square-${to}, .${to}`).forEach(el => {
            el.classList.add('chess-helper-to');
        });
    }

    // ==================== REMOVE ARROWS ====================
    function removeAllArrows() {
        document.querySelectorAll('.chess-helper-arrow, .chess-helper-pv-arrows').forEach(el => el.remove());
        if (typeof currentArrow !== 'undefined') currentArrow = null;
    }

    function removeArrowAnalyze() {
        removeAllArrows();
    }

    // ==================== AUTO ANALYZE ====================
    function setupAutoAnalyze() {
        const observer = new MutationObserver(debounceAnalyze(() => {
            if (!BotState.AUTO_ANALYZE) return;

            const currentFen = getFENanalyze();
            if (currentFen && currentFen !== lastFen && !isAnalyzing) {
                log('Position changed, auto-analyzing...');
                clearTimeout(autoAnalyzeTimeout);
                autoAnalyzeTimeout = setTimeout(analyzePosition, BotState.AUTO_ANALYZE_DELAY);
            }
        }, 300));

        const chessBoards = document.querySelectorAll('chess-board, wc-chess-board, .board');
        chessBoards.forEach(board => {
            observer.observe(board, {
                childList: true,
                subtree: true,
                attributes: true,
                characterData: true
            });
        });

        const lichessBoards = document.querySelectorAll('.cg-wrap, .analyse__board, .round__app');
        lichessBoards.forEach(board => {
            observer.observe(board, {
                childList: true,
                subtree: true,
                attributes: true
            });
        });

        const bodyObserver = new MutationObserver(() => {
            const newBoards = document.querySelectorAll('chess-board, wc-chess-board, .cg-wrap');
            newBoards.forEach(board => {
                if (!board.hasAttribute('data-helper-observed')) {
                    board.setAttribute('data-helper-observed', 'true');
                    observer.observe(board, {
                        childList: true,
                        subtree: true,
                        attributes: true
                    });
                }
            });
        });

        bodyObserver.observe(document.body, { childList: true, subtree: true });
    }

    // ==================== HOTKEYS ====================
    function setupHotkeys() {
        document.addEventListener('keydown', (e) => {
            if (e.target.matches('input, textarea, [contenteditable]')) return;

            // SPACE - Analyze
            if (e.key === BotState.HOTKEY_ANALYZE) {
                e.preventDefault();
                if (!isAnalyzing) analyzePosition();
            }

            // P - Toggle PV Arrows
            if (e.key.toLowerCase() === 'p' && !e.ctrlKey && !e.altKey) {
                e.preventDefault();
                BotState.showPVArrows = !BotState.showPVArrows;
                log(`PV Arrows: ${BotState.showPVArrows ? 'ON' : 'OFF'}`);
                updateStatus(`PV Arrows: ${BotState.showPVArrows ? 'ON ‚úì' : 'OFF ‚úó'}`);
                if (!BotState.showPVArrows) {
                    removeAllArrows();
                } else if (lastAnalyzedFen) {
                    analyzePosition();
                }
            }

            // C - Clear arrows
            if (e.key.toLowerCase() === 'c' && !e.ctrlKey && !e.altKey) {
                e.preventDefault();
                removeAllArrows();
                log('Arrows cleared');
                updateStatus('Arrows cleared');
            }
        });
    }

    // ==================== INJECT STYLES ====================
    function injectHelperStyles(helperStyles) {
        if (!document.getElementById('chess-helper-styles')) {
            const styleEl = document.createElement('style');
            styleEl.id = 'chess-helper-styles';
            styleEl.textContent = helperStyles;
            document.head.appendChild(styleEl);
        }
    }
    // ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
    // ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
    // PANEL DRAGGABLE - IMPROVED
    // ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ

    function makePanelDraggable(panel) {
        if (!panel) return;

        let isDragging = false;
        let dragHandler = null;

        function clampToViewport() {
            const rect = panel.getBoundingClientRect();
            const vw = window.innerWidth;
            const vh = window.innerHeight;
            const margin = 8;

            panel.style.right = 'auto';

            let left = parseFloat(panel.style.left) || rect.left;
            let top = parseFloat(panel.style.top) || rect.top;

            left = Math.max(margin, Math.min(left, vw - rect.width - margin));
            top = Math.max(margin, Math.min(top, vh - rect.height - margin));

            panel.style.left = left + 'px';
            panel.style.top = top + 'px';
        }

        function allowDragFromTarget(target, e) {
            if (e.altKey) return true;

            const rect = panel.getBoundingClientRect();
            const m = 14;
            const nearEdge =
                  e.clientX <= rect.left + m ||
                  e.clientX >= rect.right - m ||
                  e.clientY <= rect.top + m ||
                  e.clientY >= rect.bottom - m;

            if (nearEdge) return true;

            if (target.closest('input, select, textarea, button, label, a, .no-drag')) {
                return false;
            }

            return true;
        }

        function startDrag(e) {
            if (isDragging) return;

            e.preventDefault();
            isDragging = true;

            const startRect = panel.getBoundingClientRect();

            panel.classList.add('grabbing');
            panel.style.right = 'auto';
            panel.style.left = startRect.left + 'px';
            panel.style.top = startRect.top + 'px';

            const startX = e.clientX;
            const startY = e.clientY;

            const move = (ev) => {
                if (!isDragging) return;

                const dx = ev.clientX - startX;
                const dy = ev.clientY - startY;
                const vw = window.innerWidth;
                const vh = window.innerHeight;

                let newLeft = startRect.left + dx;
                let newTop = startRect.top + dy;

                const margin = 8;
                const maxLeft = Math.max(margin, vw - startRect.width - margin);
                const maxTop = Math.max(margin, vh - startRect.height - margin);

                newLeft = Math.min(Math.max(newLeft, margin), maxLeft);
                newTop = Math.min(Math.max(newTop, margin), maxTop);

                panel.style.left = newLeft + 'px';
                panel.style.top = newTop + 'px';
            };

            const up = () => {
                isDragging = false;
                document.removeEventListener('mousemove', move);
                document.removeEventListener('mouseup', up);
                panel.classList.remove('grabbing');

                try {
                    ui?.BotStateUtils?.save?.();
                } catch (error) {
                    // Ignore save errors
                }
            };

            document.addEventListener('mousemove', move);
            document.addEventListener('mouseup', up);
        }

        // Store handler for potential cleanup
        dragHandler = (e) => {
            if (e.button !== 0) return;
            if (!allowDragFromTarget(e.target, e)) return;
            startDrag(e);
        };

        panel.addEventListener('mousedown', dragHandler);
        window.addEventListener('resize', clampToViewport);

        // Initial clamp
        requestAnimationFrame(clampToViewport);

        // Return cleanup function
        return () => {
            panel.removeEventListener('mousedown', dragHandler);
            window.removeEventListener('resize', clampToViewport);
        };
    }

    // ==================== INITIALIZATION ====================
    async function initialize() {
        try {
            log('Initializing v3.0...');
            Logger.info(`Initializing ${SCRIPT_NAME} v${VERSION}...`);

            // Connect WebSocket if needed
            if (BotState.USE_WEBSOCKET && !BotState.USE_STOCKFISH_ONLINE) {
                connectWebSocket();
            } else {
                updateIndicator('connected');
            }
            injectHelperStyles();
            // Load saved settings
            BotStateUtils.load();
            Logger.debug('Settings:', BotStateUtils.getSummary());

            // Setup features
            setupHotkeys();
            setTimeout(setupAutoAnalyze, 1500);

            // Build UI
            await buildUI();

            // Initial analysis after short delay
            setTimeout(() => {
                const fen = getFENanalyze();
                if (fen) {
                    log('Board detected, ready for analysis');
                    updateStatus('üéØ Board terdeteksi. Tekan Spasi untuk analisis.');
                }
            }, 2000);

            // Start DOM board watcher
            startDomBoardWatcher();

            // Start clock
            startClockInterval();

            // Start main loops if enabled
            if (isBotEnabled()) {
                startTickLoop();
                startAutoWatchers();
                startAutoMatchInterval();
            }

            log('Ready! Using ' + (BotState.USE_STOCKFISH_ONLINE ? 'Stockfish Online API' : 'Chess-API WebSocket'));
            Logger.info('Initialization complete');
        } catch (error) {
            Logger.error('Initialization failed:', error);
        }
    }

    // Handle page unload
    window.addEventListener('beforeunload', cleanup);

    // Handle visibility change
    document.addEventListener('visibilitychange', () => {
        if (document.hidden) {
            Logger.debug('Tab hidden, pausing...');
        } else {
            Logger.debug('Tab visible, resuming...');
            if (isBotEnabled()) {
                lastFenProcessedMain = '';
                tick();
            }
        }
    });

    // Start initialization
    initialize();
})();
